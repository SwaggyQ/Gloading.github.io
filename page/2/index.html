<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拉塞尔FMVP了吗">
<meta name="keywords" content="Dloading...">
<meta property="og:type" content="website">
<meta property="og:title" content="Dloading...">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Dloading...">
<meta property="og:description" content="拉塞尔FMVP了吗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dloading...">
<meta name="twitter:description" content="拉塞尔FMVP了吗">





  
  
  <link rel="canonical" href="http://yoursite.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dloading...</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dloading...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">努力成为优秀程序员</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/15/jdk/聊一聊HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/15/jdk/聊一聊HashMap/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-15 23:39:18" itemprop="dateCreated datePublished" datetime="2019-02-15T23:39:18+08:00">2019-02-15</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-10 00:46:13" itemprop="dateModified" datetime="2019-03-10T00:46:13+08:00">2019-03-10</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈HashMap"><a href="#谈谈HashMap" class="headerlink" title="谈谈HashMap"></a>谈谈HashMap</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk-1-8讲讲他底层是怎么实现的，并会对比jdk-1-7看看这两个版本做了什么修改"><a href="#最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk-1-8讲讲他底层是怎么实现的，并会对比jdk-1-7看看这两个版本做了什么修改" class="headerlink" title="最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk 1.8讲讲他底层是怎么实现的，并会对比jdk 1.7看看这两个版本做了什么修改"></a>最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk 1.8讲讲他底层是怎么实现的，并会对比jdk 1.7看看这两个版本做了什么修改</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？"><a href="#按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？" class="headerlink" title="按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？"></a>按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">     this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句"><a href="#总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句" class="headerlink" title="总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句"></a>总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

<h4 id="我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。-例如传入7会得到8，传入13会返回16。-这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。"><a href="#我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。-例如传入7会得到8，传入13会返回16。-这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。" class="headerlink" title="我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。 例如传入7会得到8，传入13会返回16。 这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。"></a>我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。 例如传入7会得到8，传入13会返回16。 这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。</h4><h4 id="既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。"><a href="#既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。" class="headerlink" title="既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。"></a>既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash-方法"><a href="#这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash-方法" class="headerlink" title="这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash()方法"></a>这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位-后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。"><a href="#这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位-后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。" class="headerlink" title="这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位 ^ 后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。"></a>这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位 ^ 后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">           n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<h4 id="在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。"><a href="#在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。" class="headerlink" title="在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。"></a>在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br></pre></td></tr></table></figure>

<h4 id="那这个Node是什么呢？这边插播一下Node的定义"><a href="#那这个Node是什么呢？这边插播一下Node的定义" class="headerlink" title="那这个Node是什么呢？这边插播一下Node的定义"></a>那这个Node是什么呢？这边插播一下Node的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组-链表的格式组成的。"><a href="#可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组-链表的格式组成的。" class="headerlink" title="可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组+链表的格式组成的。"></a>可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组+链表的格式组成的。</h4><h4 id="好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。"><a href="#好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。" class="headerlink" title="好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。"></a>好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// (n-1) &amp; hash 计算出给定的key应该保存在数组的第几个位置中</span><br><span class="line">// 如果数组的这个位置现在还是空的，则可以直接new一个Node作为第一个占位的节点，放在给定的位置</span><br><span class="line">   if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">          tab[i] = newNode(hash, key, value, null);</span><br><span class="line">      else &#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。"><a href="#如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。" class="headerlink" title="如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。"></a>如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。</h4><ul>
<li><p>新加入的key已经在数组存在了，这个put操作就成为了用新数据更新旧数据的操作</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">       e = p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数组中存在的链表中继续添加新节点。注意当链表长度大于8的时候，链表会转化为红黑树。这也是jdk 1.8中新增的功能，避免了1.7版本中链表长度过长造成的查询效率低的问题。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">		// 到达了链表的末尾，则只需要将原尾节点的后继指针指向新加入的节点</span><br><span class="line">           if ((e = p.next) == null) &#123;</span><br><span class="line">               p.next = newNode(hash, key, value, null);</span><br><span class="line">               // 当链表长度大于7的时候，就会红黑树化</span><br><span class="line">               if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                   treeifyBin(tab, hash);</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           // 若在链表中已存在key</span><br><span class="line">           if (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               break;</span><br><span class="line">           p = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 将原数组中的对应位置的链表转为红黑树</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">       int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       // 如果原有的数组的容量小于64，则直接去扩容</span><br><span class="line">       if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       // 已达到转化的阈值，则开始转换</span><br><span class="line">       else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = null, tl = null; // 树的首尾节点</span><br><span class="line">           do &#123;</span><br><span class="line">           	// 将原有的Node节点，转为TreeNode</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">               if (tl == null)</span><br><span class="line">                   hd = p;</span><br><span class="line">               else &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; while ((e = e.next) != null);</span><br><span class="line">           if ((tab[index] = hd) != null)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>在数组中的链表已经转为了红黑树</li>
</ul>
<h4 id="好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法"><a href="#好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法" class="headerlink" title="好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法"></a>好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。"><a href="#可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。" class="headerlink" title="可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。"></a>可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 找到底层数组对应的桶位的第一个节点，直接查看是否满足要求，是的话可以直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">        	// 若节点已经是红黑树的一部分，则用查找红黑树的方式得到想要的节点</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            // 若是链表，则可以直接按照链表来查找</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Java7-是先扩容后插入新值的，Java8-先插值再扩容"><a href="#Java7-是先扩容后插入新值的，Java8-先插值再扩容" class="headerlink" title="Java7 是先扩容后插入新值的，Java8 先插值再扩容"></a>Java7 是先扩容后插入新值的，Java8 先插值再扩容</h1>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/jdk/HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/jdk/HashTable/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-14 14:59:57" itemprop="dateCreated datePublished" datetime="2019-02-14T14:59:57+08:00">2019-02-14</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-18 13:31:13" itemprop="dateModified" datetime="2019-02-18T13:31:13+08:00">2019-02-18</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊一聊HashTable"><a href="#聊一聊HashTable" class="headerlink" title="聊一聊HashTable"></a>聊一聊HashTable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"><a href="#关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下" class="headerlink" title="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"></a>关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"><a href="#大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？" class="headerlink" title="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"></a>大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？</h4><h4 id="这边用一个小例子作为入口，我们可以进去一探究竟"><a href="#这边用一个小例子作为入口，我们可以进去一探究竟" class="headerlink" title="这边用一个小例子作为入口，我们可以进去一探究竟"></a>这边用一个小例子作为入口，我们可以进去一探究竟</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    Hashtable hb = new Hashtable();</span><br><span class="line">    // 存储</span><br><span class="line">    hb.put(&quot;1&quot;,new Integer(1));</span><br><span class="line">    hb.put(&quot;2&quot;,new Integer(2));</span><br><span class="line">    hb.put(&quot;3&quot;,new Integer(3));</span><br><span class="line">    // 取值</span><br><span class="line">    System.out.println(hb.get(&quot;1&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;2&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;3&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"><a href="#这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。" class="headerlink" title="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"></a>这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。</h4><ul>
<li>初始化 </li>
<li>存储</li>
<li>取值</li>
</ul>
<h4 id="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"><a href="#这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现" class="headerlink" title="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"></a>这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现</h4><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h4 id="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"><a href="#当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。" class="headerlink" title="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"></a>当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。</h4><h1 id="TODO-构造函数截图"><a href="#TODO-构造函数截图" class="headerlink" title="TODO 构造函数截图"></a>TODO 构造函数截图</h1><h4 id="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"><a href="#从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。" class="headerlink" title="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"></a>从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity==0)</span><br><span class="line">        initialCapacity = 1;</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 上面的代码主要对参数的格式做了一些检验，例如initialCapacity不能为负数，而且最小也必须是1，</span><br><span class="line">    // loadFactor 必须是大于零的浮点数</span><br><span class="line">    </span><br><span class="line">    // 再根据initialCapacity参数创建一个Entry数组</span><br><span class="line">    table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    // 初始化threshold，(两个参数的乘积)和(Int最大值-8)中的较小值</span><br><span class="line">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。"><a href="#这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。" class="headerlink" title="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。"></a>这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。</h4><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h4 id="现在我们看一下当我们put的时候，内部发生了什么"><a href="#现在我们看一下当我们put的时候，内部发生了什么" class="headerlink" title="现在我们看一下当我们put的时候，内部发生了什么"></a>现在我们看一下当我们put的时候，内部发生了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 可以看到这个方法名上加了synchronized，这和在HashMap上是有不一样的地方</span><br><span class="line">   public synchronized V put(K key, V value) &#123;</span><br><span class="line">       // Make sure the value is not null</span><br><span class="line">       if (value == null) &#123;</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Makes sure the key is not already in the hashtable.</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       // 会取传入的键的Hashcode，所以每个字符串的Hashcode都是一样的</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       // 通过计算得到当前键在Entry数组中的下标</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       // 取出在数组中指定下标已存在的值，指定下标取出来可能是一个链表，在Entry中存有链表后继结点的引用</span><br><span class="line">       Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">       	// 必须双重判断hash值一样，而且键值内容一样，才能说明传入的key已存在</span><br><span class="line">           if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">           	// 若已存在，则替换新传入的值，并返回旧值</span><br><span class="line">               V old = entry.value;</span><br><span class="line">               entry.value = value;</span><br><span class="line">               return old;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	// 若key在原结构中不存在，则需要新增</span><br><span class="line">       addEntry(hash, key, value, index);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="继续看看往存储结构中新增一个key的时候做了什么操作"><a href="#继续看看往存储结构中新增一个key的时候做了什么操作" class="headerlink" title="继续看看往存储结构中新增一个key的时候做了什么操作"></a>继续看看往存储结构中新增一个key的时候做了什么操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">	// 这个字段作为修改的一个version值做后续的版本控制</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">	// count是当前数组中已有的Entry的数目</span><br><span class="line">	// 如果比原定的threshold要大，则需要重新进行一次hash重分配</span><br><span class="line">    if (count &gt;= threshold) &#123;</span><br><span class="line">        // Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 在Entry数组对应的index的位置创建一个值，并把可能原有的值作为新增节点在链表中的后继结点存储，所以在链表中是新的节点排在链表前面</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。"><a href="#新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。" class="headerlink" title="新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。"></a>新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">	// old容量 默认为11</span><br><span class="line">       int oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">       // overflow-conscious code</span><br><span class="line">       // new容量 = (11 &lt;&lt; 1) + 1 = 23 </span><br><span class="line">       int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">       // MAX_ARRAY_SIZE 是Int.max - 8， 如果新的容量比这个数值还要大的话，要进行进一步的考量</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">           if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               // Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">               return;</span><br><span class="line">           newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       // 用新的容量创建一个新的数组</span><br><span class="line">       Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       // 重新计算threshold</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">       table = newMap;</span><br><span class="line">	// 从原有数组的末尾，从后往前扫描每一个节点，按照新的容量计算新的index。</span><br><span class="line">       for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">           for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">               newMap[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"><a href="#好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程" class="headerlink" title="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"></a>好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程</h4><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 同样是一个同步的方法</span><br><span class="line">   public synchronized V get(Object key) &#123;</span><br><span class="line">   	// 整个方法是不是似曾相识？在我们第二步的存储的代码中，已经包含了这一部分代码。当时是为了确定存入的值是否已经存在。所以这边也不赘述了</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">           if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               return (V)e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"><a href="#大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。" class="headerlink" title="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"></a>大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/设计模式/门面模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/14/设计模式/门面模式/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-14 14:32:05" itemprop="dateCreated datePublished" datetime="2019-02-14T14:32:05+08:00">2019-02-14</time>
            </span>
          

          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#设计模式(二) 门面模式</p>
<h2 id="先占个坑"><a href="#先占个坑" class="headerlink" title="先占个坑"></a>先占个坑</h2><h3 id="门面模式的意思，现在了解起来就是将多个子功能的功能函数，通过一个总开关代理的方式，方便的调用所有功能"><a href="#门面模式的意思，现在了解起来就是将多个子功能的功能函数，通过一个总开关代理的方式，方便的调用所有功能" class="headerlink" title="门面模式的意思，现在了解起来就是将多个子功能的功能函数，通过一个总开关代理的方式，方便的调用所有功能"></a>门面模式的意思，现在了解起来就是将多个子功能的功能函数，通过一个总开关代理的方式，方便的调用所有功能</h3><h3 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h3><h3 id="本来开一个灯一个热水器一个电视机，需要跟三个电器打交道"><a href="#本来开一个灯一个热水器一个电视机，需要跟三个电器打交道" class="headerlink" title="本来开一个灯一个热水器一个电视机，需要跟三个电器打交道"></a>本来开一个灯一个热水器一个电视机，需要跟三个电器打交道</h3><h3 id="现在将他们三个的开关，统一做到了同一个开关上，用户只用跟这一个开关打交道了"><a href="#现在将他们三个的开关，统一做到了同一个开关上，用户只用跟这一个开关打交道了" class="headerlink" title="现在将他们三个的开关，统一做到了同一个开关上，用户只用跟这一个开关打交道了"></a>现在将他们三个的开关，统一做到了同一个开关上，用户只用跟这一个开关打交道了</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/13/设计模式/设计模式(一) 单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/13/设计模式/设计模式(一) 单例模式/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-13 16:37:36" itemprop="dateCreated datePublished" datetime="2019-02-13T16:37:36+08:00">2019-02-13</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-14 13:37:09" itemprop="dateModified" datetime="2019-02-14T13:37:09+08:00">2019-02-14</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计模式-一-单例模式"><a href="#设计模式-一-单例模式" class="headerlink" title="设计模式(一) 单例模式"></a>设计模式(一) 单例模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="今天开始填一下设计模式的坑，尽量多总结一下常用的设计模式，今天先讲讲我觉得最常见的单例模式"><a href="#今天开始填一下设计模式的坑，尽量多总结一下常用的设计模式，今天先讲讲我觉得最常见的单例模式" class="headerlink" title="今天开始填一下设计模式的坑，尽量多总结一下常用的设计模式，今天先讲讲我觉得最常见的单例模式"></a>今天开始填一下设计模式的坑，尽量多总结一下常用的设计模式，今天先讲讲我觉得最常见的单例模式</h4><h2 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h2><h4 id="从名字我们也可以得到一点"><a href="#从名字我们也可以得到一点" class="headerlink" title="从名字我们也可以得到一点"></a>从名字我们也可以得到一点</h4><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><h4 id="synchronized-同步式式"><a href="#synchronized-同步式式" class="headerlink" title="synchronized 同步式式"></a>synchronized 同步式式</h4><h4 id="双重检验式"><a href="#双重检验式" class="headerlink" title="双重检验式"></a>双重检验式</h4><h4 id="既要懒汉式加载，又要线程安全：静态内部类。式"><a href="#既要懒汉式加载，又要线程安全：静态内部类。式" class="headerlink" title="既要懒汉式加载，又要线程安全：静态内部类。式"></a>既要懒汉式加载，又要线程安全：静态内部类。式</h4><h4 id="反射和反序列化破坏单例"><a href="#反射和反序列化破坏单例" class="headerlink" title="反射和反序列化破坏单例"></a>反射和反序列化破坏单例</h4><h4 id="最后一招，使用枚举"><a href="#最后一招，使用枚举" class="headerlink" title="最后一招，使用枚举"></a>最后一招，使用枚举</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/jdk/AQS的详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/02/11/jdk/AQS的详解/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-02-11 14:44:16" itemprop="dateCreated datePublished" datetime="2019-02-11T14:44:16+08:00">2019-02-11</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-05 16:21:05" itemprop="dateModified" datetime="2019-03-05T16:21:05+08:00">2019-03-05</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AQS的详解"><a href="#AQS的详解" class="headerlink" title="AQS的详解"></a>AQS的详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java-util-concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。"><a href="#java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java-util-concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。" class="headerlink" title="java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java.util.concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。"></a>java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java.util.concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。</h4><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h4 id="在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤"><a href="#在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤" class="headerlink" title="在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤"></a>在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤</h4><pre><code>1: 提供一个资源供大家抢占，假设初始状态为1，被占用后设置为0.所以假设有多个线程去获取这个资源的时候，肯定会只有一个线程能抢占成功，那么其他的线程必须按序排好。同时也要考虑到多个节点往队伍中排会出现的并发问题
2: 当上一个节点消费完成后，要将资源释放出来，然后要通知排在队伍中的第一个节点，通知他可以开始竞争资源了。</code></pre><h4 id="所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。"><a href="#所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。" class="headerlink" title="所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。"></a>所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。"><a href="#接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。" class="headerlink" title="接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。"></a>接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。</h4><h4 id="首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。"><a href="#首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。" class="headerlink" title="首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。"></a>首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">	this.nextWaiter = mode;</span><br><span class="line"> 			this.thread = thread;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合了一些这个构造函数的调用链，可以看到这个mode有两种情况"><a href="#结合了一些这个构造函数的调用链，可以看到这个mode有两种情况" class="headerlink" title="结合了一些这个构造函数的调用链，可以看到这个mode有两种情况"></a>结合了一些这个构造函数的调用链，可以看到这个mode有两种情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">static final Node SHARED = new Node();</span><br><span class="line">/** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">static final Node EXCLUSIVE = null;</span><br></pre></td></tr></table></figure>

<h4 id="这代表抢占资源的两种模式，一种是独占式，一种是共享式。"><a href="#这代表抢占资源的两种模式，一种是独占式，一种是共享式。" class="headerlink" title="这代表抢占资源的两种模式，一种是独占式，一种是共享式。"></a>这代表抢占资源的两种模式，一种是独占式，一种是共享式。</h4><blockquote>
<p>独占模式和共享模式。处于独占模式下时，其他线程试图获取该锁将无法取得成功。在共享模式下，多个线程获取某个锁可能（但不是一定）会获得成功</p>
</blockquote>
<h4 id="这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。"><a href="#这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。" class="headerlink" title="这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。"></a>这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg)</span><br><span class="line">protected boolean tryRelease(int arg)</span><br><span class="line">protected int tryAcquireShared(int arg)</span><br><span class="line">protected boolean tryReleaseShared(int arg)</span><br></pre></td></tr></table></figure>

<h4 id="因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。"><a href="#因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。" class="headerlink" title="因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。"></a>因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。</h4><h4 id="接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式-这个模式的获取资源和释放资源的入口方法分别的Acquire和Release"><a href="#接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式-这个模式的获取资源和释放资源的入口方法分别的Acquire和Release" class="headerlink" title="接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式,这个模式的获取资源和释放资源的入口方法分别的Acquire和Release"></a>接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式,这个模式的获取资源和释放资源的入口方法分别的Acquire和Release</h4><h2 id="EXCLUSIVE模式"><a href="#EXCLUSIVE模式" class="headerlink" title="EXCLUSIVE模式"></a>EXCLUSIVE模式</h2><h3 id="首先我们看一下独占模式的acquire方法"><a href="#首先我们看一下独占模式的acquire方法" class="headerlink" title="首先我们看一下独占模式的acquire方法"></a>首先我们看一下独占模式的acquire方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	// 直接调用子类复写的方法，尝试去获取资源，</span><br><span class="line">	// 若成功，则直接返回</span><br><span class="line">	// 若失败，则加入内部维护的FIFO队列中</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单看一下addWaiter方法内部"><a href="#简单看一下addWaiter方法内部" class="headerlink" title="简单看一下addWaiter方法内部"></a>简单看一下addWaiter方法内部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    // 若当前队列中已经初始化了尾节点，则会先尝试一种快速入队的方式，即</span><br><span class="line">    // 1：先获得当前队列中的尾节点，假设名字为t</span><br><span class="line">    // 2: 将当前节点的先驱节点设置为t，即将节点排在了队列的最尾端</span><br><span class="line">    // 3: 将队列的尾指针用CAS的方式，安全的指向当前节点。此处用CAS保证了线程安全</span><br><span class="line">    // 4: 之后将原尾节点的后继指针指向了当前节点，从而完成了双向确认</span><br><span class="line">    // 注意: 三个指针的操作中，之后尾指针的指向时用了CAS，其余两个都是普通的赋值操作，这边先埋个点，在之后会再讲到这个地方</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若之前的方法成功，则直接返回</span><br><span class="line">    // 否则就要进行比较复杂的方式</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">	// 整段代码由一个永真循环包围</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 若第一次调用，则要初始化队列的头尾指针</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	// 调用上段的逻辑，不断重试</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####可以看到内部就是维护了一个FIFO的队列，队列中每个节点都维护了线程，和当前等待状态以及前驱和后继节点。新节点到来时，会用CAS+自旋的方法去将节点放在等待队列中。然后在acquireQueued方法中，我们也可以看到，每个在队列中的节点，都会不断根据前驱节点的状态的改变，不断的去尝试获取资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">      boolean failed = true;</span><br><span class="line">      try &#123;</span><br><span class="line">      	// 标识线程是否中断</span><br><span class="line">          boolean interrupted = false;</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              final Node p = node.predecessor();</span><br><span class="line">              // 判断先驱节点是否为队列首节点</span><br><span class="line">              // 若是，则尝试去获取资源</span><br><span class="line">              if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              	//	若资源获取成功了，则将当前节点设为队列首节点</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = null; // help GC</span><br><span class="line">                  failed = false;</span><br><span class="line">                  return interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">              // 若还没轮到竞争资源，或者竞争资源失败</span><br><span class="line">              // 每个节点都会判断自己以及前驱节点的状态是否满足当前节点是否可以park，这句话可能比较绕，可以直接先看看shouldParkAfterFailedAcquire这个方法里面做了什么</span><br><span class="line">              if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	// 首先看到这个方法的返回值是一个布尔值，为true则标志当前节点可以park，会有其他节点在合适的时候将其唤醒</span><br><span class="line">  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">  	// 先驱节点的状态</span><br><span class="line">      int ws = pred.waitStatus;</span><br><span class="line">// 若前驱节点的状态是SIGNAL，也就是标志着当前节点在park前已经通知了前驱节点</span><br><span class="line">// 换句话说就是，前驱节点知道排在他后面的节点是park状态，那么在竞争完资源或者退出竞争之后，都会将其唤醒</span><br><span class="line">      if (ws == Node.SIGNAL)</span><br><span class="line">          /*</span><br><span class="line">           * This node has already set status asking a release</span><br><span class="line">           * to signal it, so it can safely park.</span><br><span class="line">           */</span><br><span class="line">          return true;</span><br><span class="line">      // 若前驱节点的状态已经是取消状态，则应该跳过这个节点，向前找到未取消的节点作为新的前驱节点</span><br><span class="line">      if (ws &gt; 0) &#123;</span><br><span class="line">          /*</span><br><span class="line">           * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">           * indicate retry.</span><br><span class="line">           */</span><br><span class="line">           // 如果先驱节点已经取消竞争了，则直接跳过他，查找队列前面最近的没取消的作为新的先驱节点</span><br><span class="line">          do &#123;</span><br><span class="line">              node.prev = pred = pred.prev;</span><br><span class="line">          &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">          pred.next = node;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          /*</span><br><span class="line">           * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">           * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">           * retry to make sure it cannot acquire before parking.</span><br><span class="line">           */</span><br><span class="line">           // 若先驱节点即没取消，又没Signal，则手动将其设置为Signal，表示当前节点已经安心park，等前驱节点资源释放后，需要将其唤醒</span><br><span class="line">          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">      &#125;</span><br><span class="line">      // 仅当先驱节点的状态是Signal的时候返回true，其他都为false</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park"><a href="#整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park" class="headerlink" title="整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park"></a>整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park</h4><h4 id="若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态"><a href="#若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态" class="headerlink" title="若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态"></a>若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。"><a href="#简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。" class="headerlink" title="简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。"></a>简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。</h4><h3 id="再看一下独占模式的release方法"><a href="#再看一下独占模式的release方法" class="headerlink" title="再看一下独占模式的release方法"></a>再看一下独占模式的release方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	// 同样的，开始就去尝试释放资源，这个方法也是由子类去覆写的</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">    	//	若释放成功，则得到等待队列中的头节点，如果节点存在，则唤醒头节点后的等待者，唤醒他开始竞争资源</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        	// 唤醒后继节点开始竞争资源</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="和acquire方法一样，里面具体的try…-方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现"><a href="#和acquire方法一样，里面具体的try…-方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现" class="headerlink" title="和acquire方法一样，里面具体的try…()方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现"></a>和acquire方法一样，里面具体的try…()方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">     // 从队列的末尾向前找到后继节点中，没有取消的节点，去唤醒。</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到有效的后继节点，尝试去唤醒</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？"><a href="#这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？" class="headerlink" title="这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？"></a>这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？</h4><h4 id="因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑"><a href="#因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑" class="headerlink" title="因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑"></a>因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (pred != null) &#123;</span><br><span class="line">    node.prev = pred;                    1</span><br><span class="line">    if (compareAndSetTail(pred, node)) &#123; 2</span><br><span class="line">        pred.next = node;                3</span><br><span class="line">        return node;                     4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况"><a href="#观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况" class="headerlink" title="观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况"></a>观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况</h4><ul>
<li><p>当2步骤完成时，由于是多线程。此时如果调度到了别的线程的release方法。若按照正常的正序查找后继结点。可以发现由于3步骤还没执行，原尾节点是没有后继节点的。那么就会认为队列已经空了，这显然是不对的。</p>
</li>
<li><p>但是由于尾指针的指向时CAS操作的，所以由尾指针作为入口，肯定是没问题的</p>
</li>
<li><p>倒序查找还跟CANCEL操作的时候有关，这部分可以直接看我文章下面的链接。写的非常好，我写不出那么好，就不班门弄斧了</p>
<h4 id="这里注意几点细节。"><a href="#这里注意几点细节。" class="headerlink" title="这里注意几点细节。"></a>这里注意几点细节。</h4></li>
<li><p>当前节点释放资源成功后，要去唤醒队伍中排在后面的人去消费。按常理来说，应该就是排在后面的那个节点，但是由于每个节点都有可能取消竞争状态，所以要跳过这种节点，以及跳过为空的节点</p>
</li>
<li><p>查找的时候要从队伍的末尾往前查找</p>
</li>
</ul>
<h4 id="唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程"><a href="#唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程" class="headerlink" title="唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程"></a>唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程</h4><h3 id="共享模式的acquire方法"><a href="#共享模式的acquire方法" class="headerlink" title="共享模式的acquire方法"></a>共享模式的acquire方法</h3><h4 id="上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。"><a href="#上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。" class="headerlink" title="上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。"></a>上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。</h4><h4 id="之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？"><a href="#之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？" class="headerlink" title="之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？"></a>之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同"><a href="#回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同" class="headerlink" title="回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同"></a>回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同</h4><ul>
<li>独占模式下try…()方法返回的是一个布尔值，直接确定是否抢占到了资源。而在共享模式下，返回的是一个int值，为负数的时候则表明抢占失败</li>
<li>共享模式这边少了一句 selfInterrupt()</li>
</ul>
<h4 id="和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占"><a href="#和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占" class="headerlink" title="和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占"></a>和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">	// 注意这里的Node的模式已经是SHARED了</span><br><span class="line">       final Node node = addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               if (p == head) &#123;</span><br><span class="line">               	// 同样的，注意这个返回是一个int值</span><br><span class="line">                   int r = tryAcquireShared(arg);</span><br><span class="line">                  // 返回值是正数，代表获取成功</span><br><span class="line">                   if (r &gt;= 0) &#123;</span><br><span class="line">                   	// 这是共享模式独有的Node状态</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = null; // help GC</span><br><span class="line">                       if (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么"><a href="#大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么" class="headerlink" title="大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么"></a>大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">     Node h = head; // Record old head for check below</span><br><span class="line">     setHead(node);</span><br><span class="line">     // 这是和独占模式有区别的地方，在共享模式中，当设置完头节点之后，还要考虑是否还有唤醒后面的节点继续抢占</span><br><span class="line">     // 1:当prop参数大于0,即表示资源还要剩余</span><br><span class="line">     // 2:当原头节点为null或者已被标注为SIGNAL模式，就表示后继节点待被唤醒</span><br><span class="line">// 3:当现头节点为null或者已被标注为SIGNAL模式，就表示后继节点待被唤醒</span><br><span class="line"></span><br><span class="line">     if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">         (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">         Node s = node.next;</span><br><span class="line">         if (s == null || s.isShared())</span><br><span class="line">             doReleaseShared();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源"><a href="#和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源" class="headerlink" title="和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源"></a>和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源"><a href="#具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源" class="headerlink" title="具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源"></a>具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。"><a href="#综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。" class="headerlink" title="综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。"></a>综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。</h4><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><p><a href="http://www.ideabuffer.cn/2017/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">关于为何倒序查找的Cancel方法论证</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/canal/canal源码分析 (三) 内嵌服务器启动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/26/canal/canal源码分析 (三) 内嵌服务器启动/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-26 17:21:01" itemprop="dateCreated datePublished" datetime="2019-01-26T17:21:01+08:00">2019-01-26</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-03-04 19:52:49" itemprop="dateModified" datetime="2019-03-04T19:52:49+08:00">2019-03-04</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="canal源码分析-三-内嵌服务器启动"><a href="#canal源码分析-三-内嵌服务器启动" class="headerlink" title="canal源码分析 (三) 内嵌服务器启动"></a>canal源码分析 (三) 内嵌服务器启动</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>####本章我们将进入到canal的内嵌服务器CanalServerWithEmbedded启动过程，通过这个类，这个类可以看做canal内部黑盒处理对外暴露的一些。在CanalServerWithEmbedded这个类中，我们可以看到有两个start的函数方法。从之前的文章中，我们已经已经看到了这些方法的具体方法。所以本文就是直接关注这个类内部的一些启动逻辑</p>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><h4 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public void start() &#123;</span><br><span class="line">	// 若内嵌服务器未启动</span><br><span class="line">    if (!isStart()) &#123;</span><br><span class="line">        super.start();</span><br><span class="line">        // 如果存在provider,则启动metrics service</span><br><span class="line">        // 接下来三行都是关于开启一些普罗米修斯监控接口的方法</span><br><span class="line">        loadCanalMetrics();</span><br><span class="line">        metrics.setServerPort(metricsPort);</span><br><span class="line">        metrics.initialize();</span><br><span class="line">        // 然后将所有的canalInstance都存放在一个map中，并用之前的instance生成器生成新的canalInstance</span><br><span class="line">        canalInstances = MigrateMap.makeComputingMap(new Function&lt;String, CanalInstance&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            public CanalInstance apply(String destination) &#123;</span><br><span class="line">                return canalInstanceGenerator.generate(destination);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // lastRollbackPostions = new MapMaker().makeMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从这个方法中也可以看到，这个start-方法，只是做了一些初始化的工作，所以重点看一下另外一个start方法"><a href="#从这个方法中也可以看到，这个start-方法，只是做了一些初始化的工作，所以重点看一下另外一个start方法" class="headerlink" title="从这个方法中也可以看到，这个start()方法，只是做了一些初始化的工作，所以重点看一下另外一个start方法"></a>从这个方法中也可以看到，这个start()方法，只是做了一些初始化的工作，所以重点看一下另外一个start方法</h3><h4 id="start-final-String-destination"><a href="#start-final-String-destination" class="headerlink" title="start(final String destination)"></a>start(final String destination)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void start(final String destination) &#123;</span><br><span class="line">	// 通过destination名字从map中获取canalInstance，若不存在则用canalInstance生成器创造</span><br><span class="line">    final CanalInstance canalInstance = canalInstances.get(destination);</span><br><span class="line">    // 若得到的canalInstance还未启动</span><br><span class="line">    if (!canalInstance.isStart()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            MDC.put(&quot;destination&quot;, destination);</span><br><span class="line">            // 在普罗米修斯的状态中注册</span><br><span class="line">            if (metrics.isRunning()) &#123;</span><br><span class="line">                metrics.register(canalInstance);</span><br><span class="line">            &#125;</span><br><span class="line">            // 启动这个canalInstance，从这句开始拉开了所有事情的帷幕</span><br><span class="line">            canalInstance.start();</span><br><span class="line">            logger.info(&quot;start CanalInstances[&#123;&#125;] successfully&quot;, destination);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            MDC.remove(&quot;destination&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从方法的入参里也可以看到两个start方法的区别。传入了destination，所以就是会去启动相应的canalInstance的实例。也就是可以看做这个类作为所有真正实例的统一入口，所有的操作都由这个类进行统一代理。"><a href="#从方法的入参里也可以看到两个start方法的区别。传入了destination，所以就是会去启动相应的canalInstance的实例。也就是可以看做这个类作为所有真正实例的统一入口，所有的操作都由这个类进行统一代理。" class="headerlink" title="从方法的入参里也可以看到两个start方法的区别。传入了destination，所以就是会去启动相应的canalInstance的实例。也就是可以看做这个类作为所有真正实例的统一入口，所有的操作都由这个类进行统一代理。"></a>从方法的入参里也可以看到两个start方法的区别。传入了destination，所以就是会去启动相应的canalInstance的实例。也就是可以看做这个类作为所有真正实例的统一入口，所有的操作都由这个类进行统一代理。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/23/netty/netty在服务端的bind操作，内部到底做了什么？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/23/netty/netty在服务端的bind操作，内部到底做了什么？/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-23 10:05:45" itemprop="dateCreated datePublished" datetime="2019-01-23T10:05:45+08:00">2019-01-23</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-01-24 11:37:14" itemprop="dateModified" datetime="2019-01-24T11:37:14+08:00">2019-01-24</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="netty在服务端的bind操作，内部到底做了什么？"><a href="#netty在服务端的bind操作，内部到底做了什么？" class="headerlink" title="netty在服务端的bind操作，内部到底做了什么？"></a>netty在服务端的bind操作，内部到底做了什么？</h1><h3 id="看看调用方式"><a href="#看看调用方式" class="headerlink" title="看看调用方式"></a>看看调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int PORT = 8887;</span><br><span class="line">   ServerBootstrap b = new ServerBootstrap();</span><br><span class="line">   // ... 此处省略一些ServerBootstrap绑定一些handle之类的操作</span><br><span class="line">// Start the server.</span><br><span class="line">ChannelFuture f = b.bind(PORT).sync();</span><br></pre></td></tr></table></figure>

<h3 id="继续跟进去AbstractBootstrap代码"><a href="#继续跟进去AbstractBootstrap代码" class="headerlink" title="继续跟进去AbstractBootstrap代码"></a>继续跟进去AbstractBootstrap代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    public ChannelFuture bind(int inetPort) &#123;</span><br><span class="line">    	// 只给定端口号的话，会用local:port的形式组成address</span><br><span class="line">        return bind(new InetSocketAddress(inetPort));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public ChannelFuture bind(SocketAddress localAddress) &#123;</span><br><span class="line">    	// 检验一下一些需要的成员变量是否存在</span><br><span class="line">        validate();</span><br><span class="line">        if (localAddress == null) &#123;</span><br><span class="line">            throw new NullPointerException(&quot;localAddress&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return doBind(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 接下来的这个bind才是真正的重点</span><br><span class="line">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</span><br><span class="line">		// 简单说起来就是这个方法会初始化一个channel,因为是异步处理，所以会直接先返回一个ChannelFuture</span><br><span class="line">        final ChannelFuture regFuture = initAndRegister();</span><br><span class="line">        final Channel channel = regFuture.channel();</span><br><span class="line">        // 如果操作失败,直接返回</span><br><span class="line">        if (regFuture.cause() != null) &#123;</span><br><span class="line">            return regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">		// 因为是异步，所以此时可能会有两种情况, 若此时已经成功，则继续下面的绑定步骤</span><br><span class="line">        if (regFuture.isDone()) &#123;</span><br><span class="line">            // At this point we know that the registration was complete and successful.</span><br><span class="line">            ChannelPromise promise = channel.newPromise();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Registration future is almost always fulfilled already, but just in case it&apos;s not.</span><br><span class="line">            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</span><br><span class="line">            // 若没有，则开一个监听器，等待完成或者失败</span><br><span class="line">            regFuture.addListener(new ChannelFutureListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span><br><span class="line">                    Throwable cause = future.cause();</span><br><span class="line">                    if (cause != null) &#123;</span><br><span class="line">                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br><span class="line">                        // IllegalStateException once we try to access the EventLoop of the Channel.</span><br><span class="line">                        promise.setFailure(cause);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Registration was successful, so set the correct executor to use.</span><br><span class="line">                        // See https://github.com/netty/netty/issues/2586</span><br><span class="line">                        promise.registered();</span><br><span class="line"></span><br><span class="line">                        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            return promise;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/22/canal/canal源码分析 (二) 启动过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/22/canal/canal源码分析 (二) 启动过程/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-22 01:46:06 / Modified: 19:47:36" itemprop="dateCreated datePublished" datetime="2019-01-22T01:46:06+08:00">2019-01-22</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="canal源码分析-二-启动过程"><a href="#canal源码分析-二-启动过程" class="headerlink" title="canal源码分析 (二) 启动过程"></a>canal源码分析 (二) 启动过程</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h4 id="上一章导读中我们算是初步对canal这个中间件的代码结构有了一些大概的印象，我也对其中我觉得比较关键的模块进行了一些浅显的论述，从本章开始，我们要真正开始对各个模块进行详细的分析。好了，进入正题。本章会详细论述一下canal是如何启动的以及启动的过程中做了什么。"><a href="#上一章导读中我们算是初步对canal这个中间件的代码结构有了一些大概的印象，我也对其中我觉得比较关键的模块进行了一些浅显的论述，从本章开始，我们要真正开始对各个模块进行详细的分析。好了，进入正题。本章会详细论述一下canal是如何启动的以及启动的过程中做了什么。" class="headerlink" title="上一章导读中我们算是初步对canal这个中间件的代码结构有了一些大概的印象，我也对其中我觉得比较关键的模块进行了一些浅显的论述，从本章开始，我们要真正开始对各个模块进行详细的分析。好了，进入正题。本章会详细论述一下canal是如何启动的以及启动的过程中做了什么。"></a>上一章导读中我们算是初步对canal这个中间件的代码结构有了一些大概的印象，我也对其中我觉得比较关键的模块进行了一些浅显的论述，从本章开始，我们要真正开始对各个模块进行详细的分析。好了，进入正题。本章会详细论述一下canal是如何启动的以及启动的过程中做了什么。</h4><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><h4 id="看完上一章的同学应该也可以看到在canal的代码结构中有一个canal-deployer的模块，从名字也可以看出来这就是canal的启动器所在的模块。在里面找到CanalLauncher这个类。作者在这个类的注释中也写的很清楚"><a href="#看完上一章的同学应该也可以看到在canal的代码结构中有一个canal-deployer的模块，从名字也可以看出来这就是canal的启动器所在的模块。在里面找到CanalLauncher这个类。作者在这个类的注释中也写的很清楚" class="headerlink" title="看完上一章的同学应该也可以看到在canal的代码结构中有一个canal.deployer的模块，从名字也可以看出来这就是canal的启动器所在的模块。在里面找到CanalLauncher这个类。作者在这个类的注释中也写的很清楚"></a>看完上一章的同学应该也可以看到在canal的代码结构中有一个canal.deployer的模块，从名字也可以看出来这就是canal的启动器所在的模块。在里面找到CanalLauncher这个类。作者在这个类的注释中也写的很清楚</h4><blockquote>
<p>/**</p>
<ul>
<li>canal独立版本启动的入口类</li>
<li>/ &gt;</li>
</ul>
</blockquote>
<h4 id="好的，既然作者都这么说了。直接运行这个类里的main函数。大功告成！？-诶不对，好像报错了。果然还有点小问题还没有解决。看看报错内容"><a href="#好的，既然作者都这么说了。直接运行这个类里的main函数。大功告成！？-诶不对，好像报错了。果然还有点小问题还没有解决。看看报错内容" class="headerlink" title="好的，既然作者都这么说了。直接运行这个类里的main函数。大功告成！？ 诶不对，好像报错了。果然还有点小问题还没有解决。看看报错内容"></a>好的，既然作者都这么说了。直接运行这个类里的main函数。大功告成！？ 诶不对，好像报错了。果然还有点小问题还没有解决。看看报错内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">2019</span>-<span class="number">01</span>-<span class="number">22</span> <span class="number">01</span>:<span class="number">21</span>:<span class="number">50.454</span> [destination = example , address = /<span class="number">127.0</span>.0.1:<span class="number">3306</span> , EventParser] ERROR c.a.o.c.p.inbound.mysql.rds.RdsBinlogEventParserProxy - dump address /<span class="number">127.0</span>.0.1:<span class="number">3306</span> has an error, retrying. caused by </span><br><span class="line">com.alibaba.otter.canal.parse.exception.CanalParseException: java.io.IOException: connect /<span class="number">127.0</span>.0.1:<span class="number">3306</span> failure</span><br><span class="line">Caused by: java.io.IOException: connect /<span class="number">127.0</span>.0.1:<span class="number">3306</span> failure</span><br><span class="line">	at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.connect(MysqlConnector.java:<span class="number">77</span>) ~[classes/:na]</span><br><span class="line">	at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.connect(MysqlConnection.java:<span class="number">89</span>) ~[classes/:na]</span><br><span class="line">	at com.alibaba.otter.canal.parse.inbound.mysql.MysqlEventParser.preDump(MysqlEventParser.java:<span class="number">86</span>) ~[classes/:na]</span><br><span class="line">	at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$<span class="number">3</span>.run(AbstractEventParser.java:<span class="number">175</span>) ~[classes/:na]</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">745</span>) [na:<span class="number">1.8</span>.0_111]</span><br></pre></td></tr></table></figure>

<h6 id="注意：如果你本机确实启动了一个数据库服务，那么是不会报错的。"><a href="#注意：如果你本机确实启动了一个数据库服务，那么是不会报错的。" class="headerlink" title="注意：如果你本机确实启动了一个数据库服务，那么是不会报错的。"></a>注意：如果你本机确实启动了一个数据库服务，那么是不会报错的。</h6><h4 id="看一下这个报错内容给了我们什么信息"><a href="#看一下这个报错内容给了我们什么信息" class="headerlink" title="看一下这个报错内容给了我们什么信息"></a>看一下这个报错内容给了我们什么信息</h4><ul>
<li>是 “destination = example” 的这个canal.instance 出错了 (还记得在上一章中我说过destination和canal.instance会在后面一直出现嘛…)</li>
<li>报错原因是因为代码去连接本机的3306端口时候报错</li>
</ul>
<h4 id="看到这两个得到的信息，我们再进一步提取出我们解决这个问题的思路。肯定是canal启动的时候，根据哪些配置或者默认的参数生成了默认为example的canal-instance然后直接监听了本机启动的数据库。所以只要找到这个配置的地方，然后把他修改成我们真正需要监听的数据库地址，就可以解决这个报错了。所以就是这个启动类是正确的，但是某些配置没有配置成功。这边先卖个关子，等我们看完整个启动过程，你们肯定会知道在哪里可以修改这个配置，让启动顺利完成。"><a href="#看到这两个得到的信息，我们再进一步提取出我们解决这个问题的思路。肯定是canal启动的时候，根据哪些配置或者默认的参数生成了默认为example的canal-instance然后直接监听了本机启动的数据库。所以只要找到这个配置的地方，然后把他修改成我们真正需要监听的数据库地址，就可以解决这个报错了。所以就是这个启动类是正确的，但是某些配置没有配置成功。这边先卖个关子，等我们看完整个启动过程，你们肯定会知道在哪里可以修改这个配置，让启动顺利完成。" class="headerlink" title="看到这两个得到的信息，我们再进一步提取出我们解决这个问题的思路。肯定是canal启动的时候，根据哪些配置或者默认的参数生成了默认为example的canal.instance然后直接监听了本机启动的数据库。所以只要找到这个配置的地方，然后把他修改成我们真正需要监听的数据库地址，就可以解决这个报错了。所以就是这个启动类是正确的，但是某些配置没有配置成功。这边先卖个关子，等我们看完整个启动过程，你们肯定会知道在哪里可以修改这个配置，让启动顺利完成。"></a>看到这两个得到的信息，我们再进一步提取出我们解决这个问题的思路。肯定是canal启动的时候，根据哪些配置或者默认的参数生成了默认为example的canal.instance然后直接监听了本机启动的数据库。所以只要找到这个配置的地方，然后把他修改成我们真正需要监听的数据库地址，就可以解决这个报错了。所以就是这个启动类是正确的，但是某些配置没有配置成功。这边先卖个关子，等我们看完整个启动过程，你们肯定会知道在哪里可以修改这个配置，让启动顺利完成。</h4><h2 id="启动详解"><a href="#启动详解" class="headerlink" title="启动详解"></a>启动详解</h2><h4 id="回到我们刚才的main函数中-去掉前面的一些打印日志-真正起作用的第一部分是下面的这几行代码"><a href="#回到我们刚才的main函数中-去掉前面的一些打印日志-真正起作用的第一部分是下面的这几行代码" class="headerlink" title="回到我们刚才的main函数中,去掉前面的一些打印日志,真正起作用的第一部分是下面的这几行代码"></a>回到我们刚才的main函数中,去掉前面的一些打印日志,真正起作用的第一部分是下面的这几行代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取canal启动的配置文件的目录，提供默认实现方式</span></span><br><span class="line"><span class="comment">// 默认的配置文件可以看resource目录下的canal.properties文件</span></span><br><span class="line">         String conf = System.getProperty(<span class="string">"canal.conf"</span>, <span class="string">"classpath:canal.properties"</span>);</span><br><span class="line">         Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">         ManagerRemoteConfigMonitor managerDbConfigMonitor = <span class="keyword">null</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 根据之前获得的配置文件目录去实例化Properties类</span></span><br><span class="line">         <span class="keyword">if</span> (conf.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">             conf = StringUtils.substringAfter(conf, CLASSPATH_URL_PREFIX);</span><br><span class="line">             properties.load(CanalLauncher.class.getClassLoader().getResourceAsStream(conf));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             properties.load(<span class="keyword">new</span> FileInputStream(conf));</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 在配置中若注明了以下参数，表名canal的启动配置从远端获取</span></span><br><span class="line">         String jdbcUrl = properties.getProperty(<span class="string">"canal.manager.jdbc.url"</span>);</span><br><span class="line">         <span class="keyword">if</span> (!StringUtils.isEmpty(jdbcUrl)) &#123;</span><br><span class="line">             logger.info(<span class="string">"## load remote canal configurations"</span>);</span><br><span class="line">             <span class="comment">// load remote config</span></span><br><span class="line">             String jdbcUsername = properties.getProperty(<span class="string">"canal.manager.jdbc.username"</span>);</span><br><span class="line">             String jdbcPassword = properties.getProperty(<span class="string">"canal.manager.jdbc.password"</span>);</span><br><span class="line">             </span><br><span class="line">             <span class="comment">// 内部实现的逻辑也就是根据提供的数据库信息，去数据库中获取内容，并覆盖本地配置文件</span></span><br><span class="line">             <span class="comment">// 从数据库中获取信息的的sql语句</span></span><br><span class="line">             <span class="comment">// "select name, content, modified_time from canal_config where id=1"</span></span><br><span class="line">             </span><br><span class="line">             managerDbConfigMonitor = <span class="keyword">new</span> ManagerRemoteConfigMonitor(jdbcUrl, jdbcUsername, jdbcPassword);</span><br><span class="line">             <span class="comment">// 加载远程canal.properties</span></span><br><span class="line">             Properties remoteConfig = managerDbConfigMonitor.loadRemoteConfig();</span><br><span class="line">             <span class="comment">// 加载remote instance配置</span></span><br><span class="line">             managerDbConfigMonitor.loadRemoteInstanceConfigs();</span><br><span class="line">             <span class="keyword">if</span> (remoteConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 properties = remoteConfig;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 managerDbConfigMonitor = <span class="keyword">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             logger.info(<span class="string">"## load canal configurations"</span>);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<h4 id="主要的几点我在代码注释里也写了，目的就是从配置文件中得到相应的配置信息，作为后续启动时的一些参数。再看接下来的代码。"><a href="#主要的几点我在代码注释里也写了，目的就是从配置文件中得到相应的配置信息，作为后续启动时的一些参数。再看接下来的代码。" class="headerlink" title="主要的几点我在代码注释里也写了，目的就是从配置文件中得到相应的配置信息，作为后续启动时的一些参数。再看接下来的代码。"></a>主要的几点我在代码注释里也写了，目的就是从配置文件中得到相应的配置信息，作为后续启动时的一些参数。再看接下来的代码。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CanalStater canalStater = <span class="keyword">new</span> CanalStater();</span><br><span class="line">canalStater.start(properties);</span><br></pre></td></tr></table></figure>

<h4 id="怎么在canalLancer里又new了一个canalStart，还把之前生成的properties作为他的start方法的参数传入。看了一下这个类的构造函数是空的，所以直接跟进去这个类的start方法，看看做了什么。"><a href="#怎么在canalLancer里又new了一个canalStart，还把之前生成的properties作为他的start方法的参数传入。看了一下这个类的构造函数是空的，所以直接跟进去这个类的start方法，看看做了什么。" class="headerlink" title="怎么在canalLancer里又new了一个canalStart，还把之前生成的properties作为他的start方法的参数传入。看了一下这个类的构造函数是空的，所以直接跟进去这个类的start方法，看看做了什么。"></a>怎么在canalLancer里又new了一个canalStart，还把之前生成的properties作为他的start方法的参数传入。看了一下这个类的构造函数是空的，所以直接跟进去这个类的start方法，看看做了什么。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从配置类中读取Server的启动模式，默认为tcp，还提供了另外两种模式 kafka，rocketmq</span></span><br><span class="line">String serverMode = CanalController.getProperty(properties, CanalConstants.CANAL_SERVER_MODE);</span><br><span class="line">      <span class="keyword">if</span> (serverMode.equalsIgnoreCase(<span class="string">"kafka"</span>)) &#123;</span><br><span class="line">          canalMQProducer = <span class="keyword">new</span> CanalKafkaProducer();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverMode.equalsIgnoreCase(<span class="string">"rocketmq"</span>)) &#123;</span><br><span class="line">          canalMQProducer = <span class="keyword">new</span> CanalRocketMQProducer();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canalMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// disable netty</span></span><br><span class="line">          System.setProperty(CanalConstants.CANAL_WITHOUT_NETTY, <span class="string">"true"</span>);</span><br><span class="line">          System.setProperty(CanalConstants.CANAL_DESTINATIONS,</span><br><span class="line">              properties.getProperty(CanalConstants.CANAL_DESTINATIONS));</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这一段代码初步看起来也不知道做了什么，就是根据配置来选择服务端启动方式。然后如果是mq的模式，就禁用之后的netty操作。目前还不知道生成的CanalProducer类具体是干嘛的，也不知道System-setProperty两个属性之后起到什么作用。先不管了，接着往后看。"><a href="#这一段代码初步看起来也不知道做了什么，就是根据配置来选择服务端启动方式。然后如果是mq的模式，就禁用之后的netty操作。目前还不知道生成的CanalProducer类具体是干嘛的，也不知道System-setProperty两个属性之后起到什么作用。先不管了，接着往后看。" class="headerlink" title="这一段代码初步看起来也不知道做了什么，就是根据配置来选择服务端启动方式。然后如果是mq的模式，就禁用之后的netty操作。目前还不知道生成的CanalProducer类具体是干嘛的，也不知道System.setProperty两个属性之后起到什么作用。先不管了，接着往后看。"></a>这一段代码初步看起来也不知道做了什么，就是根据配置来选择服务端启动方式。然后如果是mq的模式，就禁用之后的netty操作。目前还不知道生成的CanalProducer类具体是干嘛的，也不知道System.setProperty两个属性之后起到什么作用。先不管了，接着往后看。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">controller = <span class="keyword">new</span> CanalController(properties);</span><br><span class="line">controller.start();</span><br></pre></td></tr></table></figure>

<h4 id="嗯？怎么又来了一个CanalController，简直要被绕晕了。继续看这个类的构造函数"><a href="#嗯？怎么又来了一个CanalController，简直要被绕晕了。继续看这个类的构造函数" class="headerlink" title="嗯？怎么又来了一个CanalController，简直要被绕晕了。继续看这个类的构造函数"></a>嗯？怎么又来了一个CanalController，简直要被绕晕了。继续看这个类的构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">managerClients = MigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;String, CanalConfigClient&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CanalConfigClient <span class="title">apply</span><span class="params">(String managerAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getManagerClient(managerAddress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化全局参数设置</span></span><br><span class="line">globalInstanceConfig = initGlobalConfig(properties);</span><br></pre></td></tr></table></figure>

<h4 id="开局一个map，不知道存了什么东西。先跳过了。然后初始化全局参数设置是什么呢。再跟进去看看这个方法。"><a href="#开局一个map，不知道存了什么东西。先跳过了。然后初始化全局参数设置是什么呢。再跟进去看看这个方法。" class="headerlink" title="开局一个map，不知道存了什么东西。先跳过了。然后初始化全局参数设置是什么呢。再跟进去看看这个方法。"></a>开局一个map，不知道存了什么东西。先跳过了。然后初始化全局参数设置是什么呢。再跟进去看看这个方法。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">InstanceConfig globalConfig = <span class="keyword">new</span> InstanceConfig();</span><br><span class="line">        String modeStr = getProperty(properties, CanalConstants.getInstanceModeKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(modeStr)) &#123;</span><br><span class="line">            globalConfig.setMode(InstanceMode.valueOf(StringUtils.upperCase(modeStr)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String lazyStr = getProperty(properties, CanalConstants.getInstancLazyKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(lazyStr)) &#123;</span><br><span class="line">            globalConfig.setLazy(Boolean.valueOf(lazyStr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String managerAddress = getProperty(properties,</span><br><span class="line">            CanalConstants.getInstanceManagerAddressKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(managerAddress)) &#123;</span><br><span class="line">            globalConfig.setManagerAddress(managerAddress);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String springXml = getProperty(properties, CanalConstants.getInstancSpringXmlKey(CanalConstants.GLOBAL_NAME));</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(springXml)) &#123;</span><br><span class="line">            globalConfig.setSpringXml(springXml);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instanceGenerator = <span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">          			...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> globalConfig;</span><br></pre></td></tr></table></figure>

<h4 id="整个方法的大逻辑就是生成并返回一个globalConfig实例，并把配置文件中的一些配置设置为globalConfig的成员变量。具体这些参数是什么意思放在后面遇到的时候再讲。主要看到最后的那个instanceGenerator"><a href="#整个方法的大逻辑就是生成并返回一个globalConfig实例，并把配置文件中的一些配置设置为globalConfig的成员变量。具体这些参数是什么意思放在后面遇到的时候再讲。主要看到最后的那个instanceGenerator" class="headerlink" title="整个方法的大逻辑就是生成并返回一个globalConfig实例，并把配置文件中的一些配置设置为globalConfig的成员变量。具体这些参数是什么意思放在后面遇到的时候再讲。主要看到最后的那个instanceGenerator"></a>整个方法的大逻辑就是生成并返回一个globalConfig实例，并把配置文件中的一些配置设置为globalConfig的成员变量。具体这些参数是什么意思放在后面遇到的时候再讲。主要看到最后的那个instanceGenerator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如名字所说 这个类是canalInstance的生成器，内部实现一个generate方法</span></span><br><span class="line">instanceGenerator = <span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">              <span class="comment">// 下文会讲到这个map, 存放每个instance独立的配置，先占个坑</span></span><br><span class="line">              InstanceConfig config = instanceConfigs.get(destination);</span><br><span class="line">              <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> CanalServerException(<span class="string">"can't find destination:&#123;&#125;"</span>);</span><br><span class="line">              &#125;</span><br><span class="line">		<span class="comment">// 根据获取的配置的生成模式选择具体的instance生成器的实现类</span></span><br><span class="line">		<span class="comment">// 目前有两种实现方式 manager和spring</span></span><br><span class="line">              <span class="keyword">if</span> (config.getMode().isManager()) &#123;</span><br><span class="line">                  ManagerCanalInstanceGenerator instanceGenerator = <span class="keyword">new</span> ManagerCanalInstanceGenerator();</span><br><span class="line">                  <span class="comment">// 会用到我们之前提到的那个开局一个map地方instanceGenerator.setCanalConfigClient(managerClients.get(config.getManagerAddress()));</span></span><br><span class="line">                  <span class="keyword">return</span> instanceGenerator.generate(destination);</span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config.getMode().isSpring()) &#123;</span><br><span class="line">                  SpringCanalInstanceGenerator instanceGenerator = <span class="keyword">new</span> SpringCanalInstanceGenerator();</span><br><span class="line">                  <span class="comment">// 默认的配置是spring模式的</span></span><br><span class="line">                  <span class="comment">// 为什么要加锁？</span></span><br><span class="line">                  <span class="keyword">synchronized</span> (CanalEventParser.class) &#123;</span><br><span class="line">                      <span class="keyword">try</span> &#123;</span><br><span class="line">                          <span class="comment">// 设置当前正在加载的通道，加载spring查找文件时会用到该变量</span></span><br><span class="line">                          System.setProperty(CanalConstants.CANAL_DESTINATION_PROPERTY, destination);</span><br><span class="line">                          <span class="comment">// 默认路径 classpath:spring/file-instance.xml</span></span><br><span class="line">                          instanceGenerator.setBeanFactory(getBeanFactory(config.getSpringXml()));</span><br><span class="line">                          <span class="comment">// 用配置的spring.xml文件来生成canalInstance bean</span></span><br><span class="line">                          <span class="keyword">return</span> instanceGenerator.generate(destination);</span><br><span class="line">                      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                          logger.error(<span class="string">"generator instance failed."</span>, e);</span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> CanalException(e);</span><br><span class="line">                      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                          System.setProperty(CanalConstants.CANAL_DESTINATION_PROPERTY, <span class="string">""</span>);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"unknow mode :"</span> + config.getMode());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="这边罗列一下spring-xml文件中配置"><a href="#这边罗列一下spring-xml文件中配置" class="headerlink" title="这边罗列一下spring.xml文件中配置"></a>这边罗列一下spring.xml文件中配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instance"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.otter.canal.instance.spring.CanalInstanceWithSpring"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destination"</span> <span class="attr">value</span>=<span class="string">"$&#123;canal.instance.destination&#125;"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventParser"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventParser"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventSink"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventSink"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"eventStore"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"eventStore"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"metaManager"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"metaManager"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alarmHandler"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"alarmHandler"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mqConfig"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"mqConfig"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="可以看到这个instance里面的几个重要的组件，跟我们第一章中对代码结构分析时提到的几个重要组件是一样的，所以印证了我之前说的"><a href="#可以看到这个instance里面的几个重要的组件，跟我们第一章中对代码结构分析时提到的几个重要组件是一样的，所以印证了我之前说的" class="headerlink" title="可以看到这个instance里面的几个重要的组件，跟我们第一章中对代码结构分析时提到的几个重要组件是一样的，所以印证了我之前说的"></a>可以看到这个instance里面的几个重要的组件，跟我们第一章中对代码结构分析时提到的几个重要组件是一样的，所以印证了我之前说的</h4><pre><code>canalInstance可以看成对mysql的binlog文件进行解析存储处理的容器通道</code></pre><h4 id="好了，结束了这个方法，再看调用这个方法之后又做了什么"><a href="#好了，结束了这个方法，再看调用这个方法之后又做了什么" class="headerlink" title="好了，结束了这个方法，再看调用这个方法之后又做了什么"></a>好了，结束了这个方法，再看调用这个方法之后又做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 和之前的初始化全局配置差不多，这部分是初始化每个单独的instance的配置，没有的话就默认全局配置</span><br><span class="line">      instanceConfigs = new MapMaker().makeMap();</span><br><span class="line">      // 初始化instance config</span><br><span class="line">      initInstanceConfig(properties); </span><br><span class="line">      // init socketChannel</span><br><span class="line">      String socketChannel = getProperty(properties, CanalConstants.CANAL_SOCKETCHANNEL);</span><br><span class="line">      if (StringUtils.isNotEmpty(socketChannel)) &#123;</span><br><span class="line">          System.setProperty(CanalConstants.CANAL_SOCKETCHANNEL, socketChannel);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 兼容1.1.0版本的ak/sk参数名</span><br><span class="line">      String accesskey = getProperty(properties, &quot;canal.instance.rds.accesskey&quot;);</span><br><span class="line">      String secretkey = getProperty(properties, &quot;canal.instance.rds.secretkey&quot;);</span><br><span class="line">      if (StringUtils.isNotEmpty(accesskey)) &#123;</span><br><span class="line">          System.setProperty(CanalConstants.CANAL_ALIYUN_ACCESSKEY, accesskey);</span><br><span class="line">      &#125;</span><br><span class="line">      if (StringUtils.isNotEmpty(secretkey)) &#123;</span><br><span class="line">          System.setProperty(CanalConstants.CANAL_ALIYUN_SECRETKEY, secretkey);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h1 id="TODO-parseInstanceConfig"><a href="#TODO-parseInstanceConfig" class="headerlink" title="TODO parseInstanceConfig"></a>TODO parseInstanceConfig</h1><h4 id="主要也就是讲了一下从配置里读取信息的内容，这边也不做赘述了。直接看下面这段比较重要的部分"><a href="#主要也就是讲了一下从配置里读取信息的内容，这边也不做赘述了。直接看下面这段比较重要的部分" class="headerlink" title="主要也就是讲了一下从配置里读取信息的内容，这边也不做赘述了。直接看下面这段比较重要的部分"></a>主要也就是讲了一下从配置里读取信息的内容，这边也不做赘述了。直接看下面这段比较重要的部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 准备canal server</span><br><span class="line">      cid = Long.valueOf(getProperty(properties, CanalConstants.CANAL_ID));</span><br><span class="line">      ip = getProperty(properties, CanalConstants.CANAL_IP);</span><br><span class="line">      port = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_PORT));</span><br><span class="line">      // 得到单例的内嵌canal服务器</span><br><span class="line">      embededCanalServer = CanalServerWithEmbedded.instance();</span><br><span class="line">      // 并把之前生成的canalInstance生成器作为成员变量</span><br><span class="line">      embededCanalServer.setCanalInstanceGenerator(instanceGenerator);// 设置自定义的instanceGenerator</span><br><span class="line">      // 提供给普罗米修斯的监控端口</span><br><span class="line">      try &#123;</span><br><span class="line">          int metricsPort = Integer.valueOf(getProperty(properties, CanalConstants.CANAL_METRICS_PULL_PORT));</span><br><span class="line">          embededCanalServer.setMetricsPort(metricsPort);</span><br><span class="line">      &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">          logger.info(&quot;No valid metrics server port found, use default 11112.&quot;);</span><br><span class="line">          embededCanalServer.setMetricsPort(11112);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边启动的embededCanalServer是一种内嵌式的canal启动服务器的实现方式，里面会保存所有的canalInstance。且同一个jvm只存在一个embededCanalServer。然后暴露metrics端口给普罗米修斯拉取监控数据。再往下看"><a href="#这边启动的embededCanalServer是一种内嵌式的canal启动服务器的实现方式，里面会保存所有的canalInstance。且同一个jvm只存在一个embededCanalServer。然后暴露metrics端口给普罗米修斯拉取监控数据。再往下看" class="headerlink" title="这边启动的embededCanalServer是一种内嵌式的canal启动服务器的实现方式，里面会保存所有的canalInstance。且同一个jvm只存在一个embededCanalServer。然后暴露metrics端口给普罗米修斯拉取监控数据。再往下看"></a>这边启动的embededCanalServer是一种内嵌式的canal启动服务器的实现方式，里面会保存所有的canalInstance。且同一个jvm只存在一个embededCanalServer。然后暴露metrics端口给普罗米修斯拉取监控数据。再往下看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 还记得之前有一个步骤判断了一下是哪种canalServer的地方吗,tcp . rocketmq . kafka三种模式的地方</span><br><span class="line">String canalWithoutNetty = getProperty(properties, CanalConstants.CANAL_WITHOUT_NETTY);</span><br><span class="line">// 若采用的是传统的tcp的方式，也就是netty连接,则会得到CanalServerWithNetty的实例化对象，并设置ip和端口</span><br><span class="line">      if (canalWithoutNetty == null || &quot;false&quot;.equals(canalWithoutNetty)) &#123;</span><br><span class="line">          canalServer = CanalServerWithNetty.instance();</span><br><span class="line">          canalServer.setIp(ip);</span><br><span class="line">          canalServer.setPort(port);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这里提一下这两段代码中的embededCanalServer和canalServer是什么关系，或者说有什么区别"><a href="#这里提一下这两段代码中的embededCanalServer和canalServer是什么关系，或者说有什么区别" class="headerlink" title="这里提一下这两段代码中的embededCanalServer和canalServer是什么关系，或者说有什么区别"></a>这里提一下这两段代码中的embededCanalServer和canalServer是什么关系，或者说有什么区别</h4><pre><code>- embededCanalServer是在程序中启动的，内部保存了所有canalInstance实例的，可以看做是所有同步数据库数据的通道的第一个启动入口
- canalServer是一个在代码中暴露出的一个服务端的接口，如果是默认的netty实现的话，就是暴露一个网络接口供客户端来网络请求的</code></pre><h4 id="好的，回到代码中。接下来的几行代码主要就是如果给定了zk地址，就要在zk里搞点事情。创建两个永久的zk-node-otter-canal-destinations和-otter-canal-cluster-，都是用作之后的的元数据存储的路径，也先不说了，之后在讲到canal-meta这个模块的时候也会提到。"><a href="#好的，回到代码中。接下来的几行代码主要就是如果给定了zk地址，就要在zk里搞点事情。创建两个永久的zk-node-otter-canal-destinations和-otter-canal-cluster-，都是用作之后的的元数据存储的路径，也先不说了，之后在讲到canal-meta这个模块的时候也会提到。" class="headerlink" title="好的，回到代码中。接下来的几行代码主要就是如果给定了zk地址，就要在zk里搞点事情。创建两个永久的zk node (/otter/canal/destinations和/otter/canal/cluster)，都是用作之后的的元数据存储的路径，也先不说了，之后在讲到canal.meta这个模块的时候也会提到。"></a>好的，回到代码中。接下来的几行代码主要就是如果给定了zk地址，就要在zk里搞点事情。创建两个永久的zk node (/otter/canal/destinations和/otter/canal/cluster)，都是用作之后的的元数据存储的路径，也先不说了，之后在讲到canal.meta这个模块的时候也会提到。</h4><h4 id="在构造函数的最后，首先通过调用静态函数的方式，为ServerRunningMonitors类传入了静态成员变量。然后因为默认autoScan这个值是true的，所以又初始化了defaultAction这个方法类和instanceConfigMonitors这个compute-map。"><a href="#在构造函数的最后，首先通过调用静态函数的方式，为ServerRunningMonitors类传入了静态成员变量。然后因为默认autoScan这个值是true的，所以又初始化了defaultAction这个方法类和instanceConfigMonitors这个compute-map。" class="headerlink" title="在构造函数的最后，首先通过调用静态函数的方式，为ServerRunningMonitors类传入了静态成员变量。然后因为默认autoScan这个值是true的，所以又初始化了defaultAction这个方法类和instanceConfigMonitors这个compute map。"></a>在构造函数的最后，首先通过调用静态函数的方式，为ServerRunningMonitors类传入了静态成员变量。然后因为默认autoScan这个值是true的，所以又初始化了defaultAction这个方法类和instanceConfigMonitors这个compute map。</h4><h4 id="好的，感觉在构造函数里困了太久了，先留一些问题，感觉从这里面出来。回到CanalStarter这个类中，构造完CanalController类之后，紧接着直接调用了他的start方法。"><a href="#好的，感觉在构造函数里困了太久了，先留一些问题，感觉从这里面出来。回到CanalStarter这个类中，构造完CanalController类之后，紧接着直接调用了他的start方法。" class="headerlink" title="好的，感觉在构造函数里困了太久了，先留一些问题，感觉从这里面出来。回到CanalStarter这个类中，构造完CanalController类之后，紧接着直接调用了他的start方法。"></a>好的，感觉在构造函数里困了太久了，先留一些问题，感觉从这里面出来。回到CanalStarter这个类中，构造完CanalController类之后，紧接着直接调用了他的start方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">logger.info(&quot;## start the canal server[&#123;&#125;:&#123;&#125;]&quot;, ip, port);</span><br><span class="line">// 创建整个canal的工作节点</span><br><span class="line">final String path = ZookeeperPathUtils.getCanalClusterNode(ip + &quot;:&quot; + port);</span><br><span class="line">initCid(path);</span><br><span class="line">if (zkclientx != null) &#123;</span><br><span class="line">    this.zkclientx.subscribeStateChanges(new IZkStateListener() &#123;</span><br><span class="line"></span><br><span class="line">        public void handleStateChanged(KeeperState state) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void handleNewSession() throws Exception &#123;</span><br><span class="line">            initCid(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void handleSessionEstablishmentError(Throwable error) throws Exception &#123;</span><br><span class="line">            logger.error(&quot;failed to connect to zookeeper&quot;, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这部分代码做的还是初始化的工作。若在配置中有填写zk地址，则会在zk的-otter-canal-cluster-路径下创建一个临时节点，标识当前canal机器已经注册并启动了。接下来的一行才是真正的开始我们canal最想要完成的从数据库拉binlog信息并解析存储的所有工作"><a href="#这部分代码做的还是初始化的工作。若在配置中有填写zk地址，则会在zk的-otter-canal-cluster-路径下创建一个临时节点，标识当前canal机器已经注册并启动了。接下来的一行才是真正的开始我们canal最想要完成的从数据库拉binlog信息并解析存储的所有工作" class="headerlink" title="这部分代码做的还是初始化的工作。若在配置中有填写zk地址，则会在zk的/otter/canal/cluster/路径下创建一个临时节点，标识当前canal机器已经注册并启动了。接下来的一行才是真正的开始我们canal最想要完成的从数据库拉binlog信息并解析存储的所有工作."></a>这部分代码做的还是初始化的工作。若在配置中有填写zk地址，则会在zk的/otter/canal/cluster/路径下创建一个临时节点，标识当前canal机器已经注册并启动了。接下来的一行才是真正的开始我们canal最想要完成的从数据库拉binlog信息并解析存储的所有工作.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 优先启动embeded服务</span><br><span class="line">embededCanalServer.start();</span><br></pre></td></tr></table></figure>

<h4 id="这个start之后，相当于真正打开了所有通道的开关，之后所有通道里面的数据就会像水流一样源源不断的流进流出。这里面我觉得需要单独开一章讲解，所以这里先跳过，下一章再讲。先继续看下面的部分。"><a href="#这个start之后，相当于真正打开了所有通道的开关，之后所有通道里面的数据就会像水流一样源源不断的流进流出。这里面我觉得需要单独开一章讲解，所以这里先跳过，下一章再讲。先继续看下面的部分。" class="headerlink" title="这个start之后，相当于真正打开了所有通道的开关，之后所有通道里面的数据就会像水流一样源源不断的流进流出。这里面我觉得需要单独开一章讲解，所以这里先跳过，下一章再讲。先继续看下面的部分。"></a>这个start之后，相当于真正打开了所有通道的开关，之后所有通道里面的数据就会像水流一样源源不断的流进流出。这里面我觉得需要单独开一章讲解，所以这里先跳过，下一章再讲。先继续看下面的部分。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 尝试启动一下非lazy状态的通道</span><br><span class="line">for (Map.Entry&lt;String, InstanceConfig&gt; entry : instanceConfigs.entrySet()) &#123;</span><br><span class="line">    final String destination = entry.getKey();</span><br><span class="line">    InstanceConfig config = entry.getValue();</span><br><span class="line">    // 创建destination的工作节点</span><br><span class="line">    if (!embededCanalServer.isStart(destination)) &#123;</span><br><span class="line">        // HA机制启动</span><br><span class="line">        ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination);</span><br><span class="line">        if (!config.getLazy() &amp;&amp; !runningMonitor.isStart()) &#123;</span><br><span class="line">            runningMonitor.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (autoScan) &#123;</span><br><span class="line">        instanceConfigMonitors.get(config.getMode()).register(destination, defaultAction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="这段代码的意思是将之前放在instanceConfig这个map中的所有key拿出来遍历一遍，判断是否已经启动了，如果没有，则调用ServerRunningMonitor的静态方法。"><a href="#这段代码的意思是将之前放在instanceConfig这个map中的所有key拿出来遍历一遍，判断是否已经启动了，如果没有，则调用ServerRunningMonitor的静态方法。" class="headerlink" title="这段代码的意思是将之前放在instanceConfig这个map中的所有key拿出来遍历一遍，判断是否已经启动了，如果没有，则调用ServerRunningMonitor的静态方法。"></a>这段代码的意思是将之前放在instanceConfig这个map中的所有key拿出来遍历一遍，判断是否已经启动了，如果没有，则调用ServerRunningMonitor的静态方法。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      ServerRunningMonitor runningMonitor = ServerRunningMonitors.getRunningMonitor(destination);</span><br><span class="line">// ServerRunningMonitors.java</span><br><span class="line">    public static ServerRunningMonitor getRunningMonitor(String destination) &#123;</span><br><span class="line">      return (ServerRunningMonitor) runningMonitors.get(destination);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="因为这个map中一开始没有这个destination的key，所以会调用map的apply方法，得到一个ServerRunningMonitor类，-注意这个类中的setListener方法设置了一个listener，在后面的代码会用到-，之后再调用这个获取的ServerRunningMonitor类的start方法，最后会跳到下面的这段代码中。-这部分代码调用可能有点复杂，建议读者自己调试感受一下"><a href="#因为这个map中一开始没有这个destination的key，所以会调用map的apply方法，得到一个ServerRunningMonitor类，-注意这个类中的setListener方法设置了一个listener，在后面的代码会用到-，之后再调用这个获取的ServerRunningMonitor类的start方法，最后会跳到下面的这段代码中。-这部分代码调用可能有点复杂，建议读者自己调试感受一下" class="headerlink" title="因为这个map中一开始没有这个destination的key，所以会调用map的apply方法，得到一个ServerRunningMonitor类，(注意这个类中的setListener方法设置了一个listener，在后面的代码会用到)，之后再调用这个获取的ServerRunningMonitor类的start方法，最后会跳到下面的这段代码中。 (这部分代码调用可能有点复杂，建议读者自己调试感受一下)"></a>因为这个map中一开始没有这个destination的key，所以会调用map的apply方法，得到一个ServerRunningMonitor类，(注意这个类中的setListener方法设置了一个listener，在后面的代码会用到)，之后再调用这个获取的ServerRunningMonitor类的start方法，最后会跳到下面的这段代码中。 (这部分代码调用可能有点复杂，建议读者自己调试感受一下)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() &#123;</span><br><span class="line">    super.start();</span><br><span class="line">    try &#123;</span><br><span class="line">    	// 进入这段代码可以看到就是调用了之前setListener方法里的processStart方法</span><br><span class="line">    	// 方法内部做的操作就是zk的/otter/canal/destinations/&#123;destination&#125;/cluster/&#123;node&#125;路径下创建临时节点</span><br><span class="line">        processStart();</span><br><span class="line">        if (zkClient != null) &#123;</span><br><span class="line">            // 如果需要尽可能释放instance资源，不需要监听running节点，不然即使stop了这台机器，另一台机器立马会start</span><br><span class="line">            String path = ZookeeperPathUtils.getDestinationServerRunning(destination);</span><br><span class="line">            zkClient.subscribeDataChanges(path, dataListener);</span><br><span class="line"></span><br><span class="line">            initRunning();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            processActiveEnter();// 没有zk，直接启动</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(&quot;start failed&quot;, e);</span><br><span class="line">        // 没有正常启动，重置一下状态，避免干扰下一次start</span><br><span class="line">        stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/19/canal/canal源码分析 (一) 项目结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/19/canal/canal源码分析 (一) 项目结构/" class="post-title-link" itemprop="url">Untitled</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-01-19 16:59:09" itemprop="dateCreated datePublished" datetime="2019-01-19T16:59:09+08:00">2019-01-19</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-27 15:41:30" itemprop="dateModified" datetime="2019-02-27T15:41:30+08:00">2019-02-27</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="canal源码分析-一-项目结构"><a href="#canal源码分析-一-项目结构" class="headerlink" title="canal源码分析 (一) 项目结构"></a>canal源码分析 (一) 项目结构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="本系列都是基于截止目前最新的canal-1-1-3-alpha-2版本-写本文的目的在于最近几个月一直在公司内构建和受用canal以及otter，之前用的都是基于canal的1-0-26版本的，最近看到canal团队发布了1-1-1的重大升级版本，所以正好借此机会研究一下新版本的特性同时对这段时间所学做一个积累和记录。"><a href="#本系列都是基于截止目前最新的canal-1-1-3-alpha-2版本-写本文的目的在于最近几个月一直在公司内构建和受用canal以及otter，之前用的都是基于canal的1-0-26版本的，最近看到canal团队发布了1-1-1的重大升级版本，所以正好借此机会研究一下新版本的特性同时对这段时间所学做一个积累和记录。" class="headerlink" title="本系列都是基于截止目前最新的canal 1.1.3-alpha-2版本,写本文的目的在于最近几个月一直在公司内构建和受用canal以及otter，之前用的都是基于canal的1.0.26版本的，最近看到canal团队发布了1.1.1的重大升级版本，所以正好借此机会研究一下新版本的特性同时对这段时间所学做一个积累和记录。"></a>本系列都是基于截止目前最新的canal 1.1.3-alpha-2版本,写本文的目的在于最近几个月一直在公司内构建和受用canal以及otter，之前用的都是基于canal的1.0.26版本的，最近看到canal团队发布了1.1.1的重大升级版本，所以正好借此机会研究一下新版本的特性同时对这段时间所学做一个积累和记录。</h3><h2 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h2><h3 id="关于canal是什么，在项目的github上面已经有过官方的解释了，我也就不再赘述了，直接贴一下地址，供还不了解canal的读者自己先看一下canal的官方wiki"><a href="#关于canal是什么，在项目的github上面已经有过官方的解释了，我也就不再赘述了，直接贴一下地址，供还不了解canal的读者自己先看一下canal的官方wiki" class="headerlink" title="关于canal是什么，在项目的github上面已经有过官方的解释了，我也就不再赘述了，直接贴一下地址，供还不了解canal的读者自己先看一下canal的官方wiki"></a>关于canal是什么，在项目的github上面已经有过官方的解释了，我也就不再赘述了，直接贴一下地址，供还不了解canal的读者自己先看一下<a href="https://github.com/alibaba/canal/wiki" target="_blank" rel="noopener">canal的官方wiki</a></h3><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="现在进入本文重点要将的canal项目的项目结构概述。准备先大概浏览一下canal这个项目的综述"><a href="#现在进入本文重点要将的canal项目的项目结构概述。准备先大概浏览一下canal这个项目的综述" class="headerlink" title="现在进入本文重点要将的canal项目的项目结构概述。准备先大概浏览一下canal这个项目的综述"></a>现在进入本文重点要将的canal项目的项目结构概述。准备先大概浏览一下canal这个项目的综述</h3><p><img src="/Users/sugu/Documents/2dfire/incubator-technology/%E6%95%B0%E6%8D%AE%E5%A2%9E%E9%87%8F/canal/img/canal%E7%AE%80%E4%BB%8B-1.png" alt="代码结构"></p>
<h3 id="可以看出整个项目费非常多的模块，一开始可能会感觉无从下手，但是不慌，我们慢慢来，一个个模块分别来看一下"><a href="#可以看出整个项目费非常多的模块，一开始可能会感觉无从下手，但是不慌，我们慢慢来，一个个模块分别来看一下" class="headerlink" title="可以看出整个项目费非常多的模块，一开始可能会感觉无从下手，但是不慌，我们慢慢来，一个个模块分别来看一下"></a>可以看出整个项目费非常多的模块，一开始可能会感觉无从下手，但是不慌，我们慢慢来，一个个模块分别来看一下</h3><h4 id="canal-server-amp-amp-canal-client"><a href="#canal-server-amp-amp-canal-client" class="headerlink" title="canal.server &amp;&amp; canal.client"></a>canal.server &amp;&amp; canal.client</h4><hr>
<h5 id="这两个组件属于同一个功能的两段，canal-server负责作为canal服务端提供数据供客户端来调用获取，相应的client就是作为客户端来发送请求。可以理解为一个典型的生产者和消费者的关系，对应的生产出的数据会放入一个内部的RingBuffer中-这个数据结构会在后面提到-。目前server和client提供的模式有三种"><a href="#这两个组件属于同一个功能的两段，canal-server负责作为canal服务端提供数据供客户端来调用获取，相应的client就是作为客户端来发送请求。可以理解为一个典型的生产者和消费者的关系，对应的生产出的数据会放入一个内部的RingBuffer中-这个数据结构会在后面提到-。目前server和client提供的模式有三种" class="headerlink" title="这两个组件属于同一个功能的两段，canal.server负责作为canal服务端提供数据供客户端来调用获取，相应的client就是作为客户端来发送请求。可以理解为一个典型的生产者和消费者的关系，对应的生产出的数据会放入一个内部的RingBuffer中(这个数据结构会在后面提到)。目前server和client提供的模式有三种:"></a>这两个组件属于同一个功能的两段，canal.server负责作为canal服务端提供数据供客户端来调用获取，相应的client就是作为客户端来发送请求。可以理解为一个典型的生产者和消费者的关系，对应的生产出的数据会放入一个内部的RingBuffer中(这个数据结构会在后面提到)。目前server和client提供的模式有三种:</h5><pre><code>- tcp 也就是传统的模式
- rocketmq
- kafka</code></pre><p>####这边进行一下说明，第一种情况下会启动CanalServerWithNetty这个服务类，启动netty为连接的服务器</p>
<p>####第2.3中情况的话，都会启动CanalMQProducer接口对应实现的子类，客户端也都是从相应的通道来获取数据</p>
<p>####这部分的代码都是由canal启动器中根据xml属性或者像otter实现的在控制台上控制，从数据库获取。分别实例化对应的实现类</p>
<h3 id="canal-prometheus"><a href="#canal-prometheus" class="headerlink" title="canal.prometheus"></a>canal.prometheus</h3><h4 id="再看一下这个模块，从名字也可以很容易看出来，这个是canal结合普罗米修斯组件进行数据可视化监控的模块，默认的暴露的metrics的端口是11112，这个在之后也会提到"><a href="#再看一下这个模块，从名字也可以很容易看出来，这个是canal结合普罗米修斯组件进行数据可视化监控的模块，默认的暴露的metrics的端口是11112，这个在之后也会提到" class="headerlink" title="再看一下这个模块，从名字也可以很容易看出来，这个是canal结合普罗米修斯组件进行数据可视化监控的模块，默认的暴露的metrics的端口是11112，这个在之后也会提到"></a>再看一下这个模块，从名字也可以很容易看出来，这个是canal结合普罗米修斯组件进行数据可视化监控的模块，默认的暴露的metrics的端口是11112，这个在之后也会提到</h4><h3 id="canal-instance"><a href="#canal-instance" class="headerlink" title="canal.instance"></a>canal.instance</h3><hr>
<h4 id="这个模块主要是作为每一个canal实例从对应的数据库地址获取数据的运行容器。在canal中，每个独立的数据库配置称为一个destination，这个概念也会在源码中反复出现。在canal启动时会将每个canal-instance放在一个map中，并在需要的时候用CanalInstanceGenerator这种生成器生成我们需要的canalInstance。这里提一句，生成器也是在canal启动的时候根据我们的配置来选择具体实现方式。目前源码中提供了两种生成器的模式"><a href="#这个模块主要是作为每一个canal实例从对应的数据库地址获取数据的运行容器。在canal中，每个独立的数据库配置称为一个destination，这个概念也会在源码中反复出现。在canal启动时会将每个canal-instance放在一个map中，并在需要的时候用CanalInstanceGenerator这种生成器生成我们需要的canalInstance。这里提一句，生成器也是在canal启动的时候根据我们的配置来选择具体实现方式。目前源码中提供了两种生成器的模式" class="headerlink" title="这个模块主要是作为每一个canal实例从对应的数据库地址获取数据的运行容器。在canal中，每个独立的数据库配置称为一个destination，这个概念也会在源码中反复出现。在canal启动时会将每个canal.instance放在一个map中，并在需要的时候用CanalInstanceGenerator这种生成器生成我们需要的canalInstance。这里提一句，生成器也是在canal启动的时候根据我们的配置来选择具体实现方式。目前源码中提供了两种生成器的模式"></a>这个模块主要是作为每一个canal实例从对应的数据库地址获取数据的运行容器。在canal中，每个独立的数据库配置称为一个destination，这个概念也会在源码中反复出现。在canal启动时会将每个canal.instance放在一个map中，并在需要的时候用CanalInstanceGenerator这种生成器生成我们需要的canalInstance。这里提一句，生成器也是在canal启动的时候根据我们的配置来选择具体实现方式。目前源码中提供了两种生成器的模式</h4><pre><code>- manager
- spring</code></pre><h4 id="目前默认的是spring的模式，也就是如何生成具体的canal-instance的构造器方式。"><a href="#目前默认的是spring的模式，也就是如何生成具体的canal-instance的构造器方式。" class="headerlink" title="目前默认的是spring的模式，也就是如何生成具体的canal.instance的构造器方式。"></a>目前默认的是spring的模式，也就是如何生成具体的canal.instance的构造器方式。</h4><h3 id="canal-sink-amp-amp-canal-parse-amp-amp-canal-store"><a href="#canal-sink-amp-amp-canal-parse-amp-amp-canal-store" class="headerlink" title="canal.sink &amp;&amp; canal.parse &amp;&amp; canal.store"></a>canal.sink &amp;&amp; canal.parse &amp;&amp; canal.store</h3><hr>
<h4 id="这几个都是之后会重点解释的模块，这几个模块组成了从mysql里得到的binlog文件的记录，怎么被内部解析和组装成为了可供读取的java内的数据结构，之后再存储在相应的介质中。这个介质可以是内存中的，也可以是rocketmq，kafka之类的消息中间中。"><a href="#这几个都是之后会重点解释的模块，这几个模块组成了从mysql里得到的binlog文件的记录，怎么被内部解析和组装成为了可供读取的java内的数据结构，之后再存储在相应的介质中。这个介质可以是内存中的，也可以是rocketmq，kafka之类的消息中间中。" class="headerlink" title="这几个都是之后会重点解释的模块，这几个模块组成了从mysql里得到的binlog文件的记录，怎么被内部解析和组装成为了可供读取的java内的数据结构，之后再存储在相应的介质中。这个介质可以是内存中的，也可以是rocketmq，kafka之类的消息中间中。"></a>这几个都是之后会重点解释的模块，这几个模块组成了从mysql里得到的binlog文件的记录，怎么被内部解析和组装成为了可供读取的java内的数据结构，之后再存储在相应的介质中。这个介质可以是内存中的，也可以是rocketmq，kafka之类的消息中间中。</h4><h3 id="canal-example"><a href="#canal-example" class="headerlink" title="canal.example"></a>canal.example</h3><hr>
<h4 id="官方提供了一些简单的例子，可以看一下具体的实现方法。"><a href="#官方提供了一些简单的例子，可以看一下具体的实现方法。" class="headerlink" title="官方提供了一些简单的例子，可以看一下具体的实现方法。"></a>官方提供了一些简单的例子，可以看一下具体的实现方法。</h4><h2 id="以上就是对canal整个代码结构进行了一些简单的解析，有一些组件我还没有提到，在之后的源码探究过程中也会有涉及。好了，现在让我们一起进入这个神秘的中间件里一探究竟。"><a href="#以上就是对canal整个代码结构进行了一些简单的解析，有一些组件我还没有提到，在之后的源码探究过程中也会有涉及。好了，现在让我们一起进入这个神秘的中间件里一探究竟。" class="headerlink" title="以上就是对canal整个代码结构进行了一些简单的解析，有一些组件我还没有提到，在之后的源码探究过程中也会有涉及。好了，现在让我们一起进入这个神秘的中间件里一探究竟。"></a>以上就是对canal整个代码结构进行了一些简单的解析，有一些组件我还没有提到，在之后的源码探究过程中也会有涉及。好了，现在让我们一起进入这个神秘的中间件里一探究竟。</h2>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Swaggy Q</p>
              <div class="site-description motion-element" itemprop="description">拉塞尔FMVP了吗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Swaggy Q</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
