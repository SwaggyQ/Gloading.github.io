<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拉塞尔FMVP了吗">
<meta name="keywords" content="Dloading...">
<meta property="og:type" content="website">
<meta property="og:title" content="Dloading...">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Dloading...">
<meta property="og:description" content="拉塞尔FMVP了吗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dloading...">
<meta name="twitter:description" content="拉塞尔FMVP了吗">





  
  
  <link rel="canonical" href="http://yoursite.com/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dloading...</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dloading...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">努力成为优秀程序员</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/线程池详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/线程池详解/" class="post-title-link" itemprop="url">线程池详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:40:51" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解"><a href="#本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解" class="headerlink" title="本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解"></a>本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="先看到构造方法做了什么"><a href="#先看到构造方法做了什么" class="headerlink" title="先看到构造方法做了什么"></a>先看到构造方法做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。"><a href="#先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。" class="headerlink" title="先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。"></a>先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。</h4><h4 id="再看到最重要的execute方法。"><a href="#再看到最重要的execute方法。" class="headerlink" title="再看到最重要的execute方法。"></a>再看到最重要的execute方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">        	throw new NullPointerException();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看"><a href="#首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看" class="headerlink" title="首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看"></a>首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 线程池内部的一个AtomInteger类型的参数，可用于计算当前的线程数以及线程池的状态，具体操作内容就是通过对bit之间的操作，先不细讲</span><br><span class="line">int c = ctl.get();</span><br><span class="line">// 通过c先计算得到当前线程池的线程数，如果小于构造函数中传入的核心线程池大小的话，就会通过addWorker方法继续往线程池中添加线程</span><br><span class="line">     if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">     	// 注意这边的第二个参数为true，代表正在添加工作节点</span><br><span class="line">          if (addWorker(command, true))</span><br><span class="line">              return;</span><br><span class="line">          c = ctl.get();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下"><a href="#在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下" class="headerlink" title="在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下"></a>在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下</h4><ul>
<li>如果新任务进来时，线程池中的线程数小于corePoolSize，则继续向线程池中添加新的工作者，也就是新的线程</li>
</ul>
<h4 id="现在继续看看addWorker方法里面做了什么"><a href="#现在继续看看addWorker方法里面做了什么" class="headerlink" title="现在继续看看addWorker方法里面做了什么"></a>现在继续看看addWorker方法里面做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        // 做了一次标记，用于之后跳出循环</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        	// 得到这个值，用于计算当前线程池的状态，总共有5种状态</span><br><span class="line">        	// RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">    		// SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">    		// STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">    		// TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">    		// TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // Check if queue empty only if necessary.</span><br><span class="line">            // 如果计算得到的线程池当前的状态rs &gt; SHUTDOWN 以及以下三个条件不同时满足，则代表添加工作节点失败，否则继续执行</span><br><span class="line">            // 1: rs等于SHUTDOWN</span><br><span class="line">            // 2: 传入的Runnable参数为空</span><br><span class="line">            // 3: 工作队列不为空</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == null &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                return false;</span><br><span class="line">			</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">            	// 得到当前线程池的工作线程数</span><br><span class="line">                int wc = workerCountOf(c);</span><br><span class="line">                // 如果当前线程数wc 已经大于了(1 &lt;&lt; 29) - 1</span><br><span class="line">                // 或者</span><br><span class="line">                // 根据方法的第二个参数来判断，wc是大于corePoolSize还是最大线程数，如果是大于，则也代表无法再添加新工作节点了，返回添加失败</span><br><span class="line">                if (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    return false;</span><br><span class="line">                // 用CAS的方法将变量c+1，代表多了一个线程</span><br><span class="line">                if (compareAndIncrementWorkerCount(c))</span><br><span class="line">        	// 如果线程数新增成功，也跳出永真循环</span><br><span class="line">                    break retry;</span><br><span class="line">                c = ctl.get();  // Re-read ctl</span><br><span class="line">                if (runStateOf(c) != rs)</span><br><span class="line">                    continue retry;</span><br><span class="line">                // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在方法中若满足条件，会用永真循环将线程数-1，成功后再看下面的操作"><a href="#在方法中若满足条件，会用永真循环将线程数-1，成功后再看下面的操作" class="headerlink" title="在方法中若满足条件，会用永真循环将线程数+1，成功后再看下面的操作"></a>在方法中若满足条件，会用永真循环将线程数+1，成功后再看下面的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 两个布尔值，判断工作节点是否加入队列中，以及是否启动</span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">      boolean workerAdded = false;</span><br><span class="line">      Worker w = null;</span><br><span class="line">      try &#123;</span><br><span class="line">      	// 用Runnable参数构建工作节点，内部会通过线程工厂构建一个新的线程，所以Worker内部包括</span><br><span class="line">      	// Runnable , Thread</span><br><span class="line">          w = new Worker(firstTask);</span><br><span class="line">          // 得到对应的线程</span><br><span class="line">          final Thread t = w.thread;</span><br><span class="line">          if (t != null) &#123;</span><br><span class="line">          	// 获得可重入锁</span><br><span class="line">              final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">              mainLock.lock();</span><br><span class="line">              try &#123;</span><br><span class="line">                  // Recheck while holding lock.</span><br><span class="line">                  // Back out on ThreadFactory failure or if</span><br><span class="line">                  // shut down before lock acquired.</span><br><span class="line">                  // 获得当前线程池的状态</span><br><span class="line">                  int rs = runStateOf(ctl.get());</span><br><span class="line">                  if (rs &lt; SHUTDOWN ||</span><br><span class="line">                      (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                      if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                          throw new IllegalThreadStateException();</span><br><span class="line">					// 在阻塞队列中添加新任务</span><br><span class="line">                      workers.add(w);</span><br><span class="line">                      int s = workers.size();</span><br><span class="line">                      // 然后更新最大的线程池大小</span><br><span class="line">                      if (s &gt; largestPoolSize)</span><br><span class="line">                          largestPoolSize = s;</span><br><span class="line">                      workerAdded = true;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  mainLock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              // 启动线程</span><br><span class="line">              if (workerAdded) &#123;</span><br><span class="line">                  t.start();</span><br><span class="line">                  workerStarted = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">      	// 如果启动失败，则移除</span><br><span class="line">          if (! workerStarted)</span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">      return workerStarted;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。"><a href="#以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。" class="headerlink" title="以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。"></a>以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">       if (command == null)</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       int c = ctl.get();</span><br><span class="line">       if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       	// 如果添加成功，代表线程已经启动</span><br><span class="line">           if (addWorker(command, true))</span><br><span class="line">               return;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">	if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           int recheck = ctl.get();</span><br><span class="line">           if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               reject(command);</span><br><span class="line">           else if (workerCountOf(recheck) == 0)</span><br><span class="line">               addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">       else if (!addWorker(command, false))</span><br><span class="line">           reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方"><a href="#重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方" class="headerlink" title="重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方"></a>重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/堆外内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/堆外内存/" class="post-title-link" itemprop="url">堆外内存</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:10:13" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h1><p>和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p>
<p>二、使用堆外内存的优点</p>
<p>1、减少了垃圾回收<br>因为垃圾回收会暂停其他的工作。<br>2、加快了复制的速度<br>堆内在flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。<br>同样任何一个事物使用起来有优点就会有缺点，堆外内存的缺点就是内存难以控制，使用了堆外内存就间接失去了JVM管理内存的可行性，改由自己来管理，当发生内存溢出时排查起来非常困难</p>
<p>-XX:MaxDirectMemorySize来指定最大的堆外内存大小<br>如果没设置-XX:MaxDirectMemorySize，则默认与-Xmx参数值相同</p>
<p>2、System.gc的作用有哪些<br>说起堆外内存免不了要提及System.gc方法，下面就是使用了System.gc的作用是什么？</p>
<p>做一次full gc<br>执行后会暂停整个进程。<br>System.gc我们可以禁掉，使用-XX:+DisableExplicitGC，<br>其实一般在cms gc下我们通过-XX:+ExplicitGCInvokesConcurrent也可以做稍微高效一点的gc，也就是并行gc。<br>最常见的场景是RMI/NIO下的堆外内存分配等</p>
<p>DirectByteBuffer<br>JDK中使用DirectByteBuffer对象来表示堆外内存，每个DirectByteBuffer对象在初始化时，都会创建一个对用的Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存。</p>
<p>用堆外内存和UNSAFE的内存泄漏问题，可以用下面这个例子解释一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// -verbose:gc -XX:+PrintGCDetails -XX:MaxDirectMemorySize=40M</span><br><span class="line">public static void main(String[] args) throws InterruptedException&#123;</span><br><span class="line">       while (true)</span><br><span class="line">       &#123;</span><br><span class="line">           ByteBuffer buffer = ByteBuffer.allocateDirect(10 * 1024 * 1024);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="用上面这一段代码不停的进行堆外内存的分配的时候，是不会造成OOM的，而是会非常频繁的产生GC"><a href="#用上面这一段代码不停的进行堆外内存的分配的时候，是不会造成OOM的，而是会非常频繁的产生GC" class="headerlink" title="用上面这一段代码不停的进行堆外内存的分配的时候，是不会造成OOM的，而是会非常频繁的产生GC"></a>用上面这一段代码不停的进行堆外内存的分配的时候，是不会造成OOM的，而是会非常频繁的产生GC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">	Unsafe unsafe = GetUsafeInstance.getUnsafeInstance();</span><br><span class="line"></span><br><span class="line">	while (true)</span><br><span class="line">	&#123;</span><br><span class="line">		long pointer = unsafe.allocateMemory(1024 * 1024 * 20);</span><br><span class="line">		System.out.println(unsafe.getByte(pointer + 1));</span><br><span class="line"></span><br><span class="line">		// 如果不释放内存,运行一段时间会报错java.lang.OutOfMemoryError</span><br><span class="line">		// unsafe.freeMemory(pointer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="而如果是用上面这一段代码的话，很快就会OOM异常。这是因为在jvm分配对象的时候，会有内置的垃圾回收器不停的帮我们回收不可用的对象，但是堆外内存显然是不受这个控制的。用UNSAFE分配内存，其实底层调用的还是C语言的malloc命令，我们知道在C语言中，对象必须都是由程序自主的释放的，也就是用free。所以如果UNSAFE使用不当，很容易会造成内存泄漏问题"><a href="#而如果是用上面这一段代码的话，很快就会OOM异常。这是因为在jvm分配对象的时候，会有内置的垃圾回收器不停的帮我们回收不可用的对象，但是堆外内存显然是不受这个控制的。用UNSAFE分配内存，其实底层调用的还是C语言的malloc命令，我们知道在C语言中，对象必须都是由程序自主的释放的，也就是用free。所以如果UNSAFE使用不当，很容易会造成内存泄漏问题" class="headerlink" title="而如果是用上面这一段代码的话，很快就会OOM异常。这是因为在jvm分配对象的时候，会有内置的垃圾回收器不停的帮我们回收不可用的对象，但是堆外内存显然是不受这个控制的。用UNSAFE分配内存，其实底层调用的还是C语言的malloc命令，我们知道在C语言中，对象必须都是由程序自主的释放的，也就是用free。所以如果UNSAFE使用不当，很容易会造成内存泄漏问题"></a>而如果是用上面这一段代码的话，很快就会OOM异常。这是因为在jvm分配对象的时候，会有内置的垃圾回收器不停的帮我们回收不可用的对象，但是堆外内存显然是不受这个控制的。用UNSAFE分配内存，其实底层调用的还是C语言的malloc命令，我们知道在C语言中，对象必须都是由程序自主的释放的，也就是用free。所以如果UNSAFE使用不当，很容易会造成内存泄漏问题</h4><h4 id="再说回ByteBuffer类，为什么这个不会有问题呢？这个是因为在类的包装中，不但考虑到了malloc，还会在合适的时候进行free。这也就是我们接下来想要讨论的，java是怎么监控到堆外内存的生命周期呢？"><a href="#再说回ByteBuffer类，为什么这个不会有问题呢？这个是因为在类的包装中，不但考虑到了malloc，还会在合适的时候进行free。这也就是我们接下来想要讨论的，java是怎么监控到堆外内存的生命周期呢？" class="headerlink" title="再说回ByteBuffer类，为什么这个不会有问题呢？这个是因为在类的包装中，不但考虑到了malloc，还会在合适的时候进行free。这也就是我们接下来想要讨论的，java是怎么监控到堆外内存的生命周期呢？"></a>再说回ByteBuffer类，为什么这个不会有问题呢？这个是因为在类的包装中，不但考虑到了malloc，还会在合适的时候进行free。这也就是我们接下来想要讨论的，java是怎么监控到堆外内存的生命周期呢？</h4><p>DirectByteBuffer构造方法中还做了挺多事情的，总的来说分为几个步骤：</p>
<p>预分配内存<br>分配内存<br>将刚分配的内存空间初始化为0<br>创建一个cleaner对象，Cleaner对象的作用是当DirectByteBuffer对象被回收时，释放其对应的堆外内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</span><br></pre></td></tr></table></figure>

<p>cleaner 是一个虚引用类型，然后内部还会有一个Runnable类型的对象，在释放内存的时候被调用<br>Cleaner.create被调用的时候，会在内部组成一个cleaner的链路</p>
<p>简单的说，就是当字段referent(也就是DirectByteBuffer对象)被回收时，会调用到Cleaner#clean方法，最终会调用到Deallocator#run进行堆外内存的回收。</p>
<p>Cleaner是虚引用在JDK中的一个典型应用场景。</p>
<p>在创建一个新的DirecByteBuffer时，会先确认有没有足够的内存，如果没有的话，会通过一些手段回收一部分堆外内存，直到可用内存大于需要分配的内存。具体步骤如下：</p>
<p>如果可用堆外内存足够，则直接返回<br>调用tryHandlePendingReference方法回收已经变成垃圾的DirectByteBuffer对象对应的堆外内存，直到可用内存足够，或目前没有垃圾DirectByteBuffer对象<br>触发一次full gc，其主要目的是为了防止’冰山现象‘：一个DirectByteBuffer对象本身占用的内存很小，但是它可能引用了一块很大的堆外内存。如果DirectByteBuffer对象进入了老年代之后变成了垃圾，因为老年代GC一直没有触发，导致这块堆外内存也一直没有被回收。需要注意的是如果使用参数-XX:+DisableExplicitGC，那System.gc();是无效的<br>重复1，2步骤的流程，直到可用内存大于需要分配的内存<br>如果超出指定次数还没有回收到足够内存，则OOM</p>
<p>tryHandlePendingReference最终调用到的是Reference#tryHandlePending</p>
<p>可以看到，tryHandlePendingReference的最终效果就是：如果有垃圾DirectBytebuffer对象，则调用对应的Cleaner#clean方法进行回收。clean方法在上面已经分析过了。</p>
<p><img src="img/reference.jpeg" alt="引用被回收的全过程"></p>
<p>refs_lists中存放了本次GC发现的某种引用类型（虚引用、软引用、弱引用等），而process_discovered_reflist方法的作用就是将不需要被回收的对象从refs_lists移除掉，refs_lists最后剩下的元素全是需要被回收的元素，最后会将其第一个元素赋值给上文提到过的Reference.java#pending字段。<br>判断是不是需要回收是由一个ReferencePolicy决定的，有四种实现方式<br>NeverClearPolicy，AlwaysClearPolicy，LRUCurrentHeapPolicy，LRUMaxHeapPolicy</p>
<p>软引用默认使用LRUCurrentHeapPolicy</p>
<p>参考图中的得到DiscoveredList后，会再进行一步将不需要被回收的对象从refs_lists移除的操作。上面说过，如果是软引用，会有policy来进行判断是否被回收。如果是虚引用，或者是弱引用，则不会有这个policy。</p>
<p>强引用： 如果有指向，永远不会被回收<br>软引用：跟堆内存和get方法被调用的时间有关，在jvm的gc过程中会调用LRUCurrentHeapPolicy来进行判断<br>弱引用：不存在policy判断，只要进行内存回收，都会直接被回收<br>虚引用：指向的对象永远不会被回收，虚引用的get方法也不会得到相应的对象，可以传入一个队列，只是作为当对象被回收后的指示。</p>
<blockquote>
<p>2.网上对于虚引用的介绍是：形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。主要用来跟踪对象被垃圾回收器回收的活动。真的是这样吗？</p>
</blockquote>
<blockquote>
<p>严格的说，虚引用是会影响对象生命周期的，如果不做任何处理，只要虚引用不被回收，那其引用的对象永远不会被回收。所以一般来说，从ReferenceQueue中获得PhantomReference对象后，如果PhantomReference对象不会被回收的话（比如被其他GC ROOT可达的对象引用），需要调用clear方法解除PhantomReference和其引用对象的引用关系。</p>
</blockquote>
<p>怎么理解？</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/聊聊 Synchronize 关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/聊聊 Synchronize 关键字/" class="post-title-link" itemprop="url">聊聊 Synchronize 关键字</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:42:36" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊聊-Synchronize-关键字"><a href="#聊聊-Synchronize-关键字" class="headerlink" title="聊聊 Synchronize 关键字"></a>聊聊 Synchronize 关键字</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况"><a href="#Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况" class="headerlink" title="Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况"></a>Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况</h4><p>1：修饰普通方法，锁的对象是当前实例<br>2：修饰形态方法，锁的对象是当前类class对象<br>3：修饰同步代码块，锁的对象是括号中的内容，可以是实例也可以是class对象</p>
<h4 id="以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的"><a href="#以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的" class="headerlink" title="以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的"></a>以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br></pre></td></tr></table></figure>

<h4 id="就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。"><a href="#就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。" class="headerlink" title="就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。"></a>就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter  //注意此处，进入同步方法</span><br><span class="line">...      </span><br><span class="line">   21: monitorexit //注意此处，退出同步方法</span><br></pre></td></tr></table></figure>

<h4 id="可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。"><a href="#可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。" class="headerlink" title="可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。"></a>可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。</h4><h4 id="再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性"><a href="#再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性" class="headerlink" title="再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性"></a>再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性</h4><p>1：当线程A正在访问某个实例对象的普通Synchronize方法，或者同步代码块的括号中为一个实例对象是，其他线程不但不能访问这个同步方法，而且其他同步方法也不能方法。但是静态的同步方法是可以访问的，因为之前说过实例对象和类对象是有自己不同的监视器的</p>
<h4 id="之前说了很多次监视器，那么监视器到底是什么呢-在java中，这部分是用c-实现的，对应的对象内容如下"><a href="#之前说了很多次监视器，那么监视器到底是什么呢-在java中，这部分是用c-实现的，对应的对象内容如下" class="headerlink" title="之前说了很多次监视器，那么监视器到底是什么呢?在java中，这部分是用c++实现的，对应的对象内容如下"></a>之前说了很多次监视器，那么监视器到底是什么呢?在java中，这部分是用c++实现的，对应的对象内容如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = 0; //用来记录该对象被线程获取锁的次数</span><br><span class="line">    _waiters      = 0;</span><br><span class="line">    _recursions   = 0; //锁的重入次数</span><br><span class="line">    _owner        = NULL; //指向持有ObjectMonitor对象的线程 </span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这一块的解释，我引用被人写的一个整个的属性转换的过程"><a href="#这一块的解释，我引用被人写的一个整个的属性转换的过程" class="headerlink" title="这一块的解释，我引用被人写的一个整个的属性转换的过程"></a>这一块的解释，我引用被人写的一个整个的属性转换的过程</h4><blockquote>
<p>对于一个synchronized修饰的方法(代码块)来说：<br>当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态<br>当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象的_owner指向当前线程，_count加1表示当前对象锁被一个线程获取<br>当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1，同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入_Owner区<br>如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1</p>
</blockquote>
<h4 id="现在再讲讲关于锁的一些膨胀的机制。其实在jdk-1-6之前，是只有重量锁，在jdk-1-6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。"><a href="#现在再讲讲关于锁的一些膨胀的机制。其实在jdk-1-6之前，是只有重量锁，在jdk-1-6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。" class="headerlink" title="现在再讲讲关于锁的一些膨胀的机制。其实在jdk 1.6之前，是只有重量锁，在jdk 1.6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。"></a>现在再讲讲关于锁的一些膨胀的机制。其实在jdk 1.6之前，是只有重量锁，在jdk 1.6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。</h4><h4 id="先讲到重量锁"><a href="#先讲到重量锁" class="headerlink" title="先讲到重量锁"></a>先讲到重量锁</h4><p>重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。</p>
<p>可以看到锁信息也是存在于对象的mark word中的。当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/类加载器/" class="post-title-link" itemprop="url">类加载器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:09:55" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>Java类加载器的作用就是在运行时加载类。Java类加载器基于三个机制：委托、可见性和单一性。</p>
<ul>
<li>委托机制是指将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它。</li>
<li>可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li>单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。</li>
</ul>
</blockquote>
<h4 id="java提供了三种类加载器"><a href="#java提供了三种类加载器" class="headerlink" title="java提供了三种类加载器"></a>java提供了三种类加载器</h4><p>1) Bootstrap类加载器 – JRE/lib/rt.jar</p>
<p>2) Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录</p>
<p>3) Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.</p>
<p>4）自定义类加载器 - 继承java.lang.ClassLoader的自定义类加载器</p>
<h4 id="以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托"><a href="#以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托" class="headerlink" title="以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托"></a>以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托</h4><h4 id="采用双亲委派的一个好处是比如加载位于-rt-jar-包中的类-java-lang-Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个-Object-对象。"><a href="#采用双亲委派的一个好处是比如加载位于-rt-jar-包中的类-java-lang-Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个-Object-对象。" class="headerlink" title="采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。"></a>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</h4><p><img src="/Users/sugu/Documents/markdown/jdk/classLoader.jpeg" alt="类加载器"></p>
<h4 id="显式的加载类的方式"><a href="#显式的加载类的方式" class="headerlink" title="显式的加载类的方式"></a>显式的加载类的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(classname)</span><br><span class="line">Class.forName(classname, initialized, classloader)。</span><br></pre></td></tr></table></figure>

<h4 id="注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的"><a href="#注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的" class="headerlink" title="注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的"></a>注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的</h4><h4 id="基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定"><a href="#基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定" class="headerlink" title="基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定"></a>基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定</h4><blockquote>
<p>第一次：在双亲委派模型出现之前—–即JDK1.2发布之前。<br>第二次：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，如果基础类调用会用户的代码怎么办呢？<br>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？<br>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。<br>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。<br>第三次：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/线程池/" class="post-title-link" itemprop="url">线程池源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:08:39" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释"><a href="#本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释" class="headerlink" title="本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释"></a>本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况"><a href="#在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况" class="headerlink" title="在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况"></a>在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况</h4><p><img src="img/threadPoolStatus.jpg" alt="线程池的状态转换"></p>
<pre><code> * RUNNING -&gt; SHUTDOWN
*    On invocation of shutdown(), perhaps implicitly in finalize()
* (RUNNING or SHUTDOWN) -&gt; STOP
*    On invocation of shutdownNow()
* SHUTDOWN -&gt; TIDYING
*    When both queue and pool are empty
* STOP -&gt; TIDYING
*    When pool is empty
* TIDYING -&gt; TERMINATED
*    When the terminated() hook method has completed
*</code></pre><h4 id="另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。"><a href="#另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。" class="headerlink" title="另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。"></a>另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。</h4><h4 id="好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的"><a href="#好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的" class="headerlink" title="好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的."></a>好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的.</h4><h2 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">   if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       if (addWorker(command, true))</span><br><span class="line">           return;</span><br><span class="line">       c = ctl.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。"><a href="#先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。" class="headerlink" title="先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。"></a>先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">	retry:</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">	    int c = ctl.get();</span><br><span class="line">	    // 得到线程池目前的状态</span><br><span class="line">	    int rs = runStateOf(c);</span><br><span class="line">	</span><br><span class="line">	    // Check if queue empty only if necessary.</span><br><span class="line">	    // 如果当前线程池状态是SHUTDOWN或者以上</span><br><span class="line">	    // 除非是状态为SHUTDOWN，且新增的是非core，且队列不为空  (可以理解为，还不是TIDYING状态)</span><br><span class="line">	    // 否则应该直接添加失败</span><br><span class="line">	    // 这句话可以这样理解，当线程池的状态已经最起码是SHUTDOWN了，那么按理说，是不应该继续添加工作线程的，除非是因为状态是SHUTDOWN，虽然不再接收新的任务，但是还需要将旧的任务执行完，那么此时可能会加入一些临时工性质的非core线程，标识就是firstTask为null</span><br><span class="line">	    if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">	        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">	           firstTask == null &amp;&amp;</span><br><span class="line">	           ! workQueue.isEmpty()))</span><br><span class="line">	        // 如果满足以上条件，则添加失败</span><br><span class="line">	        return false;</span><br><span class="line">	</span><br><span class="line">	    for (;;) &#123;</span><br><span class="line">	    	// 再次得到目前的节点数</span><br><span class="line">	        int wc = workerCountOf(c);</span><br><span class="line">	        // 如果已经大于了最大数量，或者大于设定的参数</span><br><span class="line">	        if (wc &gt;= CAPACITY ||</span><br><span class="line">	            wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">	            return false;</span><br><span class="line">	        // 将线程数+1</span><br><span class="line">	        if (compareAndIncrementWorkerCount(c))</span><br><span class="line">	            break retry;</span><br><span class="line">	        c = ctl.get();  // Re-read ctl</span><br><span class="line">	        // 若线程状态已经改变，则需要执行外部的大循环，否则执行内部的循环</span><br><span class="line">	        if (runStateOf(c) != rs)</span><br><span class="line">	            continue retry;</span><br><span class="line">	        // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目-1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码"><a href="#注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目-1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码" class="headerlink" title="注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目+1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码"></a>注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目+1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 标识是否启动成功</span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">// 标识是否添加成功</span><br><span class="line">   boolean workerAdded = false;</span><br><span class="line">   Worker w = null;</span><br><span class="line">   try &#123;</span><br><span class="line">   	// 构建worker，包含thread和runnable两个属性</span><br><span class="line">       w = new Worker(firstTask);</span><br><span class="line">       final Thread t = w.thread;</span><br><span class="line">       if (t != null) &#123;</span><br><span class="line">           final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           try &#123;</span><br><span class="line">               // Recheck while holding lock.</span><br><span class="line">               // Back out on ThreadFactory failure or if</span><br><span class="line">               // shut down before lock acquired.</span><br><span class="line">               int rs = runStateOf(ctl.get());</span><br><span class="line">               // 如果目前状态是RUNNING，或者是SHUTDOWN但是添加的是非core</span><br><span class="line">               if (rs &lt; SHUTDOWN ||</span><br><span class="line">                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                   if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                       throw new IllegalThreadStateException();</span><br><span class="line">                   workers.add(w);</span><br><span class="line">                   int s = workers.size();</span><br><span class="line">                   if (s &gt; largestPoolSize)</span><br><span class="line">                       largestPoolSize = s;</span><br><span class="line">                   workerAdded = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           if (workerAdded) &#123;</span><br><span class="line">           	// 若添加成功，则启动对应的线程</span><br><span class="line">               t.start();</span><br><span class="line">               workerStarted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       if (! workerStarted)</span><br><span class="line">           addWorkerFailed(w);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况"><a href="#以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况" class="headerlink" title="以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况"></a>以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">       final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">       	// 若之前已经在set中记录了worker，则需要移除</span><br><span class="line">           if (w != null)</span><br><span class="line">               workers.remove(w);</span><br><span class="line">           // 永真循环的减小工作节点数</span><br><span class="line">           decrementWorkerCount();</span><br><span class="line">           tryTerminate();</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看"><a href="#大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看" class="headerlink" title="大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看"></a>大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 如果线程池的状态是STOP或者Terminal，并且workQueue为空</span><br><span class="line">// 则原子性的将线程池的状态改为Terminate，</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        // 若状态还是RUNNING或者为 TIDYING或者TERMINATED</span><br><span class="line">        // 或者是SHUTDOWN但是任务队列不为空</span><br><span class="line">        // 则可以直接退出当前方法</span><br><span class="line">        // 所以可以得到，只有当前线程池状态是SHUTDOWN且任务队列为空，或者状态为Stop的时候，才会继续</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">		// 若此时线程池中的线程已经为0，则可以调用terminated方法</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑"><a href="#再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑" class="headerlink" title="再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑"></a>再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果此时线程池的运行状态是正常的，但是上一步添加worker失败。则需要将传入的Runnable参数放入阻塞队列中</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">       int recheck = ctl.get();</span><br><span class="line">       // 再重复检查一遍，若线程池不在运行，则需要移除任务，并用拒绝策略执行相应的方法</span><br><span class="line">       if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">           reject(command);</span><br><span class="line">       // 如果线程池现在正在运行，但是此时的工作节点数为0，则需要直接新节点</span><br><span class="line">       else if (workerCountOf(recheck) == 0)</span><br><span class="line">           addWorker(null, false);</span><br><span class="line">   &#125;</span><br><span class="line">   // 如果当前线程池不是正常运行状态，则尝试添加非核心线程</span><br><span class="line">   else if (!addWorker(command, false))</span><br><span class="line">       reject(command);</span><br></pre></td></tr></table></figure>

<h4 id="现在再回到刚才的新建worker，然后启动worker中的线程的部分"><a href="#现在再回到刚才的新建worker，然后启动worker中的线程的部分" class="headerlink" title="现在再回到刚才的新建worker，然后启动worker中的线程的部分"></a>现在再回到刚才的新建worker，然后启动worker中的线程的部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">       setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">       this.firstTask = firstTask;</span><br><span class="line">       this.thread = getThreadFactory().newThread(this);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** Delegates main run loop to outer runWorker  */</span><br><span class="line">   public void run() &#123;</span><br><span class="line">       runWorker(this);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。"><a href="#可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。" class="headerlink" title="可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。"></a>可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">       Thread wt = Thread.currentThread();</span><br><span class="line">       // 得到传入的firstTask，注意这个可能是nul</span><br><span class="line">       Runnable task = w.firstTask;</span><br><span class="line">       w.firstTask = null;</span><br><span class="line">       w.unlock(); // allow interrupts</span><br><span class="line">       boolean completedAbruptly = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (task != null || (task = getTask()) != null)&#123;</span><br><span class="line">               w.lock();</span><br><span class="line">               if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               try &#123;</span><br><span class="line">               	// 预留给子类实现的方法</span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = null;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; throw x;</span><br><span class="line">                   &#125; catch (Error x) &#123;</span><br><span class="line">                       thrown = x; throw x;</span><br><span class="line">                   &#125; catch (Throwable x) &#123;</span><br><span class="line">                       thrown = x; throw new Error(x);</span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                   	// 预留给子类实现的方法</span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   task = null;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = false;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。"><a href="#可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。" class="headerlink" title="可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。"></a>可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">	// 如果不是被中断退出的，那么在getTask方法中就已经做了这一步了</span><br><span class="line">       if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">           decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">       final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">       mainLock.lock();</span><br><span class="line">       try &#123;</span><br><span class="line">           completedTaskCount += w.completedTasks;</span><br><span class="line">           // 移除当前工作节点</span><br><span class="line">           workers.remove(w);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           mainLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       tryTerminate();</span><br><span class="line"></span><br><span class="line">       int c = ctl.get();</span><br><span class="line">       // 如果当前线程池状态起码已经是STOP了</span><br><span class="line">       if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">       	// 如果当前线程不是用户中断的，则需要判断是否需要新增工作节点</span><br><span class="line">           if (!completedAbruptly) &#123;</span><br><span class="line">               int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">               if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                   min = 1;</span><br><span class="line">               // 如果当前线程数不够最小线程数</span><br><span class="line">               if (workerCountOf(c) &gt;= min)</span><br><span class="line">                   return; // replacement not needed</span><br><span class="line">           &#125;</span><br><span class="line">           addWorker(null, false);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在再来看看getTask方法做了什么"><a href="#现在再来看看getTask方法做了什么" class="headerlink" title="现在再来看看getTask方法做了什么"></a>现在再来看看getTask方法做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">	// 通过一个布尔值标识重试的第二次方法是否超时</span><br><span class="line">       boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">       for (;;) &#123;</span><br><span class="line">       	// 再计算一次线程池的状态</span><br><span class="line">           int c = ctl.get();</span><br><span class="line">           int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">           // Check if queue empty only if necessary.</span><br><span class="line">		// 如果状态已经是SHUTDOWN且任务队列已经空或者起码是STOP</span><br><span class="line">		// 则直接返回null</span><br><span class="line">           if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">               decrementWorkerCount();</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">		// 计算当前线程池中的线程数</span><br><span class="line">           int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">           // Are workers subject to culling?</span><br><span class="line">           // 工作节点是否需要被淘汰</span><br><span class="line">           boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">		// 如果当前线程数已经大于最大阈值 或者 需要淘汰且上一次已经超时</span><br><span class="line">		// 而且线程数大于1，或者任务队列已经为空</span><br><span class="line">		// 则需要减少线程数，并返回null</span><br><span class="line">           if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">               if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   return null;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           try &#123;</span><br><span class="line">           	// 根据是否需要淘汰线程，选择是需要带超时的poll方法还是take方法</span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               if (r != null)</span><br><span class="line">                   return r;</span><br><span class="line">               timedOut = true;</span><br><span class="line">           &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="从上面的代码中我们可以提炼出一些细节点"><a href="#从上面的代码中我们可以提炼出一些细节点" class="headerlink" title="从上面的代码中我们可以提炼出一些细节点"></a>从上面的代码中我们可以提炼出一些细节点</h4><ul>
<li>可以指定allowCoreThreadTimeOut参数来确定是否需要淘汰core线程。默认是false。</li>
<li>当线程池中的线程数大于了corePoolSize，则开始考虑是否需要淘汰线程</li>
<li>当开始开始考虑线程后，会将从workQueue获取任务的方式从阻塞的take，换成用给定的传入的keepAliveTime做超时时间的poll方法</li>
<li>因为获取任务是一个不断重试的过程，所以如果第一次超时了，则会进行第二次。这时候就会判断任务队列中是不是已经空了，以及当前线程是不是不止一个，则需要淘汰当前线程<h4 id="以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。"><a href="#以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。" class="headerlink" title="以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。"></a>以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。</h4></li>
</ul>
<h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><h4 id="一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况"><a href="#一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况" class="headerlink" title="一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况"></a>一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><h4 id="可以看做是一个FixedThreadPool的变种，只是线程数目给定为1"><a href="#可以看做是一个FixedThreadPool的变种，只是线程数目给定为1" class="headerlink" title="可以看做是一个FixedThreadPool的变种，只是线程数目给定为1"></a>可以看做是一个FixedThreadPool的变种，只是线程数目给定为1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/-wyl/p/9760670.html" target="_blank" rel="noopener">线程池五种状态转化的解释</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/锁膨胀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/锁膨胀/" class="post-title-link" itemprop="url">锁膨胀</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:41:08" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h1><h4 id="每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息"><a href="#每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息" class="headerlink" title="每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息"></a>每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息</h4><p><img src="img/class-head.png" alt="对象头"></p>
<h2 id="锁的膨胀过程"><a href="#锁的膨胀过程" class="headerlink" title="锁的膨胀过程"></a>锁的膨胀过程</h2><h3 id="无锁-–-gt-偏向锁"><a href="#无锁-–-gt-偏向锁" class="headerlink" title="无锁 –&gt; 偏向锁"></a>无锁 –&gt; 偏向锁</h3><h4 id="所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。"><a href="#所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。" class="headerlink" title="所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。"></a>所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。</h4><h3 id="偏向锁-–-gt-轻量锁"><a href="#偏向锁-–-gt-轻量锁" class="headerlink" title="偏向锁 –&gt; 轻量锁"></a>偏向锁 –&gt; 轻量锁</h3><h4 id="偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。"><a href="#偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。" class="headerlink" title="偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。"></a>偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。</h4><h3 id="轻量锁-–-gt-重量锁"><a href="#轻量锁-–-gt-重量锁" class="headerlink" title="轻量锁 –&gt; 重量锁"></a>轻量锁 –&gt; 重量锁</h3><h4 id="轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。-但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。"><a href="#轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。-但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。" class="headerlink" title="轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。"></a>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</h4><p><img src="img/lock-expand.jpg" alt="锁的膨胀全过程"><br><a href="https://my.oschina.net/hosee/blog/2878328" target="_blank" rel="noopener">引用原文</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/G1回收器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/10/G1回收器/" class="post-title-link" itemprop="url">G1回收器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-10 12:40:25" itemprop="dateCreated datePublished" datetime="2019-04-10T12:40:25+08:00">2019-04-10</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 16:29:39" itemprop="dateModified" datetime="2019-07-09T16:29:39+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h1><p>CSet：一系列分区的集合，也是在垃圾收集过程中被回收的目标</p>
<p>年轻代收集（young gc）：CSet里全部都是年轻代分区的收集</p>
<p>混合收集（mixed gc）：CSet里包括年轻代分区和一部分老年代分区的收集</p>
<p>-XX:InitiatingHeapOccupancyPercent：在G1中，IHOP的值是老年代空间占Java堆总空间的比例<br>-XX:G1MixedGCCountTarget：一个混合收集周期中包含多少次混合收集<br>-XX:G1HeapWastePercent：堆浪费百分比，当G1发现可被回收的空间小于5%时，就不会再进行混合收集，也就是会结束当前的混合收集周期</p>
<p>常规的垃圾收集器（串行，并行，CMS）都将堆结构分为三个部分：年轻代，老年代和固定大小的永久代。</p>
<p>G1整个颠覆了之前的的新生代和老年代的紧凑分布，将内存分为了不同的区</p>
<p>被G1标识成熟的区域是通过转移的方式收集。G1将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中，同时压缩和释放内存。这种转移方法在并行运行在多处理器上，以减少暂停时间并提高吞吐量</p>
<p>CMS垃圾收集器不执行内存压缩，ParallelOld垃圾收集器执行全堆压缩，这将导致很大的暂停时间。</p>
<p>Remembered Sets (RSets)跟踪对象引用到给定的区域。堆中每个区域有一个RSet。 RSet使GC能并行和独立地收集一个区域。 RSets的整体性能影响小于5％<br>Collection Sets (CSets)是GC中将要被收集的一组区域。GC中的所有存活数据在GC期间转移（复制/移动）。这些集合可能是eden区，survivor区或者老年代，CSets对JVM的大小影响不到1％。</p>
<p>G1的推荐用例<br>G1的第一个重要特点是为用户的应用程序的提供一个低GC延时和大内存GC的解决方案。这意味着堆大小6GB或更大，稳定和可预测的暂停时间将低于0.5秒。</p>
<p>如果应用程序使用CMS或ParallelOld垃圾回收器具有一个或多个以下特征，将有利于切换到G1：</p>
<p>Full GC持续时间太长或太频繁<br>对象分配率或年轻代升级老年代很频繁<br>不期望的很长的垃圾收集时间或压缩暂停（超过0.5至1秒）</p>
<p>存活对象从Eden区和一个survivor区拷贝到另一个survivor区，任何一个“年龄”达到阈值的对象会被晋升到老年代。</p>
<p>主要困惑点： 何时并发何时并行何时stw，和cms的区别，Rset Cset CardTable重点怎么用着三个</p>
<blockquote>
<p>CMS和G1算法都涉及对可达对象的并发标记。并发标记的主要问题是collector在标记对象的过程中mutator可能正在改变对象引用关系图，从而造成漏标和错标。错标不会影响程序的正确性，只是造成所谓的浮动垃圾。但漏标则会导致可达对象被当做垃圾收集掉，从而影响程序的正确性。<br>为解决漏标问题，GC Handbook一书首先将对象分为三类，即所谓的black对象，grey对象和white对象。white对象是那些还没有被collector标记到的对象；grey对象是那些自身已经被标记到，但其所有引用字段还没有处理的对象；而black对象则是自身已经被标记到，且其引用的所有对象也已经被标记的对象。 </p>
</blockquote>
<p>基于上述分类，一个white对象在并发标记阶段会被漏标的充分必要条件是：<br>1、mutator插入了一个从black对象到该white对象的新引用<br>2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。<br>因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 </p>
<p>Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。<br>SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。 </p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><h4 id="一种标记的算法，黑灰白"><a href="#一种标记的算法，黑灰白" class="headerlink" title="一种标记的算法，黑灰白"></a>一种标记的算法，黑灰白</h4><h4 id="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"><a href="#G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。" class="headerlink" title="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"></a>G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。</h4><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p>
<p>在插入的时候记录对象<br>在删除的时候记录对象<br>刚好这对应CMS和G1的2种不同实现方式：<br>刚好这对应CMS和G1的2种不同实现方式：</p>
<p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p>
<p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p>
<p>1，在开始标记的时候生成一个快照图标记存活对象</p>
<p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p>
<p>3，可能存在游离的垃圾，将在下次被收集<br></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/JVM的各个分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/08/JVM的各个分区/" class="post-title-link" itemprop="url">JVM的各个分区</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-08 19:59:25" itemprop="dateCreated datePublished" datetime="2019-03-08T19:59:25+08:00">2019-03-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 10:34:53" itemprop="dateModified" datetime="2019-07-09T10:34:53+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM的各个分区"><a href="#JVM的各个分区" class="headerlink" title="JVM的各个分区"></a>JVM的各个分区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> 现在直接概括一下JVM中到底有哪些分区</p>
<ul>
<li>堆 (线程共享) (GC的主要发生区)</li>
<li>栈 (细分为虚拟机栈和本地方法栈) (线程独占) </li>
<li>方法区 (non-heap) (线程共享) (内部还包含了一个运行时常量区)</li>
<li>程序计数器 (线程独占)</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。<br> 堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8:1:1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配</p>
<ul>
<li><p>-Xmx 堆的最大内存</p>
</li>
<li><p>-Xms 堆的最小内存</p>
<p>可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM<br>因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。<br>有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。<br>采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了<br>以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS+重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。</p>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p> 栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。<br> 那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？<br> 其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p> 程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p> 方法区在jdk 1.7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String.intern()方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = new StringBuilder(&quot;ab&quot;).append(&quot;cd&quot;).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">    String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个小例子在jdk1.7的版本下运行会返回true，false。但是在jdk1.6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下《深入理解java虚拟机》一书的2.4.3小节</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/Volatile修饰符的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/08/Volatile修饰符的实现/" class="post-title-link" itemprop="url">Volatile修饰符的实现</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-08 15:39:25" itemprop="dateCreated datePublished" datetime="2019-03-08T15:39:25+08:00">2019-03-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-10 00:56:41" itemprop="dateModified" datetime="2019-07-10T00:56:41+08:00">2019-07-10</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。"><a href="#本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。" class="headerlink" title="本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。"></a>本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。"><a href="#开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。" class="headerlink" title="开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。"></a>开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。</h4><h4 id="探究这个原因，用最简单的一句话去解释一下就是-为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。"><a href="#探究这个原因，用最简单的一句话去解释一下就是-为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。" class="headerlink" title="探究这个原因，用最简单的一句话去解释一下就是:为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。"></a>探究这个原因，用最简单的一句话去解释一下就是:为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。</h4><h4 id="因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1-L2-L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。"><a href="#因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1-L2-L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。" class="headerlink" title="因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1,L2,L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。"></a>因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1,L2,L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。</h4><p><img src="/Users/sugu/Desktop/cache.png" alt="# 三级缓存"></p>
<ul>
<li>缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：</li>
<li>L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。</li>
<li>L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li>
</ul>
<h4 id="从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。"><a href="#从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。" class="headerlink" title="从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。"></a>从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。</h4><h4 id="最简单的例子就是"><a href="#最简单的例子就是" class="headerlink" title="最简单的例子就是"></a>最简单的例子就是</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=i+1</span><br></pre></td></tr></table></figure>

<h4 id="假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2-但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1"><a href="#假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2-但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1" class="headerlink" title="假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2.但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1."></a>假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2.但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1.</h4><h4 id="对于这个问题，有两种方式可以解决"><a href="#对于这个问题，有两种方式可以解决" class="headerlink" title="对于这个问题，有两种方式可以解决"></a>对于这个问题，有两种方式可以解决</h4><ul>
<li><p>总线加锁<br>  对内存总线进行加锁，例如当线程1从共享区域中取了x变量之后，对总线进行加锁。即所有线程此时都不能再访问共享变量，只有线程1对x变量处理之后，写回共享内存之后然后解锁之后，其他线程才能继续记性解锁。</p>
</li>
<li><p>缓存一致性协议，MESI协议<br>  MESI是intel公司提出的一种缓存一致性协议，即对缓存中的变量分配4中不同的状态</p>
<pre><code>- M: modify， 即当前cpu对应的缓存的变量在其他核中已被修改
- E: exclusive， 即变量只在当前核中被缓存过
- S: shared， 即当前缓存的变量在其他cpu中也被缓存过
- I: invalid， 缓存的变量已失效</code></pre></li>
</ul>
<h4 id="第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况"><a href="#第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况" class="headerlink" title="第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况"></a>第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况</h4><h4 id="讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题"><a href="#讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题" class="headerlink" title="讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题"></a>讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题</h4><ul>
<li><p>原子性:<br>  一个操作必须要么全部完成，要么不完成。不会出现完成一半的情况</p>
</li>
<li><p>可见性:<br>  在一个线程中做的修改，能立刻被其他线程感知</p>
</li>
<li><p>重排序:<br>  当我们写程序的时候，几行代码不一定都按照我们写的顺序执行。编译器可能会对代码进行看似乱序的执行顺序。但是这个乱序必须保证和单线程执行结果一样。下面用个例子解释一下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              //语句1  </span><br><span class="line">boolean flag = false;	//语句2  </span><br><span class="line">i = 1;                //语句3  </span><br><span class="line">flag = true;          //语句4</span><br></pre></td></tr></table></figure>

<p>  上面的代码不一定完全按照1-2-3-4这样的顺序执行，可能会是2-1-4-3。这就是重排序。但是3永远不会在1之前执行，同理4不会在2之前执行。这就是保证有关联的语句之间的顺序不会被打破，保证若是单线程执行条件下，结果都会一样。但是多线程情况就会出现问题</p>
</li>
</ul>
<h3 id="我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java-Memory-Model-JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。"><a href="#我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java-Memory-Model-JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。" class="headerlink" title="我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。"></a>我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。</h3><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h5 id="好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质"><a href="#好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质" class="headerlink" title="好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质"></a>好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质</h5><ul>
<li>被Volatile修饰的变量都会保证强可见性</li>
<li>被Volatile修饰的变量都会禁止重排序</li>
</ul>
<h4 id="以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用"><a href="#以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用" class="headerlink" title="以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用"></a>以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用</h4><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性"><a href="#由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性" class="headerlink" title="由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性"></a>由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性</h4><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h4 id="Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子"><a href="#Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子" class="headerlink" title="Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子"></a>Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>

<h4 id="这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的"><a href="#这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的" class="headerlink" title="这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的"></a>这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的</h4><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="Volatile修饰的变量其实是不保证原子性的。同样看个例子"><a href="#Volatile修饰的变量其实是不保证原子性的。同样看个例子" class="headerlink" title="Volatile修饰的变量其实是不保证原子性的。同样看个例子"></a>Volatile修饰的变量其实是不保证原子性的。同样看个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/谈谈GC问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/谈谈GC问题/" class="post-title-link" itemprop="url">谈谈java的GC问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-01 13:59:25" itemprop="dateCreated datePublished" datetime="2019-03-01T13:59:25+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 11:20:53" itemprop="dateModified" datetime="2019-07-09T11:20:53+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈GC问题"><a href="#谈谈GC问题" class="headerlink" title="谈谈GC问题"></a>谈谈GC问题</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>上一章中，我们已经看了JVM中的内存分布。也提到了堆是GC发生的主要位置，方法区也会存在GC的可能性，但是回收效率很低。那么本章我们要看看到底GC的时候，虚拟机中发生了什么事。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> 开始讲GC之前，我想先说说。GC到底是什么？GC就是Garbage Collect的意思，就是定期回收在内存中已经再也不会被用到的内存块，可以再分配给其他对象使用的过程。从我上一句对粗略的GC的定义中，可以发现有几个重要的概念</p>
<ul>
<li>怎么判断哪些内存块是不会再被用到的</li>
<li>什么时候去回收这部分内存</li>
<li>怎么回收呢<br>好的，带着这几个问题，我们正式去了解一下GC。</li>
</ul>
<h2 id="怎么判断内存是否该回收"><a href="#怎么判断内存是否该回收" class="headerlink" title="怎么判断内存是否该回收"></a>怎么判断内存是否该回收</h2><p> 首先我们看到第一个问题。在我们平时编码的过程中，会经常的去new一个个对象，这样就会在堆中划分一块块内存供各个对象使用。那么我们怎么去判断哪些对象是之后再也用不到的呢？</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p> 这是一种很容易想到的策略方法。就是用一个计数器，计算着每个对象是不是有被调用的地方，有一个调用，计数器+1，调用失效后就计数器-1.这样，每个计数器指数为0的对象都是再也不会用到的。这个方法非常直观，的确也有很多程序语言是使用这种方式来判断无效的对象，例如python。但是这个方法有一个很致命的缺点就是他无法回收相互引用的两个对象。因为这个缺陷，所以java并没有采取这种方式</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p> 这种方式是java目前采取的</p>
<h1 id="TODO-可达性图"><a href="#TODO-可达性图" class="headerlink" title="TODO 可达性图"></a>TODO 可达性图</h1><p> 从图中可以看到，java采用的这个方法需要先确定一些GC ROOT的变量，用这些作为起点去分析可以引用到对象，这些引用组成了引用链，不可以被引用链到达的对象就是被标记为不可达的。讲到引用这边提一句引用的几种分类</p>
<ul>
<li><p>强引用<br>  类似</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	这种赋值语句带来的引用叫做强引用。这是最高等级的引用方式，只要对象存在这种强引用，就不会被GC回收</span><br><span class="line">	</span><br><span class="line">- 软引用</span><br><span class="line">	仅次于强引用的引用类型。 </span><br><span class="line">	```SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>  存在软引用的对象在堆内存第一次满引发的GC时不会被回收。但是若第一次GC后，堆内内存仍过大，就会进行第二次GC，将存在软引用的对象也进行回收。</p>
</li>
<li><p>弱引用<br>  比软引用更弱等级的引用类型</p>
  <figure class="highlight plain"><figcaption><span>sr </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	弱引用在GC时都会被回收，并不想软引用那样有存活一次的机会</span><br><span class="line">	</span><br><span class="line">- 虚引用</span><br><span class="line">    ```ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference (object, queue);</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Swaggy Q</p>
              <div class="site-description motion-element" itemprop="description">拉塞尔FMVP了吗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Swaggy Q</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
