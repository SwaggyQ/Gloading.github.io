<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拉塞尔FMVP了吗">
<meta name="keywords" content="Dloading...">
<meta property="og:type" content="website">
<meta property="og:title" content="Dloading...">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Dloading...">
<meta property="og:description" content="拉塞尔FMVP了吗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dloading...">
<meta name="twitter:description" content="拉塞尔FMVP了吗">





  
  
  <link rel="canonical" href="http://yoursite.com/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dloading...</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dloading...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">努力成为优秀程序员</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/批量再偏向机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/批量再偏向机制/" class="post-title-link" itemprop="url">偏向锁的批量再偏向机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:09:25" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="批量再偏向机制"><a href="#批量再偏向机制" class="headerlink" title="批量再偏向机制"></a>批量再偏向机制</h1><p>该机制的主要工作原理如下：</p>
<p>引入一个概念 epoch, 其本质是一个时间戳 ， 代表了偏向锁的有效性<br>从前文描述的对象头结构中可以看到， epoch 存储在可偏向对象的 MarkWord 中。<br>除了对象中的 epoch, 对象所属的类 class 信息中， 也会保存一个 epoch 值</p>
<p>每当遇到一个全局安全点时， 如果要对 class C 进行批量再偏向， 则首先对 class C 中保存的 epoch 进行增加操作， 得到一个新的 epoch_new</p>
<p>然后扫描所有持有 class C 实例的线程栈， 根据线程栈的信息判断出该线程是否锁定了该对象， 仅将 epoch_new 的值赋给被锁定的对象中。</p>
<p>退出安全点后， 当有线程需要尝试获取偏向锁时， 直接检查 class C 中存储的 epoch 值是否与目标对象中存储的 epoch 值相等， 如果不相等， 则说明该对象的偏向锁已经失效了， 可以直接通过 CAS 操作尝试再次将该对象再次偏向于请求获得锁的线程。</p>
<p>直接看到jvm源码里，做个记录</p>
<p>1: 得到当前的系统时间<br>2: 对kclass的对象头中设置当前时间<br>3: 如果需要批量再偏向<br>    3.1 如果klass的对象头中有偏向记录</p>
<p>查看jvm源码的monitorenter<br>先查看当前线程的</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/线程池/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/线程池/" class="post-title-link" itemprop="url">线程池源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-10 10:10:05" itemprop="dateModified" datetime="2019-07-10T10:10:05+08:00">2019-07-10</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释"><a href="#本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释" class="headerlink" title="本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释"></a>本文将对java中的线程池机制做一个详细的解读，包括java内部提供的各种线程池类型的解释</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况"><a href="#在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况" class="headerlink" title="在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况"></a>在开始对其中的方法进行解释前，我们先预热一下。先看到在线程池中的几种状态，以及几种状态之间转化的一些情况</h4><p><img src="img/threadPoolStatus.jpg" alt="线程池的状态转换"></p>
<pre><code> * RUNNING -&gt; SHUTDOWN
*    On invocation of shutdown(), perhaps implicitly in finalize()
* (RUNNING or SHUTDOWN) -&gt; STOP
*    On invocation of shutdownNow()
* SHUTDOWN -&gt; TIDYING
*    When both queue and pool are empty
* STOP -&gt; TIDYING
*    When pool is empty
* TIDYING -&gt; TERMINATED
*    When the terminated() hook method has completed
*</code></pre><h4 id="另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。"><a href="#另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。" class="headerlink" title="另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。"></a>另外注意到，在线程池ThreadPoolExecute类中，有一个非常重要的变量，是一个AtomicInteger类型的魔数。之后所有的操作都离不开这个参数。他的前三位代表线程池状态，后29位代表线程数。</h4><h4 id="好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的"><a href="#好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的" class="headerlink" title="好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的."></a>好了，讲完上面想说的一些细节之后，我们直接看到execute方法，这个方法也是我们平时最会用到的.</h4><h2 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int c = ctl.get();</span><br><span class="line">   if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">       if (addWorker(command, true))</span><br><span class="line">           return;</span><br><span class="line">       c = ctl.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。"><a href="#先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。" class="headerlink" title="先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。"></a>先是得到类中的魔数，用于计算目前在线程池中的工作节点数目。在魔数的后二十九位用于计算线程数。如果目前工作节点的数目小于设定的corePoolSize，则可以继续添加worker。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">	retry:</span><br><span class="line">	for (;;) &#123;</span><br><span class="line">	    int c = ctl.get();</span><br><span class="line">	    // 得到线程池目前的状态</span><br><span class="line">	    int rs = runStateOf(c);</span><br><span class="line">	</span><br><span class="line">	    // Check if queue empty only if necessary.</span><br><span class="line">	    // 如果当前线程池状态是SHUTDOWN或者以上</span><br><span class="line">	    // 除非是状态为SHUTDOWN，且新增的是非core，且队列不为空  (可以理解为，还不是TIDYING状态)</span><br><span class="line">	    // 否则应该直接添加失败</span><br><span class="line">	    // 这句话可以这样理解，当线程池的状态已经最起码是SHUTDOWN了，那么按理说，是不应该继续添加工作线程的，除非是因为状态是SHUTDOWN，虽然不再接收新的任务，但是还需要将旧的任务执行完，那么此时可能会加入一些临时工性质的非core线程，标识就是firstTask为null</span><br><span class="line">	    if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">	        ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">	           firstTask == null &amp;&amp;</span><br><span class="line">	           ! workQueue.isEmpty()))</span><br><span class="line">	        // 如果满足以上条件，则添加失败</span><br><span class="line">	        return false;</span><br><span class="line">	</span><br><span class="line">	    for (;;) &#123;</span><br><span class="line">	    	// 再次得到目前的节点数</span><br><span class="line">	        int wc = workerCountOf(c);</span><br><span class="line">	        // 如果已经大于了最大数量，或者大于设定的参数</span><br><span class="line">	        if (wc &gt;= CAPACITY ||</span><br><span class="line">	            wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">	            return false;</span><br><span class="line">	        // 将线程数+1</span><br><span class="line">	        if (compareAndIncrementWorkerCount(c))</span><br><span class="line">	            break retry;</span><br><span class="line">	        c = ctl.get();  // Re-read ctl</span><br><span class="line">	        // 若线程状态已经改变，则需要执行外部的大循环，否则执行内部的循环</span><br><span class="line">	        if (runStateOf(c) != rs)</span><br><span class="line">	            continue retry;</span><br><span class="line">	        // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目-1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码"><a href="#注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目-1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码" class="headerlink" title="注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目+1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码"></a>注意这个addWorker方法的入参中的firstTask，代表新建的工作节点需要第一个执行的任务。在不同的调用中有不同的内容，是可以为null的，即代表添加的非core线程。以上的代码主要将线程池中的线程状态进行了更新，并将数目+1，如果CAS自增的时候，失败了则会开始重试，如果在CAS的过程中线程池状态已经发生了改变，则需要重新check一下。再看到下面的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 标识是否启动成功</span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">// 标识是否添加成功</span><br><span class="line">   boolean workerAdded = false;</span><br><span class="line">   Worker w = null;</span><br><span class="line">   try &#123;</span><br><span class="line">   	// 构建worker，包含thread和runnable两个属性</span><br><span class="line">       w = new Worker(firstTask);</span><br><span class="line">       final Thread t = w.thread;</span><br><span class="line">       if (t != null) &#123;</span><br><span class="line">           final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">           mainLock.lock();</span><br><span class="line">           try &#123;</span><br><span class="line">               // Recheck while holding lock.</span><br><span class="line">               // Back out on ThreadFactory failure or if</span><br><span class="line">               // shut down before lock acquired.</span><br><span class="line">               int rs = runStateOf(ctl.get());</span><br><span class="line">               // 如果目前状态是RUNNING，或者是SHUTDOWN但是添加的是非core</span><br><span class="line">               if (rs &lt; SHUTDOWN ||</span><br><span class="line">                   (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                   if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                       throw new IllegalThreadStateException();</span><br><span class="line">                   workers.add(w);</span><br><span class="line">                   int s = workers.size();</span><br><span class="line">                   if (s &gt; largestPoolSize)</span><br><span class="line">                       largestPoolSize = s;</span><br><span class="line">                   workerAdded = true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               mainLock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">           if (workerAdded) &#123;</span><br><span class="line">           	// 若添加成功，则启动对应的线程</span><br><span class="line">               t.start();</span><br><span class="line">               workerStarted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">       if (! workerStarted)</span><br><span class="line">           addWorkerFailed(w);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况"><a href="#以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况" class="headerlink" title="以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况"></a>以上的逻辑也是比较简单，也不细说了，看到最后一句，若工作节点未启动，则需要处理失败的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void addWorkerFailed(Worker w) &#123;</span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">    	// 若之前已经在set中记录了worker，则需要移除</span><br><span class="line">        if (w != null)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        // 永真循环的减小工作节点数</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看"><a href="#大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看" class="headerlink" title="大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看"></a>大部分逻辑还是可以预见的，就是减少数量，从work的set中移除。但是要看到最后一个方法，tryTerminate，不知道这个方法里面做了什么。重点看看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 如果线程池的状态是STOP或者Terminal，并且workQueue为空</span><br><span class="line">// 则原子性的将线程池的状态改为Terminate，</span><br><span class="line">final void tryTerminate() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        // 若状态还是RUNNING或者为 TIDYING或者TERMINATED</span><br><span class="line">        // 或者是SHUTDOWN但是任务队列不为空</span><br><span class="line">        // 则可以直接退出当前方法</span><br><span class="line">        // 所以可以得到，只有当前线程池状态是SHUTDOWN且任务队列为空，或者状态为Stop的时候，才会继续</span><br><span class="line">        if (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            return;</span><br><span class="line">        if (workerCountOf(c) != 0) &#123; // Eligible to terminate</span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">		// 若此时线程池中的线程已经为0，则可以调用terminated方法</span><br><span class="line">        final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, 0));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        // else retry on failed CAS</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑"><a href="#再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑" class="headerlink" title="再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑"></a>再回到原来的execute方法中，如果上一步的addWorker方法成功，则直接返回，但是如果添加失败。则需要继续下面的逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果此时线程池的运行状态是正常的，但是上一步添加worker失败。则需要将传入的Runnable参数放入阻塞队列中</span><br><span class="line">if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">    int recheck = ctl.get();</span><br><span class="line">    // 再重复检查一遍，若线程池不在运行，则需要移除任务，并用拒绝策略执行相应的方法</span><br><span class="line">    if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">    // 如果线程池现在正在运行，但是此时的工作节点数为0，则需要直接新节点</span><br><span class="line">    else if (workerCountOf(recheck) == 0)</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">&#125;</span><br><span class="line">// 如果当前线程池不是正常运行状态，则尝试添加非核心线程</span><br><span class="line">else if (!addWorker(command, false))</span><br><span class="line">    reject(command);</span><br></pre></td></tr></table></figure>

<h4 id="现在再回到刚才的新建worker，然后启动worker中的线程的部分"><a href="#现在再回到刚才的新建worker，然后启动worker中的线程的部分" class="headerlink" title="现在再回到刚才的新建worker，然后启动worker中的线程的部分"></a>现在再回到刚才的新建worker，然后启动worker中的线程的部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-1); // inhibit interrupts until runWorker</span><br><span class="line">    this.firstTask = firstTask;</span><br><span class="line">    this.thread = getThreadFactory().newThread(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Delegates main run loop to outer runWorker  */</span><br><span class="line">public void run() &#123;</span><br><span class="line">    runWorker(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。"><a href="#可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。" class="headerlink" title="可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。"></a>可以看到，worker本来就是一个Runnable的对象，在新建thread的时候，也是包含了本身，所以启动线程的时候，其实调用的是runWorker方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">final void runWorker(Worker w) &#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    // 得到传入的firstTask，注意这个可能是nul</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = null;</span><br><span class="line">    w.unlock(); // allow interrupts</span><br><span class="line">    boolean completedAbruptly = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        while (task != null || (task = getTask()) != null)&#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            if ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            try &#123;</span><br><span class="line">            	// 预留给子类实现的方法</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; catch (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Error x) &#123;</span><br><span class="line">                    thrown = x; throw x;</span><br><span class="line">                &#125; catch (Throwable x) &#123;</span><br><span class="line">                    thrown = x; throw new Error(x);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                	// 预留给子类实现的方法</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                task = null;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = false;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。"><a href="#可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。" class="headerlink" title="可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。"></a>可以看到，在worker启动后，就会不断的通过getTask方法，从任务队列中取任务进行处理。如果没有从任务队列中得到任务，则说明当前线程池状态至少是STOP了，或者任务队列已经是空了。就会淘汰掉一些线程。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void processWorkerExit(Worker w, boolean completedAbruptly) &#123;</span><br><span class="line">	// 如果不是被中断退出的，那么在getTask方法中就已经做了这一步了</span><br><span class="line">    if (completedAbruptly) // If abrupt, then workerCount wasn&apos;t adjusted</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        // 移除当前工作节点</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // 如果当前线程池状态起码已经是STOP了</span><br><span class="line">    if (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">    	// 如果当前线程不是用户中断的，则需要判断是否需要新增工作节点</span><br><span class="line">        if (!completedAbruptly) &#123;</span><br><span class="line">            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;</span><br><span class="line">            if (min == 0 &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = 1;</span><br><span class="line">            // 如果当前线程数不够最小线程数</span><br><span class="line">            if (workerCountOf(c) &gt;= min)</span><br><span class="line">                return; // replacement not needed</span><br><span class="line">        &#125;</span><br><span class="line">        addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在再来看看getTask方法做了什么"><a href="#现在再来看看getTask方法做了什么" class="headerlink" title="现在再来看看getTask方法做了什么"></a>现在再来看看getTask方法做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private Runnable getTask() &#123;</span><br><span class="line">	// 通过一个布尔值标识重试的第二次方法是否超时</span><br><span class="line">    boolean timedOut = false; // Did the last poll() time out?</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    	// 再计算一次线程池的状态</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line">	</span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">		// 如果状态已经是SHUTDOWN且任务队列已经空或者起码是STOP</span><br><span class="line">		// 则直接返回null</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">		// 计算当前线程池中的线程数</span><br><span class="line">        int wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        // Are workers subject to culling?</span><br><span class="line">        // 工作节点是否需要被淘汰</span><br><span class="line">        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">		// 如果当前线程数已经大于最大阈值 或者 需要淘汰且上一次已经超时</span><br><span class="line">		// 而且线程数大于1，或者任务队列已经为空</span><br><span class="line">		// 则需要减少线程数，并返回null</span><br><span class="line">        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123;</span><br><span class="line">            if (compareAndDecrementWorkerCount(c))</span><br><span class="line">                return null;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">        	// 根据是否需要淘汰线程，选择是需要带超时的poll方法还是take方法</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            if (r != null)</span><br><span class="line">                return r;</span><br><span class="line">            timedOut = true;</span><br><span class="line">        &#125; catch (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="从上面的代码中我们可以提炼出一些细节点"><a href="#从上面的代码中我们可以提炼出一些细节点" class="headerlink" title="从上面的代码中我们可以提炼出一些细节点"></a>从上面的代码中我们可以提炼出一些细节点</h4><ul>
<li>可以指定allowCoreThreadTimeOut参数来确定是否需要淘汰core线程。默认是false。</li>
<li>当线程池中的线程数大于了corePoolSize，则开始考虑是否需要淘汰线程</li>
<li>当开始开始考虑线程后，会将从workQueue获取任务的方式从阻塞的take，换成用给定的传入的keepAliveTime做超时时间的poll方法</li>
<li>因为获取任务是一个不断重试的过程，所以如果第一次超时了，则会进行第二次。这时候就会判断任务队列中是不是已经空了，以及当前线程是不是不止一个，则需要淘汰当前线程<h4 id="以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。"><a href="#以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。" class="headerlink" title="以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。"></a>以上我们就简单过了一次ThreadPoolExecutor的执行一个Runnable任务的过程。之前也说过在java中，自带实现了几种线程池的类型。现在我们也看看这几个是做了什么个性化的设定。</h4></li>
</ul>
<h2 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h2><h4 id="一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况"><a href="#一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况" class="headerlink" title="一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况"></a>一个给定线程数的线程池类型，因为corePoolSize和maximumPoolSize都是给定的，所以不会出现临时线程的情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h2><h4 id="可以看做是一个FixedThreadPool的变种，只是线程数目给定为1"><a href="#可以看做是一个FixedThreadPool的变种，只是线程数目给定为1" class="headerlink" title="可以看做是一个FixedThreadPool的变种，只是线程数目给定为1"></a>可以看做是一个FixedThreadPool的变种，只是线程数目给定为1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CachedThreadPool"><a href="#CachedThreadPool" class="headerlink" title="CachedThreadPool"></a>CachedThreadPool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/-wyl/p/9760670.html" target="_blank" rel="noopener">线程池五种状态转化的解释</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/类加载器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/类加载器/" class="post-title-link" itemprop="url">类加载器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:09:55" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><blockquote>
<p>Java类加载器的作用就是在运行时加载类。Java类加载器基于三个机制：委托、可见性和单一性。</p>
<ul>
<li>委托机制是指将加载一个类的请求交给父类加载器，如果这个父类加载器不能够找到或者加载这个类，那么再加载它。</li>
<li>可见性的原理是子类的加载器可以看见所有的父类加载器加载的类，而父类加载器看不到子类加载器加载的类。</li>
<li>单一性原理是指仅加载一个类一次，这是由委托机制确保子类加载器不会再次加载父类加载器加载过的类。</li>
</ul>
</blockquote>
<h4 id="java提供了三种类加载器"><a href="#java提供了三种类加载器" class="headerlink" title="java提供了三种类加载器"></a>java提供了三种类加载器</h4><p>1) Bootstrap类加载器 – JRE/lib/rt.jar</p>
<p>2) Extension类加载器 – JRE/lib/ext或者java.ext.dirs指向的目录</p>
<p>3) Application类加载器 – CLASSPATH环境变量, 由-classpath或-cp选项定义,或者是JAR中的Manifest的classpath属性定义.</p>
<p>4）自定义类加载器 - 继承java.lang.ClassLoader的自定义类加载器</p>
<h4 id="以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托"><a href="#以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托" class="headerlink" title="以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托"></a>以上四个类加载器从上到下父子关系，每层的类加载器得到一个类加载的请求后，首先会向上一层的类加载器发送这个请求，依次一直到Bootstrap类加载器。如果上层的类加载器没有加载成功后，才会返回到这层的类加载器来加载。这就是双亲委托</h4><h4 id="采用双亲委派的一个好处是比如加载位于-rt-jar-包中的类-java-lang-Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个-Object-对象。"><a href="#采用双亲委派的一个好处是比如加载位于-rt-jar-包中的类-java-lang-Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个-Object-对象。" class="headerlink" title="采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。"></a>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象。</h4><p><img src="/Users/sugu/Documents/markdown/jdk/classLoader.jpeg" alt="类加载器"></p>
<h4 id="显式的加载类的方式"><a href="#显式的加载类的方式" class="headerlink" title="显式的加载类的方式"></a>显式的加载类的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(classname)</span><br><span class="line">Class.forName(classname, initialized, classloader)。</span><br></pre></td></tr></table></figure>

<h4 id="注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的"><a href="#注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的" class="headerlink" title="注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的"></a>注意对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。对于同一个类，如果没有采用相同的类加载器来加载，则是不相等的</h4><h4 id="基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定"><a href="#基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定" class="headerlink" title="基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定"></a>基于单一性原则，子类的类加载器可以看到父类的加载器中加载的类，所以不会被加载两次，然重写违反委托和单一性机制的类加载器可以打破这个规定</h4><blockquote>
<p>第一次：在双亲委派模型出现之前—–即JDK1.2发布之前。<br>第二次：是这个模型自身的缺陷导致的。我们说，双亲委派模型很好的解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API， 但没有绝对，如果基础类调用会用户的代码怎么办呢？<br>这不是没有可能的。一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进去的rt.jar）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在rt.jar中，但是启动类加载器又需要加载。怎么办呢？<br>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader方法进行设置。如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过多的话，那这个类加载器默认即使应用程序类加载器。<br>嘿嘿，有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。但这无可奈何，Java中所有涉及SPI的加载动作基本胜都采用这种方式。例如JNDI，JDBC，JCE，JAXB，JBI等。<br>第三次：为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/线程池详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/线程池详解/" class="post-title-link" itemprop="url">线程池详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-10 09:59:12" itemprop="dateModified" datetime="2019-07-10T09:59:12+08:00">2019-07-10</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解"><a href="#本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解" class="headerlink" title="本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解"></a>本文旨在针对ThreadPoolExecutor进行一些源码级别的解读，从而对我们平时从Executor类生成的各种不同的线程池有更深的理解</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="先看到构造方法做了什么"><a href="#先看到构造方法做了什么" class="headerlink" title="先看到构造方法做了什么"></a>先看到构造方法做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。"><a href="#先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。" class="headerlink" title="先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。"></a>先简单看到初始化了一些参数，然后放入了一个阻塞队列，一个线程制造工厂，还有一个handler。这个handler主要是作为线程调度失败后的一些操作。具体每个参数在后面都会讲到。</h4><h4 id="再看到最重要的execute方法。"><a href="#再看到最重要的execute方法。" class="headerlink" title="再看到最重要的execute方法。"></a>再看到最重要的execute方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command == null)</span><br><span class="line">        	throw new NullPointerException();</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看"><a href="#首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看" class="headerlink" title="首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看"></a>首先看到，入参是一个Runnable类型的参数，这个就是我们平时构造线程时会传入的具体执行的内容指令。然后先回对这个参数进行一下校验。再继续往下看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 线程池内部的一个AtomInteger类型的参数，可用于计算当前的线程数以及线程池的状态，具体操作内容就是通过对bit之间的操作，先不细讲</span><br><span class="line">int c = ctl.get();</span><br><span class="line">// 通过c先计算得到当前线程池的线程数，如果小于构造函数中传入的核心线程池大小的话，就会通过addWorker方法继续往线程池中添加线程</span><br><span class="line">if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">// 注意这边的第二个参数为true，代表正在添加工作节点</span><br><span class="line">    if (addWorker(command, true))</span><br><span class="line">        return;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下"><a href="#在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下" class="headerlink" title="在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下"></a>在线程池中会涉及到很多的判断条件，所以边看源码边进行记录一下</h4><ul>
<li>如果新任务进来时，线程池中的线程数小于corePoolSize，则继续向线程池中添加新的工作者，也就是新的线程</li>
</ul>
<h4 id="现在继续看看addWorker方法里面做了什么"><a href="#现在继续看看addWorker方法里面做了什么" class="headerlink" title="现在继续看看addWorker方法里面做了什么"></a>现在继续看看addWorker方法里面做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">    // 做了一次标记，用于之后跳出循环</span><br><span class="line">    retry:</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">    	// 得到这个值，用于计算当前线程池的状态，总共有5种状态</span><br><span class="line">    	// RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">		// SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">		// STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">		// TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">		// TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line">        int c = ctl.get();</span><br><span class="line">        int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        // Check if queue empty only if necessary.</span><br><span class="line">        // 如果计算得到的线程池当前的状态rs &gt; SHUTDOWN 以及以下三个条件不同时满足，则代表添加工作节点失败，否则继续执行</span><br><span class="line">        // 1: rs等于SHUTDOWN</span><br><span class="line">        // 2: 传入的Runnable参数为空</span><br><span class="line">        // 3: 工作队列不为空</span><br><span class="line">        if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == null &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            return false;</span><br><span class="line">		</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">        	// 得到当前线程池的工作线程数</span><br><span class="line">            int wc = workerCountOf(c);</span><br><span class="line">            // 如果当前线程数wc 已经大于了(1 &lt;&lt; 29) - 1</span><br><span class="line">            // 或者</span><br><span class="line">            // 根据方法的第二个参数来判断，wc是大于corePoolSize还是最大线程数，如果是大于，则也代表无法再添加新工作节点了，返回添加失败</span><br><span class="line">            if (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                return false;</span><br><span class="line">            // 用CAS的方法将变量c+1，代表多了一个线程</span><br><span class="line">            if (compareAndIncrementWorkerCount(c))</span><br><span class="line">    	// 如果线程数新增成功，也跳出永真循环</span><br><span class="line">                break retry;</span><br><span class="line">            c = ctl.get();  // Re-read ctl</span><br><span class="line">            if (runStateOf(c) != rs)</span><br><span class="line">                continue retry;</span><br><span class="line">            // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在方法中若满足条件，会用永真循环将线程数-1，成功后再看下面的操作"><a href="#在方法中若满足条件，会用永真循环将线程数-1，成功后再看下面的操作" class="headerlink" title="在方法中若满足条件，会用永真循环将线程数+1，成功后再看下面的操作"></a>在方法中若满足条件，会用永真循环将线程数+1，成功后再看下面的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 两个布尔值，判断工作节点是否加入队列中，以及是否启动</span><br><span class="line">boolean workerStarted = false;</span><br><span class="line">      boolean workerAdded = false;</span><br><span class="line">      Worker w = null;</span><br><span class="line">      try &#123;</span><br><span class="line">      	// 用Runnable参数构建工作节点，内部会通过线程工厂构建一个新的线程，所以Worker内部包括</span><br><span class="line">      	// Runnable , Thread</span><br><span class="line">          w = new Worker(firstTask);</span><br><span class="line">          // 得到对应的线程</span><br><span class="line">          final Thread t = w.thread;</span><br><span class="line">          if (t != null) &#123;</span><br><span class="line">          	// 获得可重入锁</span><br><span class="line">              final ReentrantLock mainLock = this.mainLock;</span><br><span class="line">              mainLock.lock();</span><br><span class="line">              try &#123;</span><br><span class="line">                  // Recheck while holding lock.</span><br><span class="line">                  // Back out on ThreadFactory failure or if</span><br><span class="line">                  // shut down before lock acquired.</span><br><span class="line">                  // 获得当前线程池的状态</span><br><span class="line">                  int rs = runStateOf(ctl.get());</span><br><span class="line">                  if (rs &lt; SHUTDOWN ||</span><br><span class="line">                      (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123;</span><br><span class="line">                      if (t.isAlive()) // precheck that t is startable</span><br><span class="line">                          throw new IllegalThreadStateException();</span><br><span class="line">					// 在阻塞队列中添加新任务</span><br><span class="line">                      workers.add(w);</span><br><span class="line">                      int s = workers.size();</span><br><span class="line">                      // 然后更新最大的线程池大小</span><br><span class="line">                      if (s &gt; largestPoolSize)</span><br><span class="line">                          largestPoolSize = s;</span><br><span class="line">                      workerAdded = true;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  mainLock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              // 启动线程</span><br><span class="line">              if (workerAdded) &#123;</span><br><span class="line">                  t.start();</span><br><span class="line">                  workerStarted = true;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">      	// 如果启动失败，则移除</span><br><span class="line">          if (! workerStarted)</span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">      return workerStarted;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。"><a href="#以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。" class="headerlink" title="以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。"></a>以上就是添加工作Worker的过程，现在回去看看execute方法中，addWorker成功之后做了什么操作。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    	// 如果添加成功，代表线程已经启动</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方"><a href="#重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方" class="headerlink" title="重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方"></a>重点看一下这个reject方法，这个就是线程池中的拒绝策略起作用的地方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/聊一聊HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/聊一聊HashMap/" class="post-title-link" itemprop="url">谈谈HashMap</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:09:41" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈HashMap"><a href="#谈谈HashMap" class="headerlink" title="谈谈HashMap"></a>谈谈HashMap</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk-1-8讲讲他底层是怎么实现的，并会对比jdk-1-7看看这两个版本做了什么修改"><a href="#最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk-1-8讲讲他底层是怎么实现的，并会对比jdk-1-7看看这两个版本做了什么修改" class="headerlink" title="最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk 1.8讲讲他底层是怎么实现的，并会对比jdk 1.7看看这两个版本做了什么修改"></a>最近正在复习jdk中的一些源码的细节。今天会讲讲Map接口下的HashMap。这个数据结构我们平时肯定也会经常用到，今天会基于jdk 1.8讲讲他底层是怎么实现的，并会对比jdk 1.7看看这两个版本做了什么修改</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？"><a href="#按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？" class="headerlink" title="按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？"></a>按我们平时的使用习惯，一般就是直接new一个HashMap的实例对象，供之后的操作。那这个构造函数中，HashMap初始化了什么参数呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public HashMap(int initialCapacity) &#123;</span><br><span class="line">     this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public HashMap() &#123;</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句"><a href="#总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句" class="headerlink" title="总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句"></a>总共有三个不同实现的构造函数。可以看到第1，2种可以看做是同一种实现，因为2中也是调用了1。那我们看到1中也是对传入的参数进行了一些校验，重点看最后一句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.threshold = tableSizeFor(initialCapacity);</span><br></pre></td></tr></table></figure>

<h4 id="我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。-例如传入7会得到8，传入13会返回16。-这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。"><a href="#我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。-例如传入7会得到8，传入13会返回16。-这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。" class="headerlink" title="我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。 例如传入7会得到8，传入13会返回16。 这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。"></a>我们传入了初始容量大小的值，但是构造函数中并没有对应的接收，而只是用这个变量去计算了thershold，也就是我们之后会用到的容量阈值。tableSizeFor方法的逻辑就是，得到最小的大于入参的2的幂次方。 例如传入7会得到8，传入13会返回16。 这样就做了初始化的动作。注意前两个构造函数初始化了loadFactor，和threshold，而第三个构造方法中值初始化了loadFactor一个方法。这个细节在后面也是会被用到。</h4><h4 id="既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。"><a href="#既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。" class="headerlink" title="既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。"></a>既然是HashMap，那最大的作用应该是存储我们给定的键值对。那我们现在看看他是怎么高效存储数据。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash-方法"><a href="#这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash-方法" class="headerlink" title="这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash()方法"></a>这个put方法是常用的方法。可以看到里面真正起作用的是putVal方法，但是里面还有一个hash()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">    int h;</span><br><span class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位-后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。"><a href="#这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位-后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。" class="headerlink" title="这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位 ^ 后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。"></a>这个方法是通过给定的key得到散列算法算出的hash值。这个散列方法只有一行，就是得到key的hashcode，然后前16位 ^ 后16位。当然若key是null也是可以接受的，就是直接返回0号位。这个返回的值就是之后会用到的每个key属于哪个桶位的编号。我们接下去看putVal方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">           n = (tab = resize()).length;</span><br></pre></td></tr></table></figure>

<h4 id="在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。"><a href="#在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。" class="headerlink" title="在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。"></a>在方法的一开头就先判断底层的数组是否已经初始化成功，如果还没初始化，就需要通过resize方法进行初始化。这个方法通过名字就可以看出应该还有改变大小的作用，这个作用会在方法的最后提到。这边先只关注初始化数组的作用。方法内部的初始化部分这边先不说了，核心就是这一句。new了一个Node的数组。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br></pre></td></tr></table></figure>

<h4 id="那这个Node是什么呢？这边插播一下Node的定义"><a href="#那这个Node是什么呢？这边插播一下Node的定义" class="headerlink" title="那这个Node是什么呢？这边插播一下Node的定义"></a>那这个Node是什么呢？这边插播一下Node的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    final int hash;</span><br><span class="line">    final K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        this.hash = hash;</span><br><span class="line">        this.key = key;</span><br><span class="line">        this.value = value;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组-链表的格式组成的。"><a href="#可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组-链表的格式组成的。" class="headerlink" title="可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组+链表的格式组成的。"></a>可以看到里面除了一些hash，key，vaule之外，还有一个Node类型的引用，所以可以合理推断这个Node后面会组成一个链表。所以模糊的可以确认出，HashMap的底层是数组+链表的格式组成的。</h4><h4 id="好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。"><a href="#好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。" class="headerlink" title="好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。"></a>好了，回到正题。看回原来的putVal方法。接下来的代码格式就是一个if-else的逻辑。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// (n-1) &amp; hash 计算出给定的key应该保存在数组的第几个位置中</span><br><span class="line">// 如果数组的这个位置现在还是空的，则可以直接new一个Node作为第一个占位的节点，放在给定的位置</span><br><span class="line">   if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">          tab[i] = newNode(hash, key, value, null);</span><br><span class="line">      else &#123;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。"><a href="#如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。" class="headerlink" title="如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。"></a>如果数组对应的位置已经有了元素，需要以原有的元素作为链表的头节点往后延伸。但是这里也有几种情况区分。</h4><ul>
<li><p>新加入的key已经在数组存在了，这个put操作就成为了用新数据更新旧数据的操作</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">       e = p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在数组中存在的链表中继续添加新节点。注意当链表长度大于8的时候，链表会转化为红黑树。这也是jdk 1.8中新增的功能，避免了1.7版本中链表长度过长造成的查询效率低的问题。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">		// 到达了链表的末尾，则只需要将原尾节点的后继指针指向新加入的节点</span><br><span class="line">           if ((e = p.next) == null) &#123;</span><br><span class="line">               p.next = newNode(hash, key, value, null);</span><br><span class="line">               // 当链表长度大于7的时候，就会红黑树化</span><br><span class="line">               if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                   treeifyBin(tab, hash);</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           // 若在链表中已存在key</span><br><span class="line">           if (e.hash == hash &amp;&amp;</span><br><span class="line">               ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">               break;</span><br><span class="line">           p = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 将原数组中的对应位置的链表转为红黑树</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">       int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       // 如果原有的数组的容量小于64，则直接去扩容</span><br><span class="line">       if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       // 已达到转化的阈值，则开始转换</span><br><span class="line">       else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = null, tl = null; // 树的首尾节点</span><br><span class="line">           do &#123;</span><br><span class="line">           	// 将原有的Node节点，转为TreeNode</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">               if (tl == null)</span><br><span class="line">                   hd = p;</span><br><span class="line">               else &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; while ((e = e.next) != null);</span><br><span class="line">           if ((tab[index] = hd) != null)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">       return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>在数组中的链表已经转为了红黑树</li>
</ul>
<h4 id="好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。可以看到在putVal的最后，会判断一下size是否已经超过了之前设定的阈值。若超过需要调用resize方法进行重新散列。"><a href="#好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。可以看到在putVal的最后，会判断一下size是否已经超过了之前设定的阈值。若超过需要调用resize方法进行重新散列。" class="headerlink" title="好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。可以看到在putVal的最后，会判断一下size是否已经超过了之前设定的阈值。若超过需要调用resize方法进行重新散列。"></a>好了，经过上面的操作。我们就已经成功有序的将元素放在了HashMap的底层数组中，不管是以链表的形式，还是红黑树的方式。可以看到在putVal的最后，会判断一下size是否已经超过了之前设定的阈值。若超过需要调用resize方法进行重新散列。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (++size &gt; threshold)</span><br><span class="line">           resize();</span><br></pre></td></tr></table></figure>

<h4 id="在重新散列方法中，这边就先跳过方法前面部分的一些判断方法，只需要知道若真需要扩容，则将原table的容量大小x2，就得到了新的容量大小。回想到我们之前初始化的时候，容量大小必须是2的幂次方，那么x2之后肯定也会是2的幂次方。为什么要取这个方式呢？我们可以从移动原有数组中的元素到新数组中得到答案。直接看到移动链表的部分"><a href="#在重新散列方法中，这边就先跳过方法前面部分的一些判断方法，只需要知道若真需要扩容，则将原table的容量大小x2，就得到了新的容量大小。回想到我们之前初始化的时候，容量大小必须是2的幂次方，那么x2之后肯定也会是2的幂次方。为什么要取这个方式呢？我们可以从移动原有数组中的元素到新数组中得到答案。直接看到移动链表的部分" class="headerlink" title="在重新散列方法中，这边就先跳过方法前面部分的一些判断方法，只需要知道若真需要扩容，则将原table的容量大小x2，就得到了新的容量大小。回想到我们之前初始化的时候，容量大小必须是2的幂次方，那么x2之后肯定也会是2的幂次方。为什么要取这个方式呢？我们可以从移动原有数组中的元素到新数组中得到答案。直接看到移动链表的部分"></a>在重新散列方法中，这边就先跳过方法前面部分的一些判断方法，只需要知道若真需要扩容，则将原table的容量大小x2，就得到了新的容量大小。回想到我们之前初始化的时候，容量大小必须是2的幂次方，那么x2之后肯定也会是2的幂次方。为什么要取这个方式呢？我们可以从移动原有数组中的元素到新数组中得到答案。直接看到移动链表的部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">else &#123; // preserve order</span><br><span class="line">	// 这边定义了两对首尾指针，作为之后移动的两个不同链表的首节点入口</span><br><span class="line">       Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">       Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       do &#123;</span><br><span class="line">           next = e.next;</span><br><span class="line">           // 这边看到主要判断了e.hash &amp; oldCap为0还是1</span><br><span class="line">           if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">               if (loTail == null)</span><br><span class="line">                   loHead = e;</span><br><span class="line">               else</span><br><span class="line">                   loTail.next = e;</span><br><span class="line">               loTail = e;</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">               if (hiTail == null)</span><br><span class="line">                   hiHead = e;</span><br><span class="line">               else</span><br><span class="line">                   hiTail.next = e;</span><br><span class="line">               hiTail = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; while ((e = next) != null);</span><br><span class="line">       if (loTail != null) &#123;</span><br><span class="line">           loTail.next = null;</span><br><span class="line">           newTab[j] = loHead;</span><br><span class="line">       &#125;</span><br><span class="line">       if (hiTail != null) &#123;</span><br><span class="line">           hiTail.next = null;</span><br><span class="line">           newTab[j + oldCap] = hiHead;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="看代码里可以看到主要的逻辑判断是-e-hash-amp-oldCap-这个值为0还是为1。回想一下，在putVal方法的时候，是用hash-amp-n-1-的方法来确定元素所在的桶位值，假设n现在是16，此时来了两个hash分别为为15和31的key，那么通过计算"><a href="#看代码里可以看到主要的逻辑判断是-e-hash-amp-oldCap-这个值为0还是为1。回想一下，在putVal方法的时候，是用hash-amp-n-1-的方法来确定元素所在的桶位值，假设n现在是16，此时来了两个hash分别为为15和31的key，那么通过计算" class="headerlink" title="看代码里可以看到主要的逻辑判断是  (e.hash &amp; oldCap)这个值为0还是为1。回想一下，在putVal方法的时候，是用hash &amp; (n-1)的方法来确定元素所在的桶位值，假设n现在是16，此时来了两个hash分别为为15和31的key，那么通过计算"></a>看代码里可以看到主要的逻辑判断是  (e.hash &amp; oldCap)这个值为0还是为1。回想一下，在putVal方法的时候，是用hash &amp; (n-1)的方法来确定元素所在的桶位值，假设n现在是16，此时来了两个hash分别为为15和31的key，那么通过计算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01111 &amp; 1111  = 1111   也就是 (15 &amp; (16-1)) = 15，也就是桶位值为15</span><br><span class="line">  11111 &amp; 1111  = 1111   也就是 (31 &amp; (16-1)) = 15,桶位值同样是15</span><br></pre></td></tr></table></figure>

<h4 id="通过上面的计算也可以看出，最左边的bit被忽略了，为0或者1都会被定位到同一个桶位中连接成一个链表。那么当此时容量大小扩大了两倍，那么结果就会变成"><a href="#通过上面的计算也可以看出，最左边的bit被忽略了，为0或者1都会被定位到同一个桶位中连接成一个链表。那么当此时容量大小扩大了两倍，那么结果就会变成" class="headerlink" title="通过上面的计算也可以看出，最左边的bit被忽略了，为0或者1都会被定位到同一个桶位中连接成一个链表。那么当此时容量大小扩大了两倍，那么结果就会变成"></a>通过上面的计算也可以看出，最左边的bit被忽略了，为0或者1都会被定位到同一个桶位中连接成一个链表。那么当此时容量大小扩大了两倍，那么结果就会变成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">01111 &amp; 11111  = 01111   也就是 (15 &amp; (32-1)) = 15，也就是桶位值为15</span><br><span class="line">  11111 &amp; 11111  = 11111   也就是 (31 &amp; (32-1)) = 31,桶位值变成了31</span><br></pre></td></tr></table></figure>

<h4 id="也就是最左边的bit值起到了作用，原本同一桶位的两个key可能会被分散在两个不同的桶位中，而根据最左边为0或者为1，就可以轻松的定位到新的桶位"><a href="#也就是最左边的bit值起到了作用，原本同一桶位的两个key可能会被分散在两个不同的桶位中，而根据最左边为0或者为1，就可以轻松的定位到新的桶位" class="headerlink" title="也就是最左边的bit值起到了作用，原本同一桶位的两个key可能会被分散在两个不同的桶位中，而根据最左边为0或者为1，就可以轻松的定位到新的桶位"></a>也就是最左边的bit值起到了作用，原本同一桶位的两个key可能会被分散在两个不同的桶位中，而根据最左边为0或者为1，就可以轻松的定位到新的桶位</h4><h4 id="那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法"><a href="#那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法" class="headerlink" title="那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法"></a>那现在HashMap就已经完成了他一半的实名，接下来他需要做的就是可以让我们能方便的取出我们的数据。直接看到他的get方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。"><a href="#可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。" class="headerlink" title="可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。"></a>可以看到，主要还是要得到key在底层数组中对应的Node。得到Node之后，想得到值就非常容易了。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 找到底层数组对应的桶位的第一个节点，直接查看是否满足要求，是的话可以直接返回</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            return first;</span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">        	// 若节点已经是红黑树的一部分，则用查找红黑树的方式得到想要的节点</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            // 若是链表，则可以直接按照链表来查找</span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/锁膨胀/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/锁膨胀/" class="post-title-link" itemprop="url">锁膨胀</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:41:08" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h1><h4 id="每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息"><a href="#每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息" class="headerlink" title="每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息"></a>每个对象在堆中分配的时候，都会有一个对象头。里面就包含了关于锁的信息</h4><p><img src="img/class-head.png" alt="对象头"></p>
<h2 id="锁的膨胀过程"><a href="#锁的膨胀过程" class="headerlink" title="锁的膨胀过程"></a>锁的膨胀过程</h2><h3 id="无锁-–-gt-偏向锁"><a href="#无锁-–-gt-偏向锁" class="headerlink" title="无锁 –&gt; 偏向锁"></a>无锁 –&gt; 偏向锁</h3><h4 id="所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。"><a href="#所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。" class="headerlink" title="所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。"></a>所有对象新分配的时候，都处于可偏向的状态。即对象头中的可偏向bit为0。所以当第一个线程过来竞争的时候，发现是可偏向的时候，就会CAS的方式，去将对象头的ThreadId改成自己的。在当前线程在第二次去竞争的时候，发现ThreadId已经是自己，就会免去CAS的过程，直接得到对象。</h4><h3 id="偏向锁-–-gt-轻量锁"><a href="#偏向锁-–-gt-轻量锁" class="headerlink" title="偏向锁 –&gt; 轻量锁"></a>偏向锁 –&gt; 轻量锁</h3><h4 id="偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。"><a href="#偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。" class="headerlink" title="偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。"></a>偏向锁是不会主动撤销的，所以当此时第二个线程发起竞争的时候，会发现对象头中的ThreadId不是自己，所以会先去检查该线程是否还存活，若时，则直接将偏向锁变回无锁状态，再CAS将对象头中改为新ThreadId，表示竞争到了偏向锁。但是如果旧线程还存活，则要去检查线程中的栈帧中，是否还需要需要占有偏向锁。如果需要，则需要将偏向锁升级为轻量锁。</h4><h3 id="轻量锁-–-gt-重量锁"><a href="#轻量锁-–-gt-重量锁" class="headerlink" title="轻量锁 –&gt; 重量锁"></a>轻量锁 –&gt; 重量锁</h3><h4 id="轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。-但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。"><a href="#轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。-但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。" class="headerlink" title="轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。"></a>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</h4><p><img src="img/lock-expand.jpg" alt="锁的膨胀全过程"><br><a href="https://my.oschina.net/hosee/blog/2878328" target="_blank" rel="noopener">引用原文</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/10/G1回收器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/04/10/G1回收器/" class="post-title-link" itemprop="url">G1回收器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-04-10 12:40:25" itemprop="dateCreated datePublished" datetime="2019-04-10T12:40:25+08:00">2019-04-10</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 16:29:39" itemprop="dateModified" datetime="2019-07-09T16:29:39+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h1><p>CSet：一系列分区的集合，也是在垃圾收集过程中被回收的目标</p>
<p>年轻代收集（young gc）：CSet里全部都是年轻代分区的收集</p>
<p>混合收集（mixed gc）：CSet里包括年轻代分区和一部分老年代分区的收集</p>
<p>-XX:InitiatingHeapOccupancyPercent：在G1中，IHOP的值是老年代空间占Java堆总空间的比例<br>-XX:G1MixedGCCountTarget：一个混合收集周期中包含多少次混合收集<br>-XX:G1HeapWastePercent：堆浪费百分比，当G1发现可被回收的空间小于5%时，就不会再进行混合收集，也就是会结束当前的混合收集周期</p>
<p>常规的垃圾收集器（串行，并行，CMS）都将堆结构分为三个部分：年轻代，老年代和固定大小的永久代。</p>
<p>G1整个颠覆了之前的的新生代和老年代的紧凑分布，将内存分为了不同的区</p>
<p>被G1标识成熟的区域是通过转移的方式收集。G1将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中，同时压缩和释放内存。这种转移方法在并行运行在多处理器上，以减少暂停时间并提高吞吐量</p>
<p>CMS垃圾收集器不执行内存压缩，ParallelOld垃圾收集器执行全堆压缩，这将导致很大的暂停时间。</p>
<p>Remembered Sets (RSets)跟踪对象引用到给定的区域。堆中每个区域有一个RSet。 RSet使GC能并行和独立地收集一个区域。 RSets的整体性能影响小于5％<br>Collection Sets (CSets)是GC中将要被收集的一组区域。GC中的所有存活数据在GC期间转移（复制/移动）。这些集合可能是eden区，survivor区或者老年代，CSets对JVM的大小影响不到1％。</p>
<p>G1的推荐用例<br>G1的第一个重要特点是为用户的应用程序的提供一个低GC延时和大内存GC的解决方案。这意味着堆大小6GB或更大，稳定和可预测的暂停时间将低于0.5秒。</p>
<p>如果应用程序使用CMS或ParallelOld垃圾回收器具有一个或多个以下特征，将有利于切换到G1：</p>
<p>Full GC持续时间太长或太频繁<br>对象分配率或年轻代升级老年代很频繁<br>不期望的很长的垃圾收集时间或压缩暂停（超过0.5至1秒）</p>
<p>存活对象从Eden区和一个survivor区拷贝到另一个survivor区，任何一个“年龄”达到阈值的对象会被晋升到老年代。</p>
<p>主要困惑点： 何时并发何时并行何时stw，和cms的区别，Rset Cset CardTable重点怎么用着三个</p>
<blockquote>
<p>CMS和G1算法都涉及对可达对象的并发标记。并发标记的主要问题是collector在标记对象的过程中mutator可能正在改变对象引用关系图，从而造成漏标和错标。错标不会影响程序的正确性，只是造成所谓的浮动垃圾。但漏标则会导致可达对象被当做垃圾收集掉，从而影响程序的正确性。<br>为解决漏标问题，GC Handbook一书首先将对象分为三类，即所谓的black对象，grey对象和white对象。white对象是那些还没有被collector标记到的对象；grey对象是那些自身已经被标记到，但其所有引用字段还没有处理的对象；而black对象则是自身已经被标记到，且其引用的所有对象也已经被标记的对象。 </p>
</blockquote>
<p>基于上述分类，一个white对象在并发标记阶段会被漏标的充分必要条件是：<br>1、mutator插入了一个从black对象到该white对象的新引用<br>2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。<br>因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 </p>
<p>Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。<br>SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。 </p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><h4 id="一种标记的算法，黑灰白"><a href="#一种标记的算法，黑灰白" class="headerlink" title="一种标记的算法，黑灰白"></a>一种标记的算法，黑灰白</h4><h4 id="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"><a href="#G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。" class="headerlink" title="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"></a>G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。</h4><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p>
<p>在插入的时候记录对象<br>在删除的时候记录对象<br>刚好这对应CMS和G1的2种不同实现方式：<br>刚好这对应CMS和G1的2种不同实现方式：</p>
<p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p>
<p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p>
<p>1，在开始标记的时候生成一个快照图标记存活对象</p>
<p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p>
<p>3，可能存在游离的垃圾，将在下次被收集<br></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/JVM的各个分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/08/JVM的各个分区/" class="post-title-link" itemprop="url">JVM的各个分区</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-08 19:59:25" itemprop="dateCreated datePublished" datetime="2019-03-08T19:59:25+08:00">2019-03-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 10:34:53" itemprop="dateModified" datetime="2019-07-09T10:34:53+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM的各个分区"><a href="#JVM的各个分区" class="headerlink" title="JVM的各个分区"></a>JVM的各个分区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> 现在直接概括一下JVM中到底有哪些分区</p>
<ul>
<li>堆 (线程共享) (GC的主要发生区)</li>
<li>栈 (细分为虚拟机栈和本地方法栈) (线程独占) </li>
<li>方法区 (non-heap) (线程共享) (内部还包含了一个运行时常量区)</li>
<li>程序计数器 (线程独占)</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。<br> 堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8:1:1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配</p>
<ul>
<li><p>-Xmx 堆的最大内存</p>
</li>
<li><p>-Xms 堆的最小内存</p>
<p>可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM<br>因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。<br>有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。<br>采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了<br>以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS+重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。</p>
</li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p> 栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。<br> 那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？<br> 其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p> 程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p> 方法区在jdk 1.7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String.intern()方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = new StringBuilder(&quot;ab&quot;).append(&quot;cd&quot;).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">    String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个小例子在jdk1.7的版本下运行会返回true，false。但是在jdk1.6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下《深入理解java虚拟机》一书的2.4.3小节</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/Volatile修饰符的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/08/Volatile修饰符的实现/" class="post-title-link" itemprop="url">Volatile修饰符的实现</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-08 15:39:25" itemprop="dateCreated datePublished" datetime="2019-03-08T15:39:25+08:00">2019-03-08</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-10 00:56:41" itemprop="dateModified" datetime="2019-07-10T00:56:41+08:00">2019-07-10</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。"><a href="#本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。" class="headerlink" title="本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。"></a>本文要讲讲在java编程中不断会看到的volatile修饰符。探究一下这个修饰底层做了什么，为什么能帮我们解决在并发编程的时候一些问题。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。"><a href="#开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。" class="headerlink" title="开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。"></a>开始讲Volatile这个修饰符前，我们必须先看看为什么java的设计师要设计出这么一个修饰符。</h4><h4 id="探究这个原因，用最简单的一句话去解释一下就是-为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。"><a href="#探究这个原因，用最简单的一句话去解释一下就是-为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。" class="headerlink" title="探究这个原因，用最简单的一句话去解释一下就是:为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。"></a>探究这个原因，用最简单的一句话去解释一下就是:为了解决多核多cpu的计算机背景下，对编程带来的数据不同步的问题。接下来会讲讲这句话是什么意思。</h4><h4 id="因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1-L2-L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。"><a href="#因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1-L2-L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。" class="headerlink" title="因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1,L2,L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。"></a>因为现代计算机的发展情况下，多个cpu的计算机架构组成是非常常见的。相信我们大家绝大多数都是在这样的电脑上进行编程。另外我们也可以知道，计算机去执行我们写的每段代码的时候，是交由cpu去执行每句指令的。但是每条指令所关联的数据本来都是存储于内存中的，所以cpu每次都需要去内存中去取得一份最新的数据。随着cpu执行速度的越来越快，出现了cpu和内存之间沟通的桥梁，也就是三级缓存L1,L2,L3。缓存出现后，cpu在一般情况下就不需要去和低速内存打交道，直接去高速缓存中得到我们想要的数据。出现了缓存之后，因为每个缓存的数据容量都很小，所以如何最有效的将我们最需要的数据存在缓存中也成为了我们要考虑的问题，所以类似LRU之类的缓存更新策略也开始出现。</h4><p><img src="/Users/sugu/Desktop/cache.png" alt="# 三级缓存"></p>
<ul>
<li>缓存大大缩小了高速CPU与低速内存之间的差距。以三层缓存架构为例：</li>
<li>L1 Cache最接近CPU, 容量最小（如32K、64K等）、速度最高，每个核上都有一个L1 Cache。</li>
<li>L2 Cache容量更大（如256K）、速度更低, 一般情况下，每个核上都有一个独立的L2 Cache。</li>
<li>L3 Cache最接近内存，容量最大（如12MB），速度最低，在同一个CPU插槽之间的核共享一个L3 Cache。</li>
</ul>
<h4 id="从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。"><a href="#从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。" class="headerlink" title="从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。"></a>从上面的图中我们也可以知道，在以前的单核时代的时候，可能还没问题，因为cpu也只有一个，所以所有的数据都交由同一个cpu来调配，不会出现什么问题。但是假设我们现在有4个cpu，那么每个cpu都会将L3缓存中的数据缓存在L1，L2中，那么很有可能同一个变量的值会在多个地方中存在。那么当多个cpu同时改了自己缓存区中的数据的时候，向共享的内存中写入数据的时候，就很容易发生并发问题。</h4><h4 id="最简单的例子就是"><a href="#最简单的例子就是" class="headerlink" title="最简单的例子就是"></a>最简单的例子就是</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=i+1</span><br></pre></td></tr></table></figure>

<h4 id="假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2-但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1"><a href="#假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2-但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1" class="headerlink" title="假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2.但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1."></a>假设i的初始值是0，我们有两个线程执行的这条语句。我们很自然的会想到最后的结果时2.但是事实上这个结果很有可能是1。原因按照我们上面的分析也很容易解释，当线程1和线程2同时将i的初始值刷到的线程独立的缓存内，当执行完后，一起讲值刷回了主存中，那结果就会是1.</h4><h4 id="对于这个问题，有两种方式可以解决"><a href="#对于这个问题，有两种方式可以解决" class="headerlink" title="对于这个问题，有两种方式可以解决"></a>对于这个问题，有两种方式可以解决</h4><ul>
<li><p>总线加锁<br>  对内存总线进行加锁，例如当线程1从共享区域中取了x变量之后，对总线进行加锁。即所有线程此时都不能再访问共享变量，只有线程1对x变量处理之后，写回共享内存之后然后解锁之后，其他线程才能继续记性解锁。</p>
</li>
<li><p>缓存一致性协议，MESI协议<br>  MESI是intel公司提出的一种缓存一致性协议，即对缓存中的变量分配4中不同的状态</p>
<pre><code>- M: modify， 即当前cpu对应的缓存的变量在其他核中已被修改
- E: exclusive， 即变量只在当前核中被缓存过
- S: shared， 即当前缓存的变量在其他cpu中也被缓存过
- I: invalid， 缓存的变量已失效</code></pre></li>
</ul>
<h4 id="第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况"><a href="#第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况" class="headerlink" title="第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况"></a>第一种策略明显不太符合实际需求，总线加锁会大大的拖低效率，所以一般采用第二种情况</h4><h4 id="讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题"><a href="#讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题" class="headerlink" title="讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题"></a>讲完了内存模型的简介。现在再来看看我们平时并发变成中会遇到三个主要问题</h4><ul>
<li><p>原子性:<br>  一个操作必须要么全部完成，要么不完成。不会出现完成一半的情况</p>
</li>
<li><p>可见性:<br>  在一个线程中做的修改，能立刻被其他线程感知</p>
</li>
<li><p>重排序:<br>  当我们写程序的时候，几行代码不一定都按照我们写的顺序执行。编译器可能会对代码进行看似乱序的执行顺序。但是这个乱序必须保证和单线程执行结果一样。下面用个例子解释一下</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;              //语句1  </span><br><span class="line">boolean flag = false;	//语句2  </span><br><span class="line">i = 1;                //语句3  </span><br><span class="line">flag = true;          //语句4</span><br></pre></td></tr></table></figure>

<p>  上面的代码不一定完全按照1-2-3-4这样的顺序执行，可能会是2-1-4-3。这就是重排序。但是3永远不会在1之前执行，同理4不会在2之前执行。这就是保证有关联的语句之间的顺序不会被打破，保证若是单线程执行条件下，结果都会一样。但是多线程情况就会出现问题</p>
</li>
</ul>
<h3 id="我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java-Memory-Model-JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。"><a href="#我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java-Memory-Model-JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。" class="headerlink" title="我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。"></a>我们知道，Java程序是需要运行在Java虚拟机上面的，Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。JMM中主存对应内存模型中的物理内存，每个线程的独立内存对应缓存的概念。</h3><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h5 id="好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质"><a href="#好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质" class="headerlink" title="好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质"></a>好了，上面扯了那么多，终于讲到重点。Volatile是java提供的一个修饰符。主要提供了两个性质</h5><ul>
<li>被Volatile修饰的变量都会保证强可见性</li>
<li>被Volatile修饰的变量都会禁止重排序</li>
</ul>
<h4 id="以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用"><a href="#以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用" class="headerlink" title="以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用"></a>以上两个性质，下面通过之前提过的三个性质叙述一下，Volatile实现了什么作用</h4><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h4 id="由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性"><a href="#由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性" class="headerlink" title="由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性"></a>由于被Volatile修饰的变量，若被一个线程修改，将会被强制刷新回主存，同时将其他线程缓存的变量都置失效，所以必须从主存读取最新的值，所以实现了可见性</h4><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><h4 id="Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子"><a href="#Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子" class="headerlink" title="Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子"></a>Volatile的性质规定禁止了重排序，但是这个禁止是有前提的。举个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x = 2;        //语句1</span><br><span class="line">y = 0;        //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;         //语句4</span><br><span class="line">y = -1;       //语句5</span><br></pre></td></tr></table></figure>

<h4 id="这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的"><a href="#这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的" class="headerlink" title="这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的"></a>这种情况下语句1和语句2不能重排序到语句3之后，且1，2修改的变量值必须已刷新到主存中，语句4和语句5不能重排序到语句3之前，也就是插入了一个storeread内存屏障。但是1，2和4，5的语句是可以重排序的</h4><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><h4 id="Volatile修饰的变量其实是不保证原子性的。同样看个例子"><a href="#Volatile修饰的变量其实是不保证原子性的。同样看个例子" class="headerlink" title="Volatile修饰的变量其实是不保证原子性的。同样看个例子"></a>Volatile修饰的变量其实是不保证原子性的。同样看个例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public volatile int inc = 0;</span><br><span class="line">     </span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test = new Test();</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j=0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/谈谈GC问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/谈谈GC问题/" class="post-title-link" itemprop="url">谈谈java的GC问题</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-03-01 13:59:25" itemprop="dateCreated datePublished" datetime="2019-03-01T13:59:25+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-07-09 11:20:53" itemprop="dateModified" datetime="2019-07-09T11:20:53+08:00">2019-07-09</time>
              </span>
            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈GC问题"><a href="#谈谈GC问题" class="headerlink" title="谈谈GC问题"></a>谈谈GC问题</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>上一章中，我们已经看了JVM中的内存分布。也提到了堆是GC发生的主要位置，方法区也会存在GC的可能性，但是回收效率很低。那么本章我们要看看到底GC的时候，虚拟机中发生了什么事。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> 开始讲GC之前，我想先说说。GC到底是什么？GC就是Garbage Collect的意思，就是定期回收在内存中已经再也不会被用到的内存块，可以再分配给其他对象使用的过程。从我上一句对粗略的GC的定义中，可以发现有几个重要的概念</p>
<ul>
<li>怎么判断哪些内存块是不会再被用到的</li>
<li>什么时候去回收这部分内存</li>
<li>怎么回收呢<br>好的，带着这几个问题，我们正式去了解一下GC。</li>
</ul>
<h2 id="怎么判断内存是否该回收"><a href="#怎么判断内存是否该回收" class="headerlink" title="怎么判断内存是否该回收"></a>怎么判断内存是否该回收</h2><p> 首先我们看到第一个问题。在我们平时编码的过程中，会经常的去new一个个对象，这样就会在堆中划分一块块内存供各个对象使用。那么我们怎么去判断哪些对象是之后再也用不到的呢？</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p> 这是一种很容易想到的策略方法。就是用一个计数器，计算着每个对象是不是有被调用的地方，有一个调用，计数器+1，调用失效后就计数器-1.这样，每个计数器指数为0的对象都是再也不会用到的。这个方法非常直观，的确也有很多程序语言是使用这种方式来判断无效的对象，例如python。但是这个方法有一个很致命的缺点就是他无法回收相互引用的两个对象。因为这个缺陷，所以java并没有采取这种方式</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p> 这种方式是java目前采取的</p>
<h1 id="TODO-可达性图"><a href="#TODO-可达性图" class="headerlink" title="TODO 可达性图"></a>TODO 可达性图</h1><p> 从图中可以看到，java采用的这个方法需要先确定一些GC ROOT的变量，用这些作为起点去分析可以引用到对象，这些引用组成了引用链，不可以被引用链到达的对象就是被标记为不可达的。讲到引用这边提一句引用的几种分类</p>
<ul>
<li><p>强引用<br>  类似</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	这种赋值语句带来的引用叫做强引用。这是最高等级的引用方式，只要对象存在这种强引用，就不会被GC回收</span><br><span class="line">	</span><br><span class="line">- 软引用</span><br><span class="line">	仅次于强引用的引用类型。 </span><br><span class="line">	```SoftReference&lt;String&gt; sr = new SoftReference&lt;String&gt;(new String(&quot;hello&quot;));</span><br></pre></td></tr></table></figure>

<p>  存在软引用的对象在堆内存第一次满引发的GC时不会被回收。但是若第一次GC后，堆内内存仍过大，就会进行第二次GC，将存在软引用的对象也进行回收。</p>
</li>
<li><p>弱引用<br>  比软引用更弱等级的引用类型</p>
  <figure class="highlight plain"><figcaption><span>sr </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	弱引用在GC时都会被回收，并不想软引用那样有存活一次的机会</span><br><span class="line">	</span><br><span class="line">- 虚引用</span><br><span class="line">    ```ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference (object, queue);</span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Swaggy Q</p>
              <div class="site-description motion-element" itemprop="description">拉塞尔FMVP了吗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Swaggy Q</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
