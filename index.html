<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拉塞尔FMVP了吗">
<meta name="keywords" content="Dloading...">
<meta property="og:type" content="website">
<meta property="og:title" content="Dloading...">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dloading...">
<meta property="og:description" content="拉塞尔FMVP了吗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dloading...">
<meta name="twitter:description" content="拉塞尔FMVP了吗">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dloading...</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dloading...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">努力成为优秀程序员</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/java的自动装箱和自动拆箱/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/java的自动装箱和自动拆箱/" class="post-title-link" itemprop="url">java的自动装箱和自动拆箱</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:05:33" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java的自动装箱和自动拆箱"><a href="#java的自动装箱和自动拆箱" class="headerlink" title="java的自动装箱和自动拆箱"></a>java的自动装箱和自动拆箱</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="今天看到一个很有意思的事情，也就是关于在java中的基础类型的自动装箱和自动拆箱的事情。之前可能就是一直在用，但是也不知道为什么可以这样。例如，下面一个最简单的例子"><a href="#今天看到一个很有意思的事情，也就是关于在java中的基础类型的自动装箱和自动拆箱的事情。之前可能就是一直在用，但是也不知道为什么可以这样。例如，下面一个最简单的例子" class="headerlink" title="今天看到一个很有意思的事情，也就是关于在java中的基础类型的自动装箱和自动拆箱的事情。之前可能就是一直在用，但是也不知道为什么可以这样。例如，下面一个最简单的例子"></a>今天看到一个很有意思的事情，也就是关于在java中的基础类型的自动装箱和自动拆箱的事情。之前可能就是一直在用，但是也不知道为什么可以这样。例如，下面一个最简单的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Integer a = 10;</span><br><span class="line">       int b = a;</span><br><span class="line">       System.out.println(a);</span><br><span class="line">       System.out.println(b);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="平时可能非常理所当然的就这么用了。但是如果问你，这个为什么可以这样子呢？或者给你出这么一道题目"><a href="#平时可能非常理所当然的就这么用了。但是如果问你，这个为什么可以这样子呢？或者给你出这么一道题目" class="headerlink" title="平时可能非常理所当然的就这么用了。但是如果问你，这个为什么可以这样子呢？或者给你出这么一道题目"></a>平时可能非常理所当然的就这么用了。但是如果问你，这个为什么可以这样子呢？或者给你出这么一道题目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       Integer x1 = 10;</span><br><span class="line">       Integer x2 = 10;</span><br><span class="line">       Integer x3 = 200;</span><br><span class="line">       Integer x4 = 200;</span><br><span class="line">       System.out.println(x1 == x2); </span><br><span class="line">       System.out.println(x3 == x4);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这两个的返回值按照常理来说都是一样的情况，应该要么都是false或者都是true。但是不是的，返回值第一个是true，第二个是false。"><a href="#这两个的返回值按照常理来说都是一样的情况，应该要么都是false或者都是true。但是不是的，返回值第一个是true，第二个是false。" class="headerlink" title="这两个的返回值按照常理来说都是一样的情况，应该要么都是false或者都是true。但是不是的，返回值第一个是true，第二个是false。"></a>这两个的返回值按照常理来说都是一样的情况，应该要么都是false或者都是true。但是不是的，返回值第一个是true，第二个是false。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ArrayBlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ArrayBlockingQueue/" class="post-title-link" itemprop="url">ArrayBlockQueue源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:05:17" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文讲一下ArrayBlockingQueue-下文简称ABQ-的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。"><a href="#本文讲一下ArrayBlockingQueue-下文简称ABQ-的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。" class="headerlink" title="本文讲一下ArrayBlockingQueue(下文简称ABQ)的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。"></a>本文讲一下ArrayBlockingQueue(下文简称ABQ)的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。</h4><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><h4 id="照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue-int-boolean-方法。其他两个都是之后调用这个方法。所以直接看看这个方法"><a href="#照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue-int-boolean-方法。其他两个都是之后调用这个方法。所以直接看看这个方法" class="headerlink" title="照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue(int , boolean)方法。其他两个都是之后调用这个方法。所以直接看看这个方法"></a>照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue(int , boolean)方法。其他两个都是之后调用这个方法。所以直接看看这个方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">	// 校验容量不能是负数</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ArrayList与LinkedList的实现和区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ArrayList与LinkedList的实现和区别/" class="post-title-link" itemprop="url">ArrayList与LinkedList的实现和区别</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:04:42" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayList与LinkedList的实现和区别"><a href="#ArrayList与LinkedList的实现和区别" class="headerlink" title="ArrayList与LinkedList的实现和区别"></a>ArrayList与LinkedList的实现和区别</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h4 id="LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。"><a href="#LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。" class="headerlink" title="LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。"></a>LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。</h4><h4 id="在类内部还实现了一个链表节点Node，存储val，pre，next"><a href="#在类内部还实现了一个链表节点Node，存储val，pre，next" class="headerlink" title="在类内部还实现了一个链表节点Node，存储val，pre，next"></a>在类内部还实现了一个链表节点Node，存储val，pre，next</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item = element;</span><br><span class="line">           this.next = next;</span><br><span class="line">           this.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkLast-方法-在最尾端插入节点"><a href="#linkLast-方法-在最尾端插入节点" class="headerlink" title="linkLast() 方法,在最尾端插入节点"></a>linkLast() 方法,在最尾端插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkFirst-方法，在最首端插入节点"><a href="#linkFirst-方法，在最首端插入节点" class="headerlink" title="linkFirst() 方法，在最首端插入节点"></a>linkFirst() 方法，在最首端插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">       // assert succ != null;</span><br><span class="line">       final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       if (pred == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkBefore-方法，在指定位置插入节点"><a href="#linkBefore-方法，在指定位置插入节点" class="headerlink" title="linkBefore() 方法，在指定位置插入节点"></a>linkBefore() 方法，在指定位置插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">       // assert succ != null;</span><br><span class="line">       final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       if (pred == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如"><a href="#以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如" class="headerlink" title="以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如"></a>以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如</h4><h4 id="add-方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast"><a href="#add-方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast" class="headerlink" title="add()方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast"></a>add()方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-int-index-E-element-方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore"><a href="#add-int-index-E-element-方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore" class="headerlink" title="add(int index, E element)方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore"></a>add(int index, E element)方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       if (index == size)</span><br><span class="line">           linkLast(element);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 从前向后，或者从后向前</span><br><span class="line">   Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">       // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">       if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           for (int i = 0; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           return x;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="再看到对首部进行操作。即push方法，或者offerFirst-最终会调用linkFirst方法"><a href="#再看到对首部进行操作。即push方法，或者offerFirst-最终会调用linkFirst方法" class="headerlink" title="再看到对首部进行操作。即push方法，或者offerFirst,最终会调用linkFirst方法"></a>再看到对首部进行操作。即push方法，或者offerFirst,最终会调用linkFirst方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void push(E e) &#123;</span><br><span class="line">      addFirst(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFirst(E e) &#123;</span><br><span class="line">      linkFirst(e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ConcurrentHashmap 的transfer方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ConcurrentHashmap 的transfer方法/" class="post-title-link" itemprop="url">ConcurrentHashMap的transfer方法</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:07:56" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ConcurrentHashmap-的transfer方法"><a href="#ConcurrentHashmap-的transfer方法" class="headerlink" title="ConcurrentHashmap 的transfer方法"></a>ConcurrentHashmap 的transfer方法</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><p>####<br>多线程之间，以volatile的方式读取sizeCtl属性，来判断ConcurrentHashMap当前所处的状态。通过cas设置sizeCtl属性，告知其他线程ConcurrentHashMap的状态变更。<br>不同状态，sizeCtl所代表的含义也有所不同。</p>
<p>未初始化：</p>
<p>sizeCtl=0：表示没有指定初始容量。<br>sizeCtl&gt;0：表示初始容量。</p>
<p>初始化中：</p>
<p>sizeCtl=-1,标记作用，告知其他线程，正在初始化</p>
<p>正常状态：</p>
<p>sizeCtl=0.75n ,扩容阈值</p>
<p>扩容中:</p>
<p>sizeCtl &lt; 0 : 表示有其他线程正在执行扩容<br>sizeCtl = (resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2    :表示此时只有一个线程在执行扩容</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="本文会解释一下在jdk-1-8中的ConcurrentHashMap是怎么并发的进行扩容的。为了描述这一过程，我们会先看到put方法中，因为当put过程中，发现元素大小超过了阈值的时候，线程才会去对底层数组进行扩容。直接看到putVal方法中，为了节省篇幅，会省去一些不必要的代码"><a href="#本文会解释一下在jdk-1-8中的ConcurrentHashMap是怎么并发的进行扩容的。为了描述这一过程，我们会先看到put方法中，因为当put过程中，发现元素大小超过了阈值的时候，线程才会去对底层数组进行扩容。直接看到putVal方法中，为了节省篇幅，会省去一些不必要的代码" class="headerlink" title="本文会解释一下在jdk 1.8中的ConcurrentHashMap是怎么并发的进行扩容的。为了描述这一过程，我们会先看到put方法中，因为当put过程中，发现元素大小超过了阈值的时候，线程才会去对底层数组进行扩容。直接看到putVal方法中，为了节省篇幅，会省去一些不必要的代码"></a>本文会解释一下在jdk 1.8中的ConcurrentHashMap是怎么并发的进行扩容的。为了描述这一过程，我们会先看到put方法中，因为当put过程中，发现元素大小超过了阈值的时候，线程才会去对底层数组进行扩容。直接看到putVal方法中，为了节省篇幅，会省去一些不必要的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        ... </span><br><span class="line">        for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab == null || (n = tab.length) == 0)</span><br><span class="line">                ...</span><br><span class="line">            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">    			...            </span><br><span class="line">            &#125;</span><br><span class="line">            else if ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">            	// 在链表后面添加节点，先省略了</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">                if (binCount != 0) &#123;</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    if (oldVal != null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(1L, binCount);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意上面代码中我留下的几块方法。我们一个个解释。先看到helpTransfer方法。可以看到，要进入到方法的条件是要将值put到的对应的桶位的节点存在，而且hash值为MOVED，也就是-1。全局搜索之后，可以发现只有一个地方会创建这种节点"><a href="#注意上面代码中我留下的几块方法。我们一个个解释。先看到helpTransfer方法。可以看到，要进入到方法的条件是要将值put到的对应的桶位的节点存在，而且hash值为MOVED，也就是-1。全局搜索之后，可以发现只有一个地方会创建这种节点" class="headerlink" title="注意上面代码中我留下的几块方法。我们一个个解释。先看到helpTransfer方法。可以看到，要进入到方法的条件是要将值put到的对应的桶位的节点存在，而且hash值为MOVED，也就是-1。全局搜索之后，可以发现只有一个地方会创建这种节点"></a>注意上面代码中我留下的几块方法。我们一个个解释。先看到helpTransfer方法。可以看到，要进入到方法的条件是要将值put到的对应的桶位的节点存在，而且hash值为MOVED，也就是-1。全局搜索之后，可以发现只有一个地方会创建这种节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123;</span><br><span class="line">       final Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">       ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">           super(MOVED, null, null, null);</span><br><span class="line">           this.nextTable = tab;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       Node&lt;K,V&gt; find(int h, Object k) &#123;</span><br><span class="line">  			... </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到，这一块是将对应的桶变成了一个ForwardingNode-以下简称fwn-，这边先剧透以下，变成这个节点就代表当前桶位正在进行扩容迁移。所以我们回到刚才那个语句"><a href="#可以看到，这一块是将对应的桶变成了一个ForwardingNode-以下简称fwn-，这边先剧透以下，变成这个节点就代表当前桶位正在进行扩容迁移。所以我们回到刚才那个语句" class="headerlink" title="可以看到，这一块是将对应的桶变成了一个ForwardingNode (以下简称fwn)，这边先剧透以下，变成这个节点就代表当前桶位正在进行扩容迁移。所以我们回到刚才那个语句"></a>可以看到，这一块是将对应的桶变成了一个ForwardingNode (以下简称fwn)，这边先剧透以下，变成这个节点就代表当前桶位正在进行扩容迁移。所以我们回到刚才那个语句</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">else if ((fh = f.hash) == MOVED)</span><br><span class="line">       tab = helpTransfer(tab, f);</span><br></pre></td></tr></table></figure>

<h4 id="可以看到如果一个线程在put的时候，发现当前正在进行扩容，他甚至是可以帮忙一起扩容的-跟进去会看到会调用到transfer方法。这也是Cmap一个非常高效的理由。"><a href="#可以看到如果一个线程在put的时候，发现当前正在进行扩容，他甚至是可以帮忙一起扩容的-跟进去会看到会调用到transfer方法。这也是Cmap一个非常高效的理由。" class="headerlink" title="可以看到如果一个线程在put的时候，发现当前正在进行扩容，他甚至是可以帮忙一起扩容的,跟进去会看到会调用到transfer方法。这也是Cmap一个非常高效的理由。"></a>可以看到如果一个线程在put的时候，发现当前正在进行扩容，他甚至是可以帮忙一起扩容的,跟进去会看到会调用到transfer方法。这也是Cmap一个非常高效的理由。</h4><h4 id="再往下看到第二处留下的代码块，这段和HashMap中非常相似，也是如果某个桶位的链表长度大于等于了8，就会尝试进行树化，同样的，在里面也会进行判断，如果此时底层数组的大小还没大于64，则会先进行扩容。"><a href="#再往下看到第二处留下的代码块，这段和HashMap中非常相似，也是如果某个桶位的链表长度大于等于了8，就会尝试进行树化，同样的，在里面也会进行判断，如果此时底层数组的大小还没大于64，则会先进行扩容。" class="headerlink" title="再往下看到第二处留下的代码块，这段和HashMap中非常相似，也是如果某个桶位的链表长度大于等于了8，就会尝试进行树化，同样的，在里面也会进行判断，如果此时底层数组的大小还没大于64，则会先进行扩容。"></a>再往下看到第二处留下的代码块，这段和HashMap中非常相似，也是如果某个桶位的链表长度大于等于了8，就会尝试进行树化，同样的，在里面也会进行判断，如果此时底层数组的大小还没大于64，则会先进行扩容。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123;</span><br><span class="line">       Node&lt;K,V&gt; b; int n, sc;</span><br><span class="line">       if (tab != null) &#123;</span><br><span class="line">           if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">               tryPresize(n &lt;&lt; 1);</span><br><span class="line">           else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123;</span><br><span class="line">  				... </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果你跟进去tryPresize方法，你会看到里面实际起作用的地方也是transfer方法"><a href="#如果你跟进去tryPresize方法，你会看到里面实际起作用的地方也是transfer方法" class="headerlink" title="如果你跟进去tryPresize方法，你会看到里面实际起作用的地方也是transfer方法"></a>如果你跟进去tryPresize方法，你会看到里面实际起作用的地方也是transfer方法</h4><h4 id="再直接看到上面留下的最后一段代码-addCount-1L-binCount-，跟进去可以看到"><a href="#再直接看到上面留下的最后一段代码-addCount-1L-binCount-，跟进去可以看到" class="headerlink" title="再直接看到上面留下的最后一段代码 addCount(1L, binCount);，跟进去可以看到"></a>再直接看到上面留下的最后一段代码 addCount(1L, binCount);，跟进去可以看到</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private final void addCount(long x, int check) &#123;</span><br><span class="line">        ...</span><br><span class="line">       if (check &gt;= 0) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; int n, sc;</span><br><span class="line">            while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                int rs = resizeStamp(n);</span><br><span class="line">                if (sc &lt; 0) &#123;</span><br><span class="line">                    if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</span><br><span class="line">                        // 重点</span><br><span class="line">                        transferIndex &lt;= 0)</span><br><span class="line">                        break;</span><br><span class="line">                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                else if (U.compareAndSwapInt(this, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</span><br><span class="line">                    transfer(tab, null);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="也就是说，如果节点数大于了阈值，就会进行transfer方法，也就是扩容。"><a href="#也就是说，如果节点数大于了阈值，就会进行transfer方法，也就是扩容。" class="headerlink" title="也就是说，如果节点数大于了阈值，就会进行transfer方法，也就是扩容。"></a>也就是说，如果节点数大于了阈值，就会进行transfer方法，也就是扩容。</h4><h4 id="好了以上三段逻辑，最后都回到了transfer方法，也就是我们今天想要讲到的地方。"><a href="#好了以上三段逻辑，最后都回到了transfer方法，也就是我们今天想要讲到的地方。" class="headerlink" title="好了以上三段逻辑，最后都回到了transfer方法，也就是我们今天想要讲到的地方。"></a>好了以上三段逻辑，最后都回到了transfer方法，也就是我们今天想要讲到的地方。</h4><h4 id="我们开始进入到transfer方法的世界"><a href="#我们开始进入到transfer方法的世界" class="headerlink" title="我们开始进入到transfer方法的世界"></a>我们开始进入到transfer方法的世界</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int n = tab.length, stride;</span><br><span class="line">if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">    stride = MIN_TRANSFER_STRIDE; // subdivide range</span><br></pre></td></tr></table></figure>

<h4 id="在方法开始的时候，会得到一个叫做stride的参数。这个参数是指定每个线程可以负责多少个桶。从代码中也可以知道，若当前机器的cpu核数大于1的时候，每个线程负责-n-8-核数-。其中每个线程最小也需要负责16个桶。接下去看"><a href="#在方法开始的时候，会得到一个叫做stride的参数。这个参数是指定每个线程可以负责多少个桶。从代码中也可以知道，若当前机器的cpu核数大于1的时候，每个线程负责-n-8-核数-。其中每个线程最小也需要负责16个桶。接下去看" class="headerlink" title="在方法开始的时候，会得到一个叫做stride的参数。这个参数是指定每个线程可以负责多少个桶。从代码中也可以知道，若当前机器的cpu核数大于1的时候，每个线程负责 n/(8 * 核数)。其中每个线程最小也需要负责16个桶。接下去看"></a>在方法开始的时候，会得到一个叫做stride的参数。这个参数是指定每个线程可以负责多少个桶。从代码中也可以知道，若当前机器的cpu核数大于1的时候，每个线程负责 n/(8 * 核数)。其中每个线程最小也需要负责16个桶。接下去看</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (nextTab == null) &#123;            // initiating</span><br><span class="line">       try &#123;</span><br><span class="line">           @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">           Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</span><br><span class="line">           nextTab = nt;</span><br><span class="line">       &#125; catch (Throwable ex) &#123;      // try to cope with OOME</span><br><span class="line">           sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       nextTable = nextTab;</span><br><span class="line">       transferIndex = n;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="如果新的数组还未初始化，则需要先初始化一下。新数组大小是旧数组的2倍。"><a href="#如果新的数组还未初始化，则需要先初始化一下。新数组大小是旧数组的2倍。" class="headerlink" title="如果新的数组还未初始化，则需要先初始化一下。新数组大小是旧数组的2倍。"></a>如果新的数组还未初始化，则需要先初始化一下。新数组大小是旧数组的2倍。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int nextn = nextTab.length;</span><br><span class="line">ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">boolean advance = true;</span><br><span class="line">boolean finishing = false; // to ensure sweep before committing nextTab</span><br></pre></td></tr></table></figure>

<h4 id="规定一些参数。继续往下，会看到一个for循环"><a href="#规定一些参数。继续往下，会看到一个for循环" class="headerlink" title="规定一些参数。继续往下，会看到一个for循环"></a>规定一些参数。继续往下，会看到一个for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0, bound = 0;;) &#123;</span><br><span class="line">    Node&lt;K,V&gt; f; int fh;</span><br><span class="line">    while (advance) &#123;</span><br><span class="line">        int nextIndex, nextBound;</span><br><span class="line">        if (--i &gt;= bound || finishing)</span><br><span class="line">            advance = false;</span><br><span class="line">        else if ((nextIndex = transferIndex) &lt;= 0) &#123;</span><br><span class="line">            i = -1;</span><br><span class="line">            advance = false;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (U.compareAndSwapInt</span><br><span class="line">                 (this, TRANSFERINDEX, nextIndex,</span><br><span class="line">                  nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                               nextIndex - stride : 0))) &#123;</span><br><span class="line">            bound = nextBound;</span><br><span class="line">            i = nextIndex - 1;</span><br><span class="line">            advance = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这一块注意几个关键的属性transferIndex，nextIndex，nextBound。具体逻辑可以看到这个链接的内容，讲的非常好。"><a href="#这一块注意几个关键的属性transferIndex，nextIndex，nextBound。具体逻辑可以看到这个链接的内容，讲的非常好。" class="headerlink" title="这一块注意几个关键的属性transferIndex，nextIndex，nextBound。具体逻辑可以看到这个链接的内容，讲的非常好。"></a>这一块注意几个关键的属性transferIndex，nextIndex，nextBound。具体逻辑可以看到这个链接的内容，讲的非常好。</h4><p><a href="https://www.jianshu.com/p/487d00afe6ca" target="_blank" rel="noopener">扩容方法的属性</a></p>
<h4 id="通过上面的for循环之后，我们就可以继续我们接下来的实际迁移过程了。借用上面链接里的几幅图进行理解"><a href="#通过上面的for循环之后，我们就可以继续我们接下来的实际迁移过程了。借用上面链接里的几幅图进行理解" class="headerlink" title="通过上面的for循环之后，我们就可以继续我们接下来的实际迁移过程了。借用上面链接里的几幅图进行理解"></a>通过上面的for循环之后，我们就可以继续我们接下来的实际迁移过程了。借用上面链接里的几幅图进行理解</h4><p><img src="img/transfer-1.png" alt="transfer-1"><br><img src="img/transfer-2.png" alt="transfer-2"></p>
<h4 id="可以得到现在"><a href="#可以得到现在" class="headerlink" title="可以得到现在"></a>可以得到现在</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nextBound = 16,</span><br><span class="line">nextIndex = 32,</span><br><span class="line">i = nextIndex -1 = 31</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/谈谈ConcurrentHashmap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/谈谈ConcurrentHashmap/" class="post-title-link" itemprop="url">ConcurrentHashmap源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:08:56" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="谈谈ConcurrentHashmap"><a href="#谈谈ConcurrentHashmap" class="headerlink" title="谈谈ConcurrentHashmap"></a>谈谈ConcurrentHashmap</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="本系列终于对ConcurrentHashmap下手了，为了解决HashMap的线程不安全的问题。java还提供了一种允许多线程同时高效访问的类似HashMap的数据结构，也就是ConcurrentHashmap，并在jdk-1-8版本中做了一个较大的改变。在jdk-1-7中，一直采用的都是对每个segment进行分段锁方法进行加锁，所以有几个segment就允许多少线程同时进行读写。但是在jdk-1-8中，完全抛弃了这种分段锁的方法，取而代之的是用CAS-synchronized的方式，对多线程进行控制。现在直接进入正文，看看内部到底是怎么进行操作的。"><a href="#本系列终于对ConcurrentHashmap下手了，为了解决HashMap的线程不安全的问题。java还提供了一种允许多线程同时高效访问的类似HashMap的数据结构，也就是ConcurrentHashmap，并在jdk-1-8版本中做了一个较大的改变。在jdk-1-7中，一直采用的都是对每个segment进行分段锁方法进行加锁，所以有几个segment就允许多少线程同时进行读写。但是在jdk-1-8中，完全抛弃了这种分段锁的方法，取而代之的是用CAS-synchronized的方式，对多线程进行控制。现在直接进入正文，看看内部到底是怎么进行操作的。" class="headerlink" title="本系列终于对ConcurrentHashmap下手了，为了解决HashMap的线程不安全的问题。java还提供了一种允许多线程同时高效访问的类似HashMap的数据结构，也就是ConcurrentHashmap，并在jdk 1.8版本中做了一个较大的改变。在jdk 1.7中，一直采用的都是对每个segment进行分段锁方法进行加锁，所以有几个segment就允许多少线程同时进行读写。但是在jdk 1.8中，完全抛弃了这种分段锁的方法，取而代之的是用CAS+synchronized的方式，对多线程进行控制。现在直接进入正文，看看内部到底是怎么进行操作的。"></a>本系列终于对ConcurrentHashmap下手了，为了解决HashMap的线程不安全的问题。java还提供了一种允许多线程同时高效访问的类似HashMap的数据结构，也就是ConcurrentHashmap，并在jdk 1.8版本中做了一个较大的改变。在jdk 1.7中，一直采用的都是对每个segment进行分段锁方法进行加锁，所以有几个segment就允许多少线程同时进行读写。但是在jdk 1.8中，完全抛弃了这种分段锁的方法，取而代之的是用CAS+synchronized的方式，对多线程进行控制。现在直接进入正文，看看内部到底是怎么进行操作的。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="先看看构造函数，可以看到和HashMap的构造函数非常类似"><a href="#先看看构造函数，可以看到和HashMap的构造函数非常类似" class="headerlink" title="先看看构造函数，可以看到和HashMap的构造函数非常类似"></a>先看看构造函数，可以看到和HashMap的构造函数非常类似</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ConcurrentHashMap(int initialCapacity,</span><br><span class="line">                         float loadFactor, int concurrencyLevel) &#123;</span><br><span class="line">    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</span><br><span class="line">        initialCapacity = concurrencyLevel;   // as estimated threads</span><br><span class="line">    long size = (long)(1.0 + (long)initialCapacity / loadFactor);</span><br><span class="line">    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((int)size);</span><br><span class="line">    this.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TODO-构造函数-concurrencyLevel-this-sizeCtl"><a href="#TODO-构造函数-concurrencyLevel-this-sizeCtl" class="headerlink" title="TODO 构造函数 concurrencyLevel this.sizeCtl"></a>TODO 构造函数 concurrencyLevel this.sizeCtl</h1><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><h4 id="现在看看put方法里做了什么。为什么可以接受多并发。"><a href="#现在看看put方法里做了什么。为什么可以接受多并发。" class="headerlink" title="现在看看put方法里做了什么。为什么可以接受多并发。"></a>现在看看put方法里做了什么。为什么可以接受多并发。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 和hashMap差不多，也是调用了putVal方法，第三个参数是onlyIfAbsent，在后面会用到</span><br><span class="line">   public V put(K key, V value) &#123;</span><br><span class="line">       return putVal(key, value, false);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /** Implementation for put and putIfAbsent */</span><br><span class="line">   final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">   	// 不接受key或者value为null的情况，这和HashMap也是不一样</span><br><span class="line">       if (key == null || value == null) throw new NullPointerException();</span><br><span class="line">       // 得到key对应的Hash值，也是高16位和低16位做^操作</span><br><span class="line">       int hash = spread(key.hashCode());</span><br><span class="line">       int binCount = 0;</span><br><span class="line">       // 永真循环的重试</span><br><span class="line">       for (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">           Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">           // 若底层table还没初始化，就需要先初始化</span><br><span class="line">           if (tab == null || (n = tab.length) == 0)</span><br><span class="line">               tab = initTable();</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; int sc;</span><br><span class="line">       while ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">       	// 若sizeCtl小于0，表示其他线程正在初始化table。只能有一个线程进行初始化，所以当前线程先挂起</span><br><span class="line">           if ((sc = sizeCtl) &lt; 0)</span><br><span class="line">               Thread.yield(); // lost initialization race; just spin</span><br><span class="line">           // 用CAS的方式将sizeCtl的值置为-1，若成功，则代表当前线程抢占到了锁，可以进行初始化table了</span><br><span class="line">           else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   if ((tab = table) == null || tab.length == 0) &#123;</span><br><span class="line">                   	// 若sizeCtl没有设置，则直接用默认值16</span><br><span class="line">                       int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                       Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</span><br><span class="line">                       table = tab = nt;</span><br><span class="line">                       // sc = 3n / 4 ,即默认值为12</span><br><span class="line">                       sc = n - (n &gt;&gt;&gt; 2);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; finally &#123;</span><br><span class="line">                   sizeCtl = sc;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return tab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="底层就是利用CAS来控制在多线程中选择一个唯一的线程来创建底层table，在ConcurrentHashmap中会大量出现CAS的方法来控制并发。接下来看初始化成功之后做了什么"><a href="#底层就是利用CAS来控制在多线程中选择一个唯一的线程来创建底层table，在ConcurrentHashmap中会大量出现CAS的方法来控制并发。接下来看初始化成功之后做了什么" class="headerlink" title="底层就是利用CAS来控制在多线程中选择一个唯一的线程来创建底层table，在ConcurrentHashmap中会大量出现CAS的方法来控制并发。接下来看初始化成功之后做了什么"></a>底层就是利用CAS来控制在多线程中选择一个唯一的线程来创建底层table，在ConcurrentHashmap中会大量出现CAS的方法来控制并发。接下来看初始化成功之后做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 类似HashMap中，利用hash来确定在底层的桶位值</span><br><span class="line">else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</span><br><span class="line">	// 若当前的桶位值还没有被其他节点占据，则直接新创建一个Node，也是用CAS的方式放在对应的位置</span><br><span class="line">       if (casTabAt(tab, i, null,new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">           break;                   // no lock when adding to empty bin</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 以下的CAS方式都是根据每个变量在内存的地址直接置换，不再细述了</span><br><span class="line">   // Unsafe mechanics</span><br><span class="line">   private static final sun.misc.Unsafe U;</span><br><span class="line">   private static final long ABASE;</span><br><span class="line">   private static final int ASHIFT;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           U = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">           Class&lt;?&gt; ak = Node[].class;</span><br><span class="line">           ABASE = U.arrayBaseOffset(ak);</span><br><span class="line">           int scale = U.arrayIndexScale(ak);</span><br><span class="line">           if ((scale &amp; (scale - 1)) != 0)</span><br><span class="line">               throw new Error(&quot;data type scale not a power of two&quot;);</span><br><span class="line">           ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           throw new Error(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123;</span><br><span class="line">       return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i,</span><br><span class="line">                                       Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</span><br><span class="line">       return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这一段也是和HashMap一样，直接在底层table对应的桶位放入Node元素。但是由于用了CAS的操作，保证了线程安全。"><a href="#这一段也是和HashMap一样，直接在底层table对应的桶位放入Node元素。但是由于用了CAS的操作，保证了线程安全。" class="headerlink" title="这一段也是和HashMap一样，直接在底层table对应的桶位放入Node元素。但是由于用了CAS的操作，保证了线程安全。"></a>这一段也是和HashMap一样，直接在底层table对应的桶位放入Node元素。但是由于用了CAS的操作，保证了线程安全。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   else if ((fh = f.hash) == MOVED)</span><br><span class="line">       tab = helpTransfer(tab, f);</span><br><span class="line"></span><br><span class="line">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] nextTab; int sc;</span><br><span class="line">       if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</span><br><span class="line">           (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</span><br><span class="line">           int rs = resizeStamp(tab.length);</span><br><span class="line">           while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                  (sc = sizeCtl) &lt; 0) &#123;</span><br><span class="line">               if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</span><br><span class="line">                   sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</span><br><span class="line">                   break;</span><br><span class="line">               // CAS方法将sc+1，表示有新的线程加入一起迁移    </span><br><span class="line">               if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</span><br><span class="line">                   transfer(tab, nextTab);</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           return nextTab;</span><br><span class="line">       &#125;</span><br><span class="line">       return table;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个if判断是hash值为MOVED，也就是-1。这是由于集群正在扩容以及对原有的节点进行移位，"><a href="#这个if判断是hash值为MOVED，也就是-1。这是由于集群正在扩容以及对原有的节点进行移位，" class="headerlink" title="这个if判断是hash值为MOVED，也就是-1。这是由于集群正在扩容以及对原有的节点进行移位，"></a>这个if判断是hash值为MOVED，也就是-1。这是由于集群正在扩容以及对原有的节点进行移位，</h4><h4 id="再看到下面这个if判断-这个判断就是若table桶位值已经存在了节点，那么就需要在后面接节点组成链表，链表长度超过阈值的时候，也要转成红黑树。在jdk-1-7的时候并不是这种处理方式的，但是在jdk-1-8的时候变成了和HashMap同样的处理方式。"><a href="#再看到下面这个if判断-这个判断就是若table桶位值已经存在了节点，那么就需要在后面接节点组成链表，链表长度超过阈值的时候，也要转成红黑树。在jdk-1-7的时候并不是这种处理方式的，但是在jdk-1-8的时候变成了和HashMap同样的处理方式。" class="headerlink" title="再看到下面这个if判断,这个判断就是若table桶位值已经存在了节点，那么就需要在后面接节点组成链表，链表长度超过阈值的时候，也要转成红黑树。在jdk 1.7的时候并不是这种处理方式的，但是在jdk 1.8的时候变成了和HashMap同样的处理方式。"></a>再看到下面这个if判断,这个判断就是若table桶位值已经存在了节点，那么就需要在后面接节点组成链表，链表长度超过阈值的时候，也要转成红黑树。在jdk 1.7的时候并不是这种处理方式的，但是在jdk 1.8的时候变成了和HashMap同样的处理方式。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">       V oldVal = null;</span><br><span class="line">       // 需要先锁定桶位的首节点</span><br><span class="line">       synchronized (f) &#123;</span><br><span class="line">           if (tabAt(tab, i) == f) &#123;</span><br><span class="line">               // 若节点的hash值&gt;=0,则表明是链表节点</span><br><span class="line">               if (fh &gt;= 0) &#123;</span><br><span class="line">               	// 作为记录链表的长度</span><br><span class="line">                   binCount = 1;</span><br><span class="line">                   for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                       K ek;</span><br><span class="line">                       if (e.hash == hash &amp;&amp;</span><br><span class="line">                           ((ek = e.key) == key ||</span><br><span class="line">                            (ek != null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                           oldVal = e.val;</span><br><span class="line">                           // 只有在值不存在的时候才会去插入</span><br><span class="line">                           if (!onlyIfAbsent)</span><br><span class="line">                               e.val = value;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                       Node&lt;K,V&gt; pred = e;</span><br><span class="line">                       // 遍历链表</span><br><span class="line">                       if ((e = e.next) == null) &#123;</span><br><span class="line">                           pred.next = new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                     value, null);</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               // 若节点的hash值&lt;0,则表明是树节点</span><br><span class="line">               else if (f instanceof TreeBin) &#123;</span><br><span class="line">                   Node&lt;K,V&gt; p;</span><br><span class="line">                   binCount = 2;</span><br><span class="line">                   // 利用红黑树的方式插入</span><br><span class="line">                   if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                  value)) != null) &#123;</span><br><span class="line">                       oldVal = p.val;</span><br><span class="line">                       if (!onlyIfAbsent)</span><br><span class="line">                           p.val = value;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       // 若链表的长度此时已大于TREEIFY_THRESHOLD，默认值为8，则需要将链表转为红黑树</span><br><span class="line">       if (binCount != 0) &#123;</span><br><span class="line">           if (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">               treeifyBin(tab, i);</span><br><span class="line">           if (oldVal != null)</span><br><span class="line">               return oldVal;</span><br><span class="line">           break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本逻辑和HashMap非常相似，只是加了synchronized修饰符，保证线程安全。put方法先讲到这边，留了很多坑，例如红黑树怎么转化，以及最重要的怎么进行扩容。这个先放着，下面先讲讲怎么进行get，之后再回来填坑。"><a href="#基本逻辑和HashMap非常相似，只是加了synchronized修饰符，保证线程安全。put方法先讲到这边，留了很多坑，例如红黑树怎么转化，以及最重要的怎么进行扩容。这个先放着，下面先讲讲怎么进行get，之后再回来填坑。" class="headerlink" title="基本逻辑和HashMap非常相似，只是加了synchronized修饰符，保证线程安全。put方法先讲到这边，留了很多坑，例如红黑树怎么转化，以及最重要的怎么进行扩容。这个先放着，下面先讲讲怎么进行get，之后再回来填坑。"></a>基本逻辑和HashMap非常相似，只是加了synchronized修饰符，保证线程安全。put方法先讲到这边，留了很多坑，例如红黑树怎么转化，以及最重要的怎么进行扩容。这个先放着，下面先讲讲怎么进行get，之后再回来填坑。</h4><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">    // 同样的得到hash值，为了计算得到后续的桶位值</span><br><span class="line">    int h = spread(key.hashCode());</span><br><span class="line">    // 验证此时table不为空，且已初始化，并在对应的桶位有节点已经放置节点</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123;</span><br><span class="line">        // 首先验证首节点是否满足条件，是就返回</span><br><span class="line">        if ((eh = e.hash) == h) &#123;</span><br><span class="line">            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若首节点不满足条件，且hash&lt;0，则证明此时已经转化为红黑树，则调用红黑树的方式去寻找</span><br><span class="line">        else if (eh &lt; 0)</span><br><span class="line">            return (p = e.find(h, key)) != null ? p.val : null;</span><br><span class="line">        // 若上面都不符合，则遍历链表，得到满足条件的值</span><br><span class="line">        while ((e = e.next) != null) &#123;</span><br><span class="line">            if (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                return e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RESIZE-STAMP-SHIFT-RESIZE-STAMP-BITS-32"><a href="#RESIZE-STAMP-SHIFT-RESIZE-STAMP-BITS-32" class="headerlink" title="RESIZE_STAMP_SHIFT + RESIZE_STAMP_BITS = 32"></a>RESIZE_STAMP_SHIFT + RESIZE_STAMP_BITS = 32</h3><h3 id="sizeCtl-默认为0-用来控制table的初始化和扩容操作-它的数值有以下含义"><a href="#sizeCtl-默认为0-用来控制table的初始化和扩容操作-它的数值有以下含义" class="headerlink" title="sizeCtl:默认为0,用来控制table的初始化和扩容操作.它的数值有以下含义"></a>sizeCtl:默认为0,用来控制table的初始化和扩容操作.它的数值有以下含义</h3><p>-1 :代表table正在初始化,其他线程应该交出CPU时间片,退出<br>-N: 表示正有N-1个线程执行扩容操作</p>
<blockquote>
<p>0: 如果table已经初始化,代表table容量,默认为table大小的0.75,如果还未初始化,代表需要初始化的大小</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/聊聊 Synchronize 关键字/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/聊聊 Synchronize 关键字/" class="post-title-link" itemprop="url">聊聊 Synchronize 关键字</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:42:36" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊聊-Synchronize-关键字"><a href="#聊聊-Synchronize-关键字" class="headerlink" title="聊聊 Synchronize 关键字"></a>聊聊 Synchronize 关键字</h1><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况"><a href="#Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况" class="headerlink" title="Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况"></a>Synchronize是java中提供的一个并发控制的一个关键字。主要是为了控制多线程并发情况下对共享资源的竞争情况。加锁有以下三种情况</h4><p>1：修饰普通方法，锁的对象是当前实例<br>2：修饰形态方法，锁的对象是当前类class对象<br>3：修饰同步代码块，锁的对象是括号中的内容，可以是实例也可以是class对象</p>
<h4 id="以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的"><a href="#以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的" class="headerlink" title="以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的"></a>以上三种情况，简单归纳可以分为两类，一个是同步方法，一个是同步代码块。在java中，这两种的实现方式是不一样的，先说说同步方法，如果我们把我们写的关于同步方法的代码反编译，会发现在反编译代码中，同步方法的代码部分，会是这样子的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br></pre></td></tr></table></figure>

<h4 id="就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。"><a href="#就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。" class="headerlink" title="就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。"></a>就代表这个方法是public的，而且是同步的。那么同步代码块是怎么样的呢？同样反编译，我们可以得到答案。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter  //注意此处，进入同步方法</span><br><span class="line">...      </span><br><span class="line">   21: monitorexit //注意此处，退出同步方法</span><br></pre></td></tr></table></figure>

<h4 id="可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。"><a href="#可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。" class="headerlink" title="可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。"></a>可以很直观的看出来，是用了两个指令来控制的，注意一下两个指令必须是成对出现的，代表获得锁和释放锁的过程。</h4><h4 id="再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性"><a href="#再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性" class="headerlink" title="再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性"></a>再看到，每个实例和类对象都有自己单独的监视器，所以两个线程可以同时访问普通的Synchronize以及静态的Synchronize方法。所以该修饰符可能会有以下几个特性</h4><p>1：当线程A正在访问某个实例对象的普通Synchronize方法，或者同步代码块的括号中为一个实例对象是，其他线程不但不能访问这个同步方法，而且其他同步方法也不能方法。但是静态的同步方法是可以访问的，因为之前说过实例对象和类对象是有自己不同的监视器的</p>
<h4 id="之前说了很多次监视器，那么监视器到底是什么呢-在java中，这部分是用c-实现的，对应的对象内容如下"><a href="#之前说了很多次监视器，那么监视器到底是什么呢-在java中，这部分是用c-实现的，对应的对象内容如下" class="headerlink" title="之前说了很多次监视器，那么监视器到底是什么呢?在java中，这部分是用c++实现的，对应的对象内容如下"></a>之前说了很多次监视器，那么监视器到底是什么呢?在java中，这部分是用c++实现的，对应的对象内容如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = 0; //用来记录该对象被线程获取锁的次数</span><br><span class="line">    _waiters      = 0;</span><br><span class="line">    _recursions   = 0; //锁的重入次数</span><br><span class="line">    _owner        = NULL; //指向持有ObjectMonitor对象的线程 </span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="这一块的解释，我引用被人写的一个整个的属性转换的过程"><a href="#这一块的解释，我引用被人写的一个整个的属性转换的过程" class="headerlink" title="这一块的解释，我引用被人写的一个整个的属性转换的过程"></a>这一块的解释，我引用被人写的一个整个的属性转换的过程</h4><blockquote>
<p>对于一个synchronized修饰的方法(代码块)来说：<br>当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态<br>当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象的_owner指向当前线程，_count加1表示当前对象锁被一个线程获取<br>当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1，同时线程进入_WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入_Owner区<br>如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1</p>
</blockquote>
<h4 id="现在再讲讲关于锁的一些膨胀的机制。其实在jdk-1-6之前，是只有重量锁，在jdk-1-6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。"><a href="#现在再讲讲关于锁的一些膨胀的机制。其实在jdk-1-6之前，是只有重量锁，在jdk-1-6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。" class="headerlink" title="现在再讲讲关于锁的一些膨胀的机制。其实在jdk 1.6之前，是只有重量锁，在jdk 1.6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。"></a>现在再讲讲关于锁的一些膨胀的机制。其实在jdk 1.6之前，是只有重量锁，在jdk 1.6之后，引用了轻量锁，和偏向锁。在一些竞争不激烈的情况下，减轻锁开销，这些锁的分类都是基于对象头。</h4><h4 id="先讲到重量锁"><a href="#先讲到重量锁" class="headerlink" title="先讲到重量锁"></a>先讲到重量锁</h4><p>重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。</p>
<p>可以看到锁信息也是存在于对象的mark word中的。当对象状态为偏向锁（biasable）时，mark word存储的是偏向的线程ID；当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashMap 1.7 版本的transfer方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashMap 1.7 版本的transfer方法/" class="post-title-link" itemprop="url">HashMap 1.7 版本的transfer方法</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:07:31" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap-1-7-版本的transfer方法"><a href="#HashMap-1-7-版本的transfer方法" class="headerlink" title="HashMap 1.7 版本的transfer方法"></a>HashMap 1.7 版本的transfer方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">     Entry[] src = table; </span><br><span class="line"></span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">     for (int j = 0; j &lt; src.length; j++) &#123; </span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">         if (e != null) &#123;</span><br><span class="line">             src[j] = null; </span><br><span class="line"></span><br><span class="line">             do &#123; </span><br><span class="line">                Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                int i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; </span><br><span class="line">                newTable[i] = e;  </span><br><span class="line">                e = next;             </span><br><span class="line">            &#125; while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> static int indexFor(int h, int length) &#123;  </span><br><span class="line">         return h &amp; (length-1); </span><br><span class="line">  	 &#125;</span><br></pre></td></tr></table></figure>

<p>newTable和src<br>遍历src中的所有桶位，如果存在链表节点，则需要遍历所有节点，用首插法的方式，将节点都移动到新的数组中。这边举一个例子，假设初始数组大小是2</p>
<p><img src="img/HashMapDeadLoop.png" alt="数组死锁"><br>线程1开始后，线程2开始transfer，并已经结束。就会造成死循环<br><img src="img/HashMapDeadLoop2.png" alt="数组死锁"><br>这时候如果调用get方法，则会一直在死循环中</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashTable,HashMap,ConcurrentHashMap 横向对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashTable,HashMap,ConcurrentHashMap 横向对比/" class="post-title-link" itemprop="url">HashTable，HashMap，CocurrentHashMap横向对比</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:07:07" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashTable-HashMap-ConcurrentHashMap-横向对比"><a href="#HashTable-HashMap-ConcurrentHashMap-横向对比" class="headerlink" title="HashTable,HashMap,ConcurrentHashMap 横向对比"></a>HashTable,HashMap,ConcurrentHashMap 横向对比</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>int index = (key.hashcode &amp; 0x7fffffff) % tab.length</code></pre><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>int index = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
最终的桶位值还需要 index &amp; (tab.length -1)</code></pre><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>int index = (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff;
最终的桶位值还需要 index &amp; (tab.length -1)</code></pre><h2 id="k，v能否为null"><a href="#k，v能否为null" class="headerlink" title="k，v能否为null"></a>k，v能否为null</h2><h3 id="HashTable-1"><a href="#HashTable-1" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>k，v均不能为null，v是因为在代码中判断，k是因为null.hashcode()会报错</code></pre><h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>k,v均可以为null。 且k为null时，会自动分配其为0号桶位</code></pre><h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>k，v均不能为null，强行校验</code></pre><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><h3 id="HashTable-2"><a href="#HashTable-2" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>在put值到底层tab前，会先进行一次count&gt;=threshold的判断，若是，则先直接进行rehash(),再将k,v放到扩容后的tab中
扩容后的newsize = (oldsize * 2) +1
倒序遍历oldtab中的每一个桶位，并用首插法的方式，将元素插入到newtab中
整个过程由synchronized强加锁，避免并发问题</code></pre><h3 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>在put值到tab之后，才会进行容量检查，若(++size &gt; threshold)，则进行扩容
扩容后的newsize = (oldsize * 2)，保持每次底层tab的容量都为2的幂次方
顺序遍历oldtab，然后将元素放置在相应的位置，改为尾插法
且根据bit直接计算对应所在的位置
整个过程，不做并发控制，所以会有并发问题</code></pre><h3 id="ConcurrentHashMap-2"><a href="#ConcurrentHashMap-2" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashTable/" class="post-title-link" itemprop="url">HashTable源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:04:30" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊一聊HashTable"><a href="#聊一聊HashTable" class="headerlink" title="聊一聊HashTable"></a>聊一聊HashTable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"><a href="#关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下" class="headerlink" title="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"></a>关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"><a href="#大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？" class="headerlink" title="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"></a>大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？</h4><h4 id="这边用一个小例子作为入口，我们可以进去一探究竟"><a href="#这边用一个小例子作为入口，我们可以进去一探究竟" class="headerlink" title="这边用一个小例子作为入口，我们可以进去一探究竟"></a>这边用一个小例子作为入口，我们可以进去一探究竟</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    Hashtable hb = new Hashtable();</span><br><span class="line">    // 存储</span><br><span class="line">    hb.put(&quot;1&quot;,new Integer(1));</span><br><span class="line">    hb.put(&quot;2&quot;,new Integer(2));</span><br><span class="line">    hb.put(&quot;3&quot;,new Integer(3));</span><br><span class="line">    // 取值</span><br><span class="line">    System.out.println(hb.get(&quot;1&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;2&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;3&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"><a href="#这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。" class="headerlink" title="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"></a>这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。</h4><ul>
<li>初始化 </li>
<li>存储</li>
<li>取值</li>
</ul>
<h4 id="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"><a href="#这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现" class="headerlink" title="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"></a>这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现</h4><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h4 id="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"><a href="#当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。" class="headerlink" title="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"></a>当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。</h4><h1 id="TODO-构造函数截图"><a href="#TODO-构造函数截图" class="headerlink" title="TODO 构造函数截图"></a>TODO 构造函数截图</h1><h4 id="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"><a href="#从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。" class="headerlink" title="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"></a>从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity==0)</span><br><span class="line">        initialCapacity = 1;</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 上面的代码主要对参数的格式做了一些检验，例如initialCapacity不能为负数，而且最小也必须是1，</span><br><span class="line">    // loadFactor 必须是大于零的浮点数</span><br><span class="line">    </span><br><span class="line">    // 再根据initialCapacity参数创建一个Entry数组</span><br><span class="line">    table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    // 初始化threshold，(两个参数的乘积)和(Int最大值-8)中的较小值</span><br><span class="line">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。"><a href="#这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。" class="headerlink" title="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。"></a>这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。</h4><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h4 id="现在我们看一下当我们put的时候，内部发生了什么"><a href="#现在我们看一下当我们put的时候，内部发生了什么" class="headerlink" title="现在我们看一下当我们put的时候，内部发生了什么"></a>现在我们看一下当我们put的时候，内部发生了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 可以看到这个方法名上加了synchronized，这和在HashMap上是有不一样的地方</span><br><span class="line">   public synchronized V put(K key, V value) &#123;</span><br><span class="line">       // Make sure the value is not null</span><br><span class="line">       if (value == null) &#123;</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Makes sure the key is not already in the hashtable.</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       // 会取传入的键的Hashcode，所以每个字符串的Hashcode都是一样的</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       // 通过计算得到当前键在Entry数组中的下标</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       // 取出在数组中指定下标已存在的值，指定下标取出来可能是一个链表，在Entry中存有链表后继结点的引用</span><br><span class="line">       Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">       	// 必须双重判断hash值一样，而且键值内容一样，才能说明传入的key已存在</span><br><span class="line">           if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">           	// 若已存在，则替换新传入的值，并返回旧值</span><br><span class="line">               V old = entry.value;</span><br><span class="line">               entry.value = value;</span><br><span class="line">               return old;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	// 若key在原结构中不存在，则需要新增</span><br><span class="line">       addEntry(hash, key, value, index);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="继续看看往存储结构中新增一个key的时候做了什么操作"><a href="#继续看看往存储结构中新增一个key的时候做了什么操作" class="headerlink" title="继续看看往存储结构中新增一个key的时候做了什么操作"></a>继续看看往存储结构中新增一个key的时候做了什么操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">	// 这个字段作为修改的一个version值做后续的版本控制</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">	// count是当前数组中已有的Entry的数目</span><br><span class="line">	// 如果比原定的threshold要大，则需要重新进行一次hash重分配</span><br><span class="line">    if (count &gt;= threshold) &#123;</span><br><span class="line">        // Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 在Entry数组对应的index的位置创建一个值，并把可能原有的值作为新增节点在链表中的后继结点存储，所以在链表中是新的节点排在链表前面</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。"><a href="#新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。" class="headerlink" title="新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。"></a>新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">	// old容量 默认为11</span><br><span class="line">       int oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">       // overflow-conscious code</span><br><span class="line">       // new容量 = (11 &lt;&lt; 1) + 1 = 23 </span><br><span class="line">       int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">       // MAX_ARRAY_SIZE 是Int.max - 8， 如果新的容量比这个数值还要大的话，要进行进一步的考量</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">           if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               // Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">               return;</span><br><span class="line">           newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       // 用新的容量创建一个新的数组</span><br><span class="line">       Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       // 重新计算threshold</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">       table = newMap;</span><br><span class="line">	// 从原有数组的末尾，从后往前扫描每一个节点，按照新的容量计算新的index。</span><br><span class="line">       for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">           for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">               newMap[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"><a href="#好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程" class="headerlink" title="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"></a>好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程</h4><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 同样是一个同步的方法</span><br><span class="line">   public synchronized V get(Object key) &#123;</span><br><span class="line">   	// 整个方法是不是似曾相识？在我们第二步的存储的代码中，已经包含了这一部分代码。当时是为了确定存入的值是否已经存在。所以这边也不赘述了</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">           if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               return (V)e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"><a href="#大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。" class="headerlink" title="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"></a>大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ReentrantLock源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ReentrantLock源码解析/" class="post-title-link" itemprop="url">ReetrantLock源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:06:24" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ReentrantLock源码详解"><a href="#ReentrantLock源码详解" class="headerlink" title="ReentrantLock源码详解"></a>ReentrantLock源码详解</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。"><a href="#之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。" class="headerlink" title="之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。"></a>之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定"><a href="#ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定" class="headerlink" title="ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定"></a>ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类"><a href="#可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类" class="headerlink" title="可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类"></a>可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 继承实现了AQS，使用了独占模式</span><br><span class="line">	abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">       private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">       abstract void lock();</span><br><span class="line">	// 这是非公平锁独有的抢占方法</span><br><span class="line">       final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           // 如果当前资源为0，则代表可以开始抢占</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           	// 用CAS的方式将资源改成抢占后的值，一般都是+1</span><br><span class="line">               if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">               	// 表示当前线程已经独占了锁</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果当前锁已经被抢占，而且正是被当前线程抢占，则可以直接再次进入锁</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0) // overflow</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">	// 继承实现了独占模式的释放资源的抽象方法</span><br><span class="line">       protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">       	// 在ReentrantLock中，得到资源之后会将state + 1;释放之后 再 -1</span><br><span class="line">       	// 所以得到的c的值表示是否已经将所有加锁的资源释放</span><br><span class="line">       	// 例如 初始state = 0，此时 线程A第一次得到了锁，则state += 1，同理多次得到会多次+1</span><br><span class="line">       	// 然后依次释放，依次-1</span><br><span class="line">           int c = getState() - releases;</span><br><span class="line">           // 只有当前线程是抢占到资源的线程时才可以释放</span><br><span class="line">           if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           // 标志是否完全可以供抢占</span><br><span class="line">           boolean free = false;</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           	// 如上分析，c==0，代表线程完全释放了资源，</span><br><span class="line">               free = true;</span><br><span class="line">             // 表示当前没有线程抢占了资源</span><br><span class="line">               setExclusiveOwnerThread(null);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           return free;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected final boolean isHeldExclusively() &#123;</span><br><span class="line">           // While we must in general read state before owner,</span><br><span class="line">           // we don&apos;t need to do so to check if current thread is owner</span><br><span class="line">           return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁"><a href="#在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁" class="headerlink" title="在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁"></a>在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">        * acquire on failure.</span><br><span class="line">        */</span><br><span class="line">       // 抢占锁 </span><br><span class="line">       final void lock() &#123;</span><br><span class="line">       	// 直接先尝试用CAS的方式，改变资源的状态</span><br><span class="line">           if (compareAndSetState(0, 1))</span><br><span class="line">           	// 如果CAS成功，则看做已经得到了锁，直接将独占线程改为自己</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           else</span><br><span class="line">           	// 如果CAS没有成功，则进入正常的AQS抢占流程</span><br><span class="line">               acquire(1);</span><br><span class="line">       &#125;</span><br><span class="line">	// 抽象方法直接使用了Sync中的非公平抢占实现</span><br><span class="line">       protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           return nonfairTryAcquire(acquires);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="再看看公平锁"><a href="#再看看公平锁" class="headerlink" title="再看看公平锁"></a>再看看公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">       final void lock() &#123;</span><br><span class="line">       	// 直接进行AQS抢占流程</span><br><span class="line">           acquire(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">        * recursive call or no waiters or is first.</span><br><span class="line">        */</span><br><span class="line">        // 抽象方法的实现，可以看到和非公平的方式基本相同</span><br><span class="line">       protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           		// 只有多了一个这个判断</span><br><span class="line">           		// 就是判断在AQS的等待队列中，是否已经有其他节点在等待</span><br><span class="line">           		// 如果没有，则直接调用</span><br><span class="line">           		// 也就是公平锁代表不能插队</span><br><span class="line">               if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0)</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。"><a href="#所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。" class="headerlink" title="所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。"></a>所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。</h4><h4 id="进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。"><a href="#进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。" class="headerlink" title="进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。"></a>进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Swaggy Q</p>
              <div class="site-description motion-element" itemprop="description">拉塞尔FMVP了吗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Swaggy Q</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
