<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拉塞尔FMVP了吗">
<meta name="keywords" content="Dloading...">
<meta property="og:type" content="website">
<meta property="og:title" content="Dloading...">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Dloading...">
<meta property="og:description" content="拉塞尔FMVP了吗">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Dloading...">
<meta name="twitter:description" content="拉塞尔FMVP了吗">





  
  
  <link rel="canonical" href="http://yoursite.com/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Dloading...</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Dloading...</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">努力成为优秀程序员</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/java动态代理机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/java动态代理机制/" class="post-title-link" itemprop="url">java的动态代理机制</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:06:41" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="java动态代理机制"><a href="#java动态代理机制" class="headerlink" title="java动态代理机制"></a>java动态代理机制</h1><p>Java中代理的实现一般分为三种：JDK静态代理、JDK动态代理以及CGLIB动态代理。在Spring的AOP实现中，主要应用了JDK动态代理以及CGLIB动态代理</p>
<p>代理一般实现的模式为JDK静态代理：创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>
<p>静态代理: 实现一个代理类，然后持有被代理类的引用。则可以在调用前后实现附加方法。但是这个方法非常不好，对多个类会很繁琐。</p>
<p>JDK静态代理是通过直接编码创建的，而JDK动态代理是利用反射机制在运行时创建代理类的。<br>JDK动态代理，注意看到Proxy类。已经提供了测试类，可以断点跟进去。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/AQS详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/AQS详解/" class="post-title-link" itemprop="url">AQS详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:47:53" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="AQS的详解"><a href="#AQS的详解" class="headerlink" title="AQS的详解"></a>AQS的详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java-util-concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。"><a href="#java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java-util-concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。" class="headerlink" title="java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java.util.concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。"></a>java的JUC包我断断续续看了零星的几个实现类，一直想写一些文章记录一下，但是由于种种原因，一是由于自己的懒惰，也因为作为一个新手，这种东西我实在没太好的文笔能表达清楚，今天我再次想冲击一下这个疑难杂症。首先说一下，AQS是一个java的java.util.concurrent包中的一个名为AbstractQueuedSynchronizer的类，简称AQS。那这个类为什么这么重要呢？因为这个JUC包中包含了几乎所有我们平时会用于控制并发的锁和并发控制类，而这个AQS更是基本所有锁的核心控制框架，所以这个类是我们学习并发的重中之重。</h4><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><h4 id="在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤"><a href="#在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤" class="headerlink" title="在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤"></a>在本系列的后面的文章中，我们会讲到，当多个线程抢占较少的资源的时候，AQS内部所做的一些关于分配资源的策略方法。在这之前我建议大家先想一下，如果由自己设计一个最简单的抢占模型，我们会怎么设计？我这边设想了一下，肯定会有下面几个步骤</h4><pre><code>1: 提供一个资源供大家抢占，假设初始状态为1，被占用后设置为0.所以假设有多个线程去获取这个资源的时候，肯定会只有一个线程能抢占成功，那么其他的线程必须按序排好。同时也要考虑到多个节点往队伍中排会出现的并发问题
2: 当上一个节点消费完成后，要将资源释放出来，然后要通知排在队伍中的第一个节点，通知他可以开始竞争资源了。</code></pre><h4 id="所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。"><a href="#所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。" class="headerlink" title="所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。"></a>所以我们可以带着这种思路来看AQS内部的实现，看是不是按照我们的设计思路来编写框架的。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。"><a href="#接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。" class="headerlink" title="接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。"></a>接下来我们直接看到AQS的内部，大致浏览一下类的内部结构。</h4><h4 id="首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。"><a href="#首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。" class="headerlink" title="首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。"></a>首先可以看到，内部有一个叫做Node的内部类实现。这个类就是用于我们之前的设计中，当线程抢占资源失败时，排在队列中的每个单元。在Node的构造函数我们可以看到除了传入了当时的线程，还传入了一个叫mode的参数。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node(Thread thread, Node mode) &#123;     // Used by addWaiter</span><br><span class="line">	this.nextWaiter = mode;</span><br><span class="line"> 			this.thread = thread;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结合了一些这个构造函数的调用链，可以看到这个mode有两种情况"><a href="#结合了一些这个构造函数的调用链，可以看到这个mode有两种情况" class="headerlink" title="结合了一些这个构造函数的调用链，可以看到这个mode有两种情况"></a>结合了一些这个构造函数的调用链，可以看到这个mode有两种情况</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">static final Node SHARED = new Node();</span><br><span class="line">/** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">static final Node EXCLUSIVE = null;</span><br></pre></td></tr></table></figure>

<h4 id="这代表抢占资源的两种模式，一种是独占式，一种是共享式。"><a href="#这代表抢占资源的两种模式，一种是独占式，一种是共享式。" class="headerlink" title="这代表抢占资源的两种模式，一种是独占式，一种是共享式。"></a>这代表抢占资源的两种模式，一种是独占式，一种是共享式。</h4><blockquote>
<p>独占模式和共享模式。处于独占模式下时，其他线程试图获取该锁将无法取得成功。在共享模式下，多个线程获取某个锁可能（但不是一定）会获得成功</p>
</blockquote>
<h4 id="这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。"><a href="#这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。" class="headerlink" title="这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。"></a>这边引入了一个Node模式的概念。我们浏览过整个AQS的代码结构就可以发现，整份代码里就是有两种模式的不同入口，分别处理不同的模式。从名字也可以看出，比如下面的四个预留的抽象方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected boolean tryAcquire(int arg)</span><br><span class="line">protected boolean tryRelease(int arg)</span><br><span class="line">protected int tryAcquireShared(int arg)</span><br><span class="line">protected boolean tryReleaseShared(int arg)</span><br></pre></td></tr></table></figure>

<h4 id="因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。"><a href="#因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。" class="headerlink" title="因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。"></a>因为之前我们也说过AQS是一个核心的并发基础框架类，内部处理了很多关于抢占资源的调度方法，同时预留了一些可以处理实际逻辑的方法，供子类处理。以上四个方法就是预留的方法。从方法名字我们也可以知道，这四个方法里面属于两个不同的模式。在单个模式的两个方法中，也分别处理了试图去获取资源和试图去释放资源的实际方法。</h4><h4 id="接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式-这个模式的获取资源和释放资源的入口方法分别的Acquire和Release"><a href="#接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式-这个模式的获取资源和释放资源的入口方法分别的Acquire和Release" class="headerlink" title="接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式,这个模式的获取资源和释放资源的入口方法分别的Acquire和Release"></a>接下来我会尽量用图的方式将这两种模式给讲清楚。好了，先讲一下独占式的模式,这个模式的获取资源和释放资源的入口方法分别的Acquire和Release</h4><h2 id="EXCLUSIVE模式"><a href="#EXCLUSIVE模式" class="headerlink" title="EXCLUSIVE模式"></a>EXCLUSIVE模式</h2><h3 id="首先我们看一下独占模式的acquire方法"><a href="#首先我们看一下独占模式的acquire方法" class="headerlink" title="首先我们看一下独占模式的acquire方法"></a>首先我们看一下独占模式的acquire方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">	// 直接调用子类复写的方法，尝试去获取资源，</span><br><span class="line">	// 若成功，则直接返回</span><br><span class="line">	// 若失败，则加入内部维护的FIFO队列中</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单看一下addWaiter方法内部"><a href="#简单看一下addWaiter方法内部" class="headerlink" title="简单看一下addWaiter方法内部"></a>简单看一下addWaiter方法内部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private Node addWaiter(Node mode) &#123;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), mode);</span><br><span class="line">    // Try the fast path of enq; backup to full enq on failure</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    // 若当前队列中已经初始化了尾节点，则会先尝试一种快速入队的方式，即</span><br><span class="line">    // 1：先获得当前队列中的尾节点，假设名字为t</span><br><span class="line">    // 2: 将当前节点的先驱节点设置为t，即将节点排在了队列的最尾端</span><br><span class="line">    // 3: 将队列的尾指针用CAS的方式，安全的指向当前节点。此处用CAS保证了线程安全</span><br><span class="line">    // 4: 之后将原尾节点的后继指针指向了当前节点，从而完成了双向确认</span><br><span class="line">    // 注意: 三个指针的操作中，之后尾指针的指向时用了CAS，其余两个都是普通的赋值操作，这边先埋个点，在之后会再讲到这个地方</span><br><span class="line">    if (pred != null) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        if (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 若之前的方法成功，则直接返回</span><br><span class="line">    // 否则就要进行比较复杂的方式</span><br><span class="line">    enq(node);</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Node enq(final Node node) &#123;</span><br><span class="line">	// 整段代码由一个永真循环包围</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        // 若第一次调用，则要初始化队列的头尾指针</span><br><span class="line">        if (t == null) &#123; // Must initialize</span><br><span class="line">            if (compareAndSetHead(new Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        	// 调用上段的逻辑，不断重试</span><br><span class="line">            node.prev = t;</span><br><span class="line">            if (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                return t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####可以看到内部就是维护了一个FIFO的队列，队列中每个节点都维护了线程，和当前等待状态以及前驱和后继节点。新节点到来时，会用CAS+自旋的方法去将节点放在等待队列中。然后在acquireQueued方法中，我们也可以看到，每个在队列中的节点，都会不断根据前驱节点的状态的改变，不断的去尝试获取资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">  final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">      boolean failed = true;</span><br><span class="line">      try &#123;</span><br><span class="line">      	// 标识线程是否中断</span><br><span class="line">          boolean interrupted = false;</span><br><span class="line">          for (;;) &#123;</span><br><span class="line">              final Node p = node.predecessor();</span><br><span class="line">              // 判断先驱节点是否为队列首节点</span><br><span class="line">              // 若是，则尝试去获取资源</span><br><span class="line">              if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">              	//	若资源获取成功了，则将当前节点设为队列首节点</span><br><span class="line">                  setHead(node);</span><br><span class="line">                  p.next = null; // help GC</span><br><span class="line">                  failed = false;</span><br><span class="line">                  return interrupted;</span><br><span class="line">              &#125;</span><br><span class="line">              // 若还没轮到竞争资源，或者竞争资源失败</span><br><span class="line">              // 每个节点都会判断自己以及前驱节点的状态是否满足当前节点是否可以park，这句话可能比较绕，可以直接先看看shouldParkAfterFailedAcquire这个方法里面做了什么</span><br><span class="line">              if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                  parkAndCheckInterrupt())</span><br><span class="line">                  interrupted = true;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          if (failed)</span><br><span class="line">              cancelAcquire(node);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	// 首先看到这个方法的返回值是一个布尔值，为true则标志当前节点可以park，会有其他节点在合适的时候将其唤醒</span><br><span class="line">  private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</span><br><span class="line">  	// 先驱节点的状态</span><br><span class="line">      int ws = pred.waitStatus;</span><br><span class="line">// 若前驱节点的状态是SIGNAL，也就是标志着当前节点在park前已经通知了前驱节点</span><br><span class="line">// 换句话说就是，前驱节点知道排在他后面的节点是park状态，那么在竞争完资源或者退出竞争之后，都会将其唤醒</span><br><span class="line">      if (ws == Node.SIGNAL)</span><br><span class="line">          /*</span><br><span class="line">           * This node has already set status asking a release</span><br><span class="line">           * to signal it, so it can safely park.</span><br><span class="line">           */</span><br><span class="line">          return true;</span><br><span class="line">      // 若前驱节点的状态已经是取消状态，则应该跳过这个节点，向前找到未取消的节点作为新的前驱节点</span><br><span class="line">      if (ws &gt; 0) &#123;</span><br><span class="line">          /*</span><br><span class="line">           * Predecessor was cancelled. Skip over predecessors and</span><br><span class="line">           * indicate retry.</span><br><span class="line">           */</span><br><span class="line">           // 如果先驱节点已经取消竞争了，则直接跳过他，查找队列前面最近的没取消的作为新的先驱节点</span><br><span class="line">          do &#123;</span><br><span class="line">              node.prev = pred = pred.prev;</span><br><span class="line">          &#125; while (pred.waitStatus &gt; 0);</span><br><span class="line">          pred.next = node;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          /*</span><br><span class="line">           * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="line">           * need a signal, but don&apos;t park yet.  Caller will need to</span><br><span class="line">           * retry to make sure it cannot acquire before parking.</span><br><span class="line">           */</span><br><span class="line">           // 若先驱节点即没取消，又没Signal，则手动将其设置为Signal，表示当前节点已经安心park，等前驱节点资源释放后，需要将其唤醒</span><br><span class="line">          compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">      &#125;</span><br><span class="line">      // 仅当先驱节点的状态是Signal的时候返回true，其他都为false</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park"><a href="#整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park" class="headerlink" title="整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park"></a>整体逻辑就是在队列中等待的节点，会不断去尝试获得资源。因为是先入先出队列，所以节点都会根据排在前面的节点的状态，来判断是不是轮到自己了。shouldParkAfterFailedAcquire方法就是用于根据前驱节点的状态来确定自己是否可以park</h4><h4 id="若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态"><a href="#若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态" class="headerlink" title="若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态"></a>若shouldParkAfterFailedAcquire方法返回了true，就是需要去park当前线程，等待先驱节点完成之后唤醒。park部分的代码就是直接调用了LockSupport的park方法，等待唤醒。唤醒可能是被前驱节点唤醒，也有可能是线程中断，所以唤醒后要检查一下线程状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="line">    LockSupport.park(this);</span><br><span class="line">    return Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。"><a href="#简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。" class="headerlink" title="简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。"></a>简单总结一下acquireQueued方法的内部逻辑。就是排在队列中的每个节点，内部都有一个永真循环去不断判断是否可以去竞争资源，或者排在前面的节点是不是放弃竞争了，如果是，则向前找到最近的没放弃的节点作为先驱节点。当先驱节点的状态已经是Signal的时候，则park当前线程，等待唤醒。</h4><h3 id="再看一下独占模式的release方法"><a href="#再看一下独占模式的release方法" class="headerlink" title="再看一下独占模式的release方法"></a>再看一下独占模式的release方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">	// 同样的，开始就去尝试释放资源，这个方法也是由子类去覆写的</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">    	//	若释放成功，则得到等待队列中的头节点，如果节点存在，则唤醒头节点后的等待者，唤醒他开始竞争资源</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">        	// 唤醒后继节点开始竞争资源</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="和acquire方法一样，里面具体的try…-方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现"><a href="#和acquire方法一样，里面具体的try…-方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现" class="headerlink" title="和acquire方法一样，里面具体的try…()方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现"></a>和acquire方法一样，里面具体的try…()方法都是抽象方法，由继承的子类来覆写逻辑。当前节点释放资源成功后，要去主动提醒后续节点。这部分的逻辑在unparkSuccessor方法中实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="line">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="line">     * fails or if status is changed by waiting thread.</span><br><span class="line">     */</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * Thread to unpark is held in successor, which is normally</span><br><span class="line">     * just the next node.  But if cancelled or apparently null,</span><br><span class="line">     * traverse backwards from tail to find the actual</span><br><span class="line">     * non-cancelled successor.</span><br><span class="line">     */</span><br><span class="line">     // 从队列的末尾向前找到后继节点中，没有取消的节点，去唤醒。</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // 找到有效的后继节点，尝试去唤醒</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？"><a href="#这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？" class="headerlink" title="这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？"></a>这边逻辑大部分都是易懂的，无非就是释放资源后，通知队列中排在后面的节点开始竞争。但是为什么倒序？</h4><h4 id="因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑"><a href="#因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑" class="headerlink" title="因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑"></a>因为考虑enq方法的时候，后继节点可能为null。也就是我们之前说的入队的时候，埋下的坑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (pred != null) &#123;</span><br><span class="line">    node.prev = pred;                    1</span><br><span class="line">    if (compareAndSetTail(pred, node)) &#123; 2</span><br><span class="line">        pred.next = node;                3</span><br><span class="line">        return node;                     4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况"><a href="#观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况" class="headerlink" title="观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况"></a>观察这段代码，其中只有在2的时候，是用CAS，保证尾指针指向了新加入的节点。而且在CAS之前，已经将当前节点的前驱节点设置为了原来的尾指针。CAS完成后，进行3。这边是一个简单的赋值语句。所以考虑这么一种情况</h4><ul>
<li><p>当2步骤完成时，由于是多线程。此时如果调度到了别的线程的release方法。若按照正常的正序查找后继结点。可以发现由于3步骤还没执行，原尾节点是没有后继节点的。那么就会认为队列已经空了，这显然是不对的。</p>
</li>
<li><p>但是由于尾指针的指向时CAS操作的，所以由尾指针作为入口，肯定是没问题的</p>
</li>
<li><p>倒序查找还跟CANCEL操作的时候有关，这部分可以直接看我文章下面的链接。写的非常好，我写不出那么好，就不班门弄斧了</p>
<h4 id="这里注意几点细节。"><a href="#这里注意几点细节。" class="headerlink" title="这里注意几点细节。"></a>这里注意几点细节。</h4></li>
<li><p>当前节点释放资源成功后，要去唤醒队伍中排在后面的人去消费。按常理来说，应该就是排在后面的那个节点，但是由于每个节点都有可能取消竞争状态，所以要跳过这种节点，以及跳过为空的节点</p>
</li>
<li><p>查找的时候要从队伍的末尾往前查找</p>
</li>
</ul>
<h4 id="唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程"><a href="#唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程" class="headerlink" title="唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程"></a>唤醒成功后，就完成了释放资源的过程。之前park住的线程会被唤醒，继续他的竞争资源的过程</h4><h3 id="共享模式的acquire方法"><a href="#共享模式的acquire方法" class="headerlink" title="共享模式的acquire方法"></a>共享模式的acquire方法</h3><h4 id="上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。"><a href="#上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。" class="headerlink" title="上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。"></a>上面说完了独占模式下，资源竞争的问题，现在我们再看看另一种共享模式下有什么不一样。</h4><h4 id="之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？"><a href="#之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？" class="headerlink" title="之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？"></a>之前也说过，共享模式就是允许多个线程同时占有资源的情形。那这个acquireShared方法是怎么实现的呢？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同"><a href="#回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同" class="headerlink" title="回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同"></a>回想一下之前说的独占模式的acquire方法。可以很明显的看到几点不同</h4><ul>
<li>独占模式下try…()方法返回的是一个布尔值，直接确定是否抢占到了资源。而在共享模式下，返回的是一个int值，为负数的时候则表明抢占失败</li>
<li>共享模式这边少了一句 selfInterrupt()</li>
</ul>
<h4 id="和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占"><a href="#和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占" class="headerlink" title="和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占"></a>和独占模式一样，如果尝试获取失败，会在队列中新建一个节点，持续等待机会去抢占</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private void doAcquireShared(int arg) &#123;</span><br><span class="line">	// 注意这里的Node的模式已经是SHARED了</span><br><span class="line">       final Node node = addWaiter(Node.SHARED);</span><br><span class="line">       boolean failed = true;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               if (p == head) &#123;</span><br><span class="line">               	// 同样的，注意这个返回是一个int值</span><br><span class="line">                   int r = tryAcquireShared(arg);</span><br><span class="line">                  // 返回值是正数，代表获取成功</span><br><span class="line">                   if (r &gt;= 0) &#123;</span><br><span class="line">                   	// 这是共享模式独有的Node状态</span><br><span class="line">                       setHeadAndPropagate(node, r);</span><br><span class="line">                       p.next = null; // help GC</span><br><span class="line">                       if (interrupted)</span><br><span class="line">                           selfInterrupt();</span><br><span class="line">                       failed = false;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           if (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么"><a href="#大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么" class="headerlink" title="大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么"></a>大部分逻辑和独占模式的时候差不多，独有的代码部分就是返回值为int以及setHeadAndPropagate这个方法，我们再看看这个方法里面做了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> private void setHeadAndPropagate(Node node, int propagate) &#123;</span><br><span class="line">     Node h = head; // Record old head for check below</span><br><span class="line">     setHead(node);</span><br><span class="line">     // 这是和独占模式有区别的地方，在共享模式中，当设置完头节点之后，还要考虑是否还有唤醒后面的节点继续抢占</span><br><span class="line">     // 1:当prop参数大于0,即表示资源还要剩余</span><br><span class="line">     // 2:当原头节点为null或者已被标注为SIGNAL模式，就表示后继节点待被唤醒</span><br><span class="line">// 3:当现头节点为null或者已被标注为SIGNAL模式，就表示后继节点待被唤醒</span><br><span class="line"></span><br><span class="line">     if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 ||</span><br><span class="line">         (h = head) == null || h.waitStatus &lt; 0) &#123;</span><br><span class="line">         Node s = node.next;</span><br><span class="line">         if (s == null || s.isShared())</span><br><span class="line">             doReleaseShared();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源"><a href="#和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源" class="headerlink" title="和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源"></a>和独占模式的区别只是在因为共享模式允许多个线程同时占有资源，所以当一个线程竞争到资源时，其他线程仍可以被唤醒去竞争。接下来看看共享模式怎么去释放资源</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源"><a href="#具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源" class="headerlink" title="具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源"></a>具体的逻辑也和独占模式差不多，依旧是倒序的查找后继结点去唤醒。但是注意共享模式多了一个叫PROPAGATE的模式，表示在队列中的节点都可以依次被唤醒去竞争资源</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。"><a href="#综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。" class="headerlink" title="综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。"></a>综上，用大篇幅详解了AQS的主要两个模式的竞争和释放资源的过程。</h4><h2 id="超链接："><a href="#超链接：" class="headerlink" title="超链接："></a>超链接：</h2><p><a href="http://www.ideabuffer.cn/2017/03/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">关于为何倒序查找的Cancel方法论证</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ArrayBlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ArrayBlockingQueue/" class="post-title-link" itemprop="url">ArrayBlockQueue源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:05:17" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="本文讲一下ArrayBlockingQueue-下文简称ABQ-的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。"><a href="#本文讲一下ArrayBlockingQueue-下文简称ABQ-的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。" class="headerlink" title="本文讲一下ArrayBlockingQueue(下文简称ABQ)的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。"></a>本文讲一下ArrayBlockingQueue(下文简称ABQ)的一些原理，整理一下之前有点混乱的几个方法，具体ABQ是什么我就不详细说了。</h4><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><h4 id="照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue-int-boolean-方法。其他两个都是之后调用这个方法。所以直接看看这个方法"><a href="#照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue-int-boolean-方法。其他两个都是之后调用这个方法。所以直接看看这个方法" class="headerlink" title="照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue(int , boolean)方法。其他两个都是之后调用这个方法。所以直接看看这个方法"></a>照例先看看怎么创建这个我们需要的这个数据结构。有三个构造函数，简单看一下可以看到重点的是ArrayBlockingQueue(int , boolean)方法。其他两个都是之后调用这个方法。所以直接看看这个方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayBlockingQueue(int capacity, boolean fair) &#123;</span><br><span class="line">	// 校验容量不能是负数</span><br><span class="line">    if (capacity &lt;= 0)</span><br><span class="line">        throw new IllegalArgumentException();</span><br><span class="line">    //</span><br><span class="line">    this.items = new Object[capacity];</span><br><span class="line">    lock = new ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ArrayList与LinkedList的实现和区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ArrayList与LinkedList的实现和区别/" class="post-title-link" itemprop="url">ArrayList与LinkedList的实现和区别</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:04:42" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayList与LinkedList的实现和区别"><a href="#ArrayList与LinkedList的实现和区别" class="headerlink" title="ArrayList与LinkedList的实现和区别"></a>ArrayList与LinkedList的实现和区别</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h4 id="LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。"><a href="#LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。" class="headerlink" title="LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。"></a>LinkedList实现了Deque的接口，即代表可以在首尾均可进行操作。类中有两个属性，first和last，分别指向链表的首和尾。</h4><h4 id="在类内部还实现了一个链表节点Node，存储val，pre，next"><a href="#在类内部还实现了一个链表节点Node，存储val，pre，next" class="headerlink" title="在类内部还实现了一个链表节点Node，存储val，pre，next"></a>在类内部还实现了一个链表节点Node，存储val，pre，next</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">       E item;</span><br><span class="line">       Node&lt;E&gt; next;</span><br><span class="line">       Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">       Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">           this.item = element;</span><br><span class="line">           this.next = next;</span><br><span class="line">           this.prev = prev;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkLast-方法-在最尾端插入节点"><a href="#linkLast-方法-在最尾端插入节点" class="headerlink" title="linkLast() 方法,在最尾端插入节点"></a>linkLast() 方法,在最尾端插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkFirst-方法，在最首端插入节点"><a href="#linkFirst-方法，在最首端插入节点" class="headerlink" title="linkFirst() 方法，在最首端插入节点"></a>linkFirst() 方法，在最首端插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">       // assert succ != null;</span><br><span class="line">       final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       if (pred == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="linkBefore-方法，在指定位置插入节点"><a href="#linkBefore-方法，在指定位置插入节点" class="headerlink" title="linkBefore() 方法，在指定位置插入节点"></a>linkBefore() 方法，在指定位置插入节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void linkBefore(E e, Node&lt;E&gt; succ) &#123;</span><br><span class="line">       // assert succ != null;</span><br><span class="line">       final Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">       final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);</span><br><span class="line">       succ.prev = newNode;</span><br><span class="line">       if (pred == null)</span><br><span class="line">           first = newNode;</span><br><span class="line">       else</span><br><span class="line">           pred.next = newNode;</span><br><span class="line">       size++;</span><br><span class="line">       modCount++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如"><a href="#以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如" class="headerlink" title="以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如"></a>以上三个就是类中的灵魂方法，其他的新增节点的方法均会调用到以上三个，例如</h4><h4 id="add-方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast"><a href="#add-方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast" class="headerlink" title="add()方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast"></a>add()方法，等同于offer方法。直接在尾部插入节点，直接调用linkLast</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">       linkLast(e);</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="add-int-index-E-element-方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore"><a href="#add-int-index-E-element-方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore" class="headerlink" title="add(int index, E element)方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore"></a>add(int index, E element)方法，在指定的位置插入节点，会先判断插入的位置是不是已经大于了链表长度了，再调用linkBefore</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">       checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">       if (index == size)</span><br><span class="line">           linkLast(element);</span><br><span class="line">       else</span><br><span class="line">           linkBefore(element, node(index));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 从前向后，或者从后向前</span><br><span class="line">   Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">       // assert isElementIndex(index);</span><br><span class="line"></span><br><span class="line">       if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">           Node&lt;E&gt; x = first;</span><br><span class="line">           for (int i = 0; i &lt; index; i++)</span><br><span class="line">               x = x.next;</span><br><span class="line">           return x;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           Node&lt;E&gt; x = last;</span><br><span class="line">           for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">               x = x.prev;</span><br><span class="line">           return x;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="再看到对首部进行操作。即push方法，或者offerFirst-最终会调用linkFirst方法"><a href="#再看到对首部进行操作。即push方法，或者offerFirst-最终会调用linkFirst方法" class="headerlink" title="再看到对首部进行操作。即push方法，或者offerFirst,最终会调用linkFirst方法"></a>再看到对首部进行操作。即push方法，或者offerFirst,最终会调用linkFirst方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void push(E e) &#123;</span><br><span class="line">      addFirst(e);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void addFirst(E e) &#123;</span><br><span class="line">      linkFirst(e);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashTable,HashMap,ConcurrentHashMap 横向对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashTable,HashMap,ConcurrentHashMap 横向对比/" class="post-title-link" itemprop="url">HashTable，HashMap，CocurrentHashMap横向对比</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:07:07" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashTable-HashMap-ConcurrentHashMap-横向对比"><a href="#HashTable-HashMap-ConcurrentHashMap-横向对比" class="headerlink" title="HashTable,HashMap,ConcurrentHashMap 横向对比"></a>HashTable,HashMap,ConcurrentHashMap 横向对比</h1><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>int index = (key.hashcode &amp; 0x7fffffff) % tab.length</code></pre><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>int index = (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
最终的桶位值还需要 index &amp; (tab.length -1)</code></pre><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>int index = (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16)) &amp; 0x7fffffff;
最终的桶位值还需要 index &amp; (tab.length -1)</code></pre><h2 id="k，v能否为null"><a href="#k，v能否为null" class="headerlink" title="k，v能否为null"></a>k，v能否为null</h2><h3 id="HashTable-1"><a href="#HashTable-1" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>k，v均不能为null，v是因为在代码中判断，k是因为null.hashcode()会报错</code></pre><h3 id="HashMap-1"><a href="#HashMap-1" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>k,v均可以为null。 且k为null时，会自动分配其为0号桶位</code></pre><h3 id="ConcurrentHashMap-1"><a href="#ConcurrentHashMap-1" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><pre><code>k，v均不能为null，强行校验</code></pre><h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><h3 id="HashTable-2"><a href="#HashTable-2" class="headerlink" title="HashTable"></a>HashTable</h3><pre><code>在put值到底层tab前，会先进行一次count&gt;=threshold的判断，若是，则先直接进行rehash(),再将k,v放到扩容后的tab中
扩容后的newsize = (oldsize * 2) +1
倒序遍历oldtab中的每一个桶位，并用首插法的方式，将元素插入到newtab中
整个过程由synchronized强加锁，避免并发问题</code></pre><h3 id="HashMap-2"><a href="#HashMap-2" class="headerlink" title="HashMap"></a>HashMap</h3><pre><code>在put值到tab之后，才会进行容量检查，若(++size &gt; threshold)，则进行扩容
扩容后的newsize = (oldsize * 2)，保持每次底层tab的容量都为2的幂次方
顺序遍历oldtab，然后将元素放置在相应的位置，改为尾插法
且根据bit直接计算对应所在的位置
整个过程，不做并发控制，所以会有并发问题</code></pre><h3 id="ConcurrentHashMap-2"><a href="#ConcurrentHashMap-2" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashMap 1.7 版本的transfer方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashMap 1.7 版本的transfer方法/" class="post-title-link" itemprop="url">HashMap 1.7 版本的transfer方法</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:07:31" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HashMap-1-7-版本的transfer方法"><a href="#HashMap-1-7-版本的transfer方法" class="headerlink" title="HashMap 1.7 版本的transfer方法"></a>HashMap 1.7 版本的transfer方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void transfer(Entry[] newTable) &#123;</span><br><span class="line">     Entry[] src = table; </span><br><span class="line"></span><br><span class="line">     int newCapacity = newTable.length;</span><br><span class="line"></span><br><span class="line">     for (int j = 0; j &lt; src.length; j++) &#123; </span><br><span class="line">         Entry&lt;K,V&gt; e = src[j];           </span><br><span class="line">         if (e != null) &#123;</span><br><span class="line">             src[j] = null; </span><br><span class="line"></span><br><span class="line">             do &#123; </span><br><span class="line">                Entry&lt;K,V&gt; next = e.next; </span><br><span class="line">                int i = indexFor(e.hash, newCapacity); </span><br><span class="line">                e.next = newTable[i]; </span><br><span class="line">                newTable[i] = e;  </span><br><span class="line">                e = next;             </span><br><span class="line">            &#125; while (e != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> static int indexFor(int h, int length) &#123;  </span><br><span class="line">         return h &amp; (length-1); </span><br><span class="line">  	 &#125;</span><br></pre></td></tr></table></figure>

<p>newTable和src<br>遍历src中的所有桶位，如果存在链表节点，则需要遍历所有节点，用首插法的方式，将节点都移动到新的数组中。这边举一个例子，假设初始数组大小是2</p>
<p><img src="img/HashMapDeadLoop.png" alt="数组死锁"><br>线程1开始后，线程2开始transfer，并已经结束。就会造成死循环<br><img src="img/HashMapDeadLoop2.png" alt="数组死锁"><br>这时候如果调用get方法，则会一直在死循环中</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/G1回收器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/G1回收器/" class="post-title-link" itemprop="url">G1回收器</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:42:12" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="G1回收器"><a href="#G1回收器" class="headerlink" title="G1回收器"></a>G1回收器</h1><p>CSet：一系列分区的集合，也是在垃圾收集过程中被回收的目标</p>
<p>年轻代收集（young gc）：CSet里全部都是年轻代分区的收集</p>
<p>混合收集（mixed gc）：CSet里包括年轻代分区和一部分老年代分区的收集</p>
<p>-XX:InitiatingHeapOccupancyPercent：在G1中，IHOP的值是老年代空间占Java堆总空间的比例<br>-XX:G1MixedGCCountTarget：一个混合收集周期中包含多少次混合收集<br>-XX:G1HeapWastePercent：堆浪费百分比，当G1发现可被回收的空间小于5%时，就不会再进行混合收集，也就是会结束当前的混合收集周期</p>
<p>常规的垃圾收集器（串行，并行，CMS）都将堆结构分为三个部分：年轻代，老年代和固定大小的永久代。</p>
<p>G1整个颠覆了之前的的新生代和老年代的紧凑分布，将内存分为了不同的区</p>
<p>被G1标识成熟的区域是通过转移的方式收集。G1将对象从堆的一个或多个区域复制到堆上的单个区域，并且在此过程中，同时压缩和释放内存。这种转移方法在并行运行在多处理器上，以减少暂停时间并提高吞吐量</p>
<p>CMS垃圾收集器不执行内存压缩，ParallelOld垃圾收集器执行全堆压缩，这将导致很大的暂停时间。</p>
<p>Remembered Sets (RSets)跟踪对象引用到给定的区域。堆中每个区域有一个RSet。 RSet使GC能并行和独立地收集一个区域。 RSets的整体性能影响小于5％<br>Collection Sets (CSets)是GC中将要被收集的一组区域。GC中的所有存活数据在GC期间转移（复制/移动）。这些集合可能是eden区，survivor区或者老年代，CSets对JVM的大小影响不到1％。</p>
<p>G1的推荐用例<br>G1的第一个重要特点是为用户的应用程序的提供一个低GC延时和大内存GC的解决方案。这意味着堆大小6GB或更大，稳定和可预测的暂停时间将低于0.5秒。</p>
<p>如果应用程序使用CMS或ParallelOld垃圾回收器具有一个或多个以下特征，将有利于切换到G1：</p>
<p>Full GC持续时间太长或太频繁<br>对象分配率或年轻代升级老年代很频繁<br>不期望的很长的垃圾收集时间或压缩暂停（超过0.5至1秒）</p>
<p>存活对象从Eden区和一个survivor区拷贝到另一个survivor区，任何一个“年龄”达到阈值的对象会被晋升到老年代。</p>
<p>主要困惑点： 何时并发何时并行何时stw，和cms的区别，Rset Cset CardTable重点怎么用着三个</p>
<blockquote>
<p>CMS和G1算法都涉及对可达对象的并发标记。并发标记的主要问题是collector在标记对象的过程中mutator可能正在改变对象引用关系图，从而造成漏标和错标。错标不会影响程序的正确性，只是造成所谓的浮动垃圾。但漏标则会导致可达对象被当做垃圾收集掉，从而影响程序的正确性。<br>为解决漏标问题，GC Handbook一书首先将对象分为三类，即所谓的black对象，grey对象和white对象。white对象是那些还没有被collector标记到的对象；grey对象是那些自身已经被标记到，但其所有引用字段还没有处理的对象；而black对象则是自身已经被标记到，且其引用的所有对象也已经被标记的对象。 </p>
</blockquote>
<p>基于上述分类，一个white对象在并发标记阶段会被漏标的充分必要条件是：<br>1、mutator插入了一个从black对象到该white对象的新引用<br>2、mutator删除了所有从grey对象到该white对象的直接或者间接引用。<br>因此，要避免对象的漏标，只需要打破上述2个条件中的任何一个即可。 </p>
<p>Incremental update关注的是第一个条件的打破，即引用关系的插入。Incremental update利用write barrier将所有新插入的引用关系都记录下来，最后以这些引用关系的src为根STW地重新扫描一遍即避免了漏标问题。<br>SATB关注的是第二个条件的打破，即引用关系的删除。SATB利用pre write barrier将所有即将被删除的引用关系的旧引用记录下来，最后以这些旧引用为根STW地重新扫描一遍即可避免漏标问题。 </p>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><h4 id="一种标记的算法，黑灰白"><a href="#一种标记的算法，黑灰白" class="headerlink" title="一种标记的算法，黑灰白"></a>一种标记的算法，黑灰白</h4><h4 id="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"><a href="#G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。" class="headerlink" title="G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。"></a>G1和CMS都是并发是收集器，所以需要处理在标记的时候，程序改动造成的对象的漏标。</h4><p>很显然，此时C是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC标记的对象不丢失呢？有如下2中可行的方式：</p>
<p>在插入的时候记录对象<br>在删除的时候记录对象<br>刚好这对应CMS和G1的2种不同实现方式：<br>刚好这对应CMS和G1的2种不同实现方式：</p>
<p>在CMS采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p>
<p>在G1中，使用的是STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有3个步骤：</p>
<p>1，在开始标记的时候生成一个快照图标记存活对象</p>
<p>2，在并发标记的时候所有被改变的对象入队（在write barrier里把所有旧的引用所指向的对象都变成非白的）</p>
<p>3，可能存在游离的垃圾，将在下次被收集<br></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/HashTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/HashTable/" class="post-title-link" itemprop="url">HashTable源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:04:30" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊一聊HashTable"><a href="#聊一聊HashTable" class="headerlink" title="聊一聊HashTable"></a>聊一聊HashTable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"><a href="#关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下" class="headerlink" title="关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下"></a>关于HashTable，今天想深入的看一下源码实现，通过其暴露的接口方法，看看他内部实现的原理。并和HashMap简单对比一下</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"><a href="#大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？" class="headerlink" title="大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？"></a>大家都知道HashTable简单来说，就是一个存储kv键值对的一个数据结构。用put方法放进去，用get方法拿出来。那内部到底是做了什么样的操作，可以做到这个方便又快速的存储呢？</h4><h4 id="这边用一个小例子作为入口，我们可以进去一探究竟"><a href="#这边用一个小例子作为入口，我们可以进去一探究竟" class="headerlink" title="这边用一个小例子作为入口，我们可以进去一探究竟"></a>这边用一个小例子作为入口，我们可以进去一探究竟</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    // 初始化</span><br><span class="line">    Hashtable hb = new Hashtable();</span><br><span class="line">    // 存储</span><br><span class="line">    hb.put(&quot;1&quot;,new Integer(1));</span><br><span class="line">    hb.put(&quot;2&quot;,new Integer(2));</span><br><span class="line">    hb.put(&quot;3&quot;,new Integer(3));</span><br><span class="line">    // 取值</span><br><span class="line">    System.out.println(hb.get(&quot;1&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;2&quot;));</span><br><span class="line">    System.out.println(hb.get(&quot;3&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"><a href="#这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。" class="headerlink" title="这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。"></a>这边写了一个最简单的例子。例子包括三部分，在注释中也有指出。</h4><ul>
<li>初始化 </li>
<li>存储</li>
<li>取值</li>
</ul>
<h4 id="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"><a href="#这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现" class="headerlink" title="这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现"></a>这三个步骤也是我们平时用到的流程，本文就会根据这三个小块来探究一下内部的实现</h4><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h4 id="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"><a href="#当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。" class="headerlink" title="当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。"></a>当我们想要使用一个HashTable的时候，最显而易见的就是我们会先new一个实例化对象出来。这样我们才会有对象可操作，那么就先看看这个构造函数。</h4><h1 id="TODO-构造函数截图"><a href="#TODO-构造函数截图" class="headerlink" title="TODO 构造函数截图"></a>TODO 构造函数截图</h1><h4 id="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"><a href="#从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable-int-float-这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。" class="headerlink" title="从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。"></a>从这个图中也可以看到，总共提供了四种不同的构造函数。其实当我们看过实现之后我们可以发现，其实四个不同的方法最终都是调用了Hashtable(int, float) 这个方法，其他构造方法只是提供了一些默认参数而已。所以我们直接先看到这个方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public Hashtable(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);</span><br><span class="line"></span><br><span class="line">    if (initialCapacity==0)</span><br><span class="line">        initialCapacity = 1;</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    // 上面的代码主要对参数的格式做了一些检验，例如initialCapacity不能为负数，而且最小也必须是1，</span><br><span class="line">    // loadFactor 必须是大于零的浮点数</span><br><span class="line">    </span><br><span class="line">    // 再根据initialCapacity参数创建一个Entry数组</span><br><span class="line">    table = new Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    // 初始化threshold，(两个参数的乘积)和(Int最大值-8)中的较小值</span><br><span class="line">    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。"><a href="#这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11-0-75f。" class="headerlink" title="这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。"></a>这样我们就完成了HashTable的部分参数初始化的工作。可以看到主要是创建了一个Entry的数组。另外如果我们使用的是无参数的构造函数，那么这两个的参数的默认值为11, 0.75f。</h4><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h4 id="现在我们看一下当我们put的时候，内部发生了什么"><a href="#现在我们看一下当我们put的时候，内部发生了什么" class="headerlink" title="现在我们看一下当我们put的时候，内部发生了什么"></a>现在我们看一下当我们put的时候，内部发生了什么</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 可以看到这个方法名上加了synchronized，这和在HashMap上是有不一样的地方</span><br><span class="line">   public synchronized V put(K key, V value) &#123;</span><br><span class="line">       // Make sure the value is not null</span><br><span class="line">       if (value == null) &#123;</span><br><span class="line">           throw new NullPointerException();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // Makes sure the key is not already in the hashtable.</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       // 会取传入的键的Hashcode，所以每个字符串的Hashcode都是一样的</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       // 通过计算得到当前键在Entry数组中的下标</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">       // 取出在数组中指定下标已存在的值，指定下标取出来可能是一个链表，在Entry中存有链表后继结点的引用</span><br><span class="line">       Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">       for(; entry != null ; entry = entry.next) &#123;</span><br><span class="line">       	// 必须双重判断hash值一样，而且键值内容一样，才能说明传入的key已存在</span><br><span class="line">           if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">           	// 若已存在，则替换新传入的值，并返回旧值</span><br><span class="line">               V old = entry.value;</span><br><span class="line">               entry.value = value;</span><br><span class="line">               return old;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">	// 若key在原结构中不存在，则需要新增</span><br><span class="line">       addEntry(hash, key, value, index);</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="继续看看往存储结构中新增一个key的时候做了什么操作"><a href="#继续看看往存储结构中新增一个key的时候做了什么操作" class="headerlink" title="继续看看往存储结构中新增一个key的时候做了什么操作"></a>继续看看往存储结构中新增一个key的时候做了什么操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void addEntry(int hash, K key, V value, int index) &#123;</span><br><span class="line">	// 这个字段作为修改的一个version值做后续的版本控制</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">	// count是当前数组中已有的Entry的数目</span><br><span class="line">	// 如果比原定的threshold要大，则需要重新进行一次hash重分配</span><br><span class="line">    if (count &gt;= threshold) &#123;</span><br><span class="line">        // Rehash the table if the threshold is exceeded</span><br><span class="line">        rehash();</span><br><span class="line"></span><br><span class="line">        tab = table;</span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Creates the new entry.</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    // 在Entry数组对应的index的位置创建一个值，并把可能原有的值作为新增节点在链表中的后继结点存储，所以在链表中是新的节点排在链表前面</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    tab[index] = new Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。"><a href="#新增部分也容易理解，主要还是数组-链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash-的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0-75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0-75为前提。" class="headerlink" title="新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。"></a>新增部分也容易理解，主要还是数组+链表的格式。可以看到在过程中已经限定了k，v都不能为空。这边留了一个概念没讲，就是这个rehash()的过程。在初始化的时候，我们定义了threshold这个int类型的参数。这个的概念就是，假设我们数组的最大可容纳数目为11个，loadFactor为0.75，那么当数目达到了8个的时候，我们就要进行一次rehash，避免数目过大影响性能。现在具体看看rehash过程。以下过程内容，都按照默认值11，0.75为前提。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">protected void rehash() &#123;</span><br><span class="line">	// old容量 默认为11</span><br><span class="line">       int oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">       // overflow-conscious code</span><br><span class="line">       // new容量 = (11 &lt;&lt; 1) + 1 = 23 </span><br><span class="line">       int newCapacity = (oldCapacity &lt;&lt; 1) + 1;</span><br><span class="line">       // MAX_ARRAY_SIZE 是Int.max - 8， 如果新的容量比这个数值还要大的话，要进行进一步的考量</span><br><span class="line">       if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123;</span><br><span class="line">           if (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               // Keep running with MAX_ARRAY_SIZE buckets</span><br><span class="line">               return;</span><br><span class="line">           newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       // 用新的容量创建一个新的数组</span><br><span class="line">       Entry&lt;?,?&gt;[] newMap = new Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       // 重新计算threshold</span><br><span class="line">       threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);</span><br><span class="line">       table = newMap;</span><br><span class="line">	// 从原有数组的末尾，从后往前扫描每一个节点，按照新的容量计算新的index。</span><br><span class="line">       for (int i = oldCapacity ; i-- &gt; 0 ;) &#123;</span><br><span class="line">           for (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != null ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;</span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">               newMap[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"><a href="#好的，现在也大概吧put梳理了一下。整体大概就是用一种数组-链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程" class="headerlink" title="好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程"></a>好的，现在也大概吧put梳理了一下。整体大概就是用一种数组+链表的方式存储我们的节点，并在必要时刻进行重新整理，接下来我们看看取值的过程</h4><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 同样是一个同步的方法</span><br><span class="line">   public synchronized V get(Object key) &#123;</span><br><span class="line">   	// 整个方法是不是似曾相识？在我们第二步的存储的代码中，已经包含了这一部分代码。当时是为了确定存入的值是否已经存在。所以这边也不赘述了</span><br><span class="line">       Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">       int hash = key.hashCode();</span><br><span class="line">       int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br><span class="line">       for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123;</span><br><span class="line">           if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">               return (V)e.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"><a href="#大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。" class="headerlink" title="大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。"></a>大致梳理了一下HashTable的几个关键流程，有一些细节还没有讲到。之后会再写一篇关于HashMap的文章，在那边可以横向对比一下这两者之间的区别。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/JVM的各个分区/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/JVM的各个分区/" class="post-title-link" itemprop="url">JVM的各个分区</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:41:49" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JVM的各个分区"><a href="#JVM的各个分区" class="headerlink" title="JVM的各个分区"></a>JVM的各个分区</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。"><a href="#最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。" class="headerlink" title="最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。"></a>最近在看JVM的书籍，避免看过就忘了。所以想用文字记录一下。本文会讲一下我理解的JVM中的各个分区。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="现在直接概括一下JVM中到底有哪些分区"><a href="#现在直接概括一下JVM中到底有哪些分区" class="headerlink" title="现在直接概括一下JVM中到底有哪些分区"></a>现在直接概括一下JVM中到底有哪些分区</h4><ul>
<li>堆 (线程共享) (GC的主要发生区)</li>
<li>栈 (细分为虚拟机栈和本地方法栈) (线程独占) </li>
<li>方法区 (non-heap) (线程共享) (内部还包含了一个运行时常量区)</li>
<li>程序计数器 (线程独占)</li>
</ul>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h4 id="堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。"><a href="#堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。" class="headerlink" title="堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。"></a>堆是JVM最大的一块区域。主要是用于存储代码中存储的各个对象。由于是虚拟机中分配的最大的一块区域，所以也是GC发生的最主要的区域。</h4><h4 id="堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8-1-1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配"><a href="#堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8-1-1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配" class="headerlink" title="堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8:1:1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配"></a>堆内部还可以再划分为Eden区，survivorTo区，survivorFrom区。三个区的大小比例最好是8:1:1。当然这些大小都是可以由用户自主的定义大小。有几个参数可供调配</h4><ul>
<li>-Xmx 堆的最大内存</li>
<li>-Xms 堆的最小内存</li>
</ul>
<h4 id="可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM"><a href="#可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM" class="headerlink" title="可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM"></a>可以看到堆的可以由伸缩范围的，而且在实际的物理内存中，堆可以不是连续的，只要是逻辑连续就可以了。但是若对象分配的总大小已经大过了最大内存。则会报OutOfMemoryError。也就是我们常见的OOM</h4><h4 id="因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。"><a href="#因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。" class="headerlink" title="因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。"></a>因为堆中会不停的发生不同程度的GC，由于不同的GC算法的实际方法有所不同。</h4><h4 id="有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。"><a href="#有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。" class="headerlink" title="有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。"></a>有采用compact算法的Serial，Parnew的GC，会将堆中空闲的内存块都统一合并成一大块，那么对象在创建分配内存的时候，只需要采用指针碰撞的方法，将符合要求的一块内存块的收尾指针移动一下，就可以看做分配给了新创建的对象。</h4><h4 id="采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了"><a href="#采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了" class="headerlink" title="采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了"></a>采用Maek-sweep算法的CMS的GC，只是维护了一个空闲内存块的表格，所以在对象分配的时候直接在表中寻找到一块最适合的分配就行了</h4><h4 id="以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS-重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。"><a href="#以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS-重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。" class="headerlink" title="以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS+重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。"></a>以上两种都是非常常见的方式，但是在采用指针碰撞的时候，要注意并发问题。也就是若同时有两个对象内存需要分配，则要注意指针的移动。一般会采用CAS+重试的方式，保证内存分配的无误。也有一种方式是，为每个线程都预先分配一块内存，叫做TLAB，所以每个线程都可以在自己的内存中无措的分配，只有在新分配TLAB的时候才需要错定内存块。</h4><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。"><a href="#栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。" class="headerlink" title="栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。"></a>栈也是我们在学校学习的时候，经常听到的一个词。但是其实在JVM定义的时候，栈是有两块组成的，一个叫做虚拟机栈，一个叫做本地方法栈。顾名思义我们也可以看出两个的不同就是本地方法栈存储的都是一些native的方法。但是在HotSpot的虚拟机的实现方法中，其实这两块也是合二为一的。</h4><h4 id="那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？"><a href="#那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？" class="headerlink" title="那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？"></a>那什么叫做存储的是方法呢？方法又是以什么样是形式存在栈中的呢？</h4><h4 id="其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError"><a href="#其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError" class="headerlink" title="其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError"></a>其实存储在栈中的单位叫做栈帧，每个栈帧里面保存的是方法中的局部变量表，操作数，动态链接，方法出口等信息。每个栈帧的入栈表示执行当前方法，出栈表示完成了当前方法。所以当我们在一个方法里递归调用了自己，就会导致不断有新的栈帧入栈，但是没有出栈，就会造成最后达到了栈的最大深度。就会报出StackOverFlowError</h4><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h4 id="程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了"><a href="#程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了" class="headerlink" title="程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了"></a>程序计数器就是每个线程都独有的一个寄存器，记录了每个线程目前执行到了哪个语句，那么当cpu在调度别的线程的时候，能将当前进度保存下来。当再度调度到的时候，也就可以继续之前的工作了</h4><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h4 id="方法区在jdk-1-7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String-intern-方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。"><a href="#方法区在jdk-1-7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String-intern-方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。" class="headerlink" title="方法区在jdk 1.7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String.intern()方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。"></a>方法区在jdk 1.7中可以类比于永久代。其实按书上所说这两者并不完全相同，只是jvm作者用永久代的实现方式实现了方法区而已。在方法区中存储的主要是类的属性方法，基本不进行GC，因为在这个区内GC的成果很低，因为这些常量不会很经常被卸载。这个方法区中还有一个叫做运行时常量区的地方，我们最常用到这块地方就是我们调用String.intern()方法。这个方法会将这个String作为常量保存在这个运行时常量区内。这边还有关于这个方法的小例子。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    String str1 = new StringBuilder(&quot;ab&quot;).append(&quot;cd&quot;).toString();</span><br><span class="line">    System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">    String str2 = new StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString();</span><br><span class="line">    System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="这个小例子在jdk1-7的版本下运行会返回true，false。但是在jdk1-6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下-lt-深入理解java虚拟机-gt-一书的2-4-3小节"><a href="#这个小例子在jdk1-7的版本下运行会返回true，false。但是在jdk1-6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下-lt-深入理解java虚拟机-gt-一书的2-4-3小节" class="headerlink" title="这个小例子在jdk1.7的版本下运行会返回true，false。但是在jdk1.6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下&lt;深入理解java虚拟机&gt;一书的2.4.3小节"></a>这个小例子在jdk1.7的版本下运行会返回true，false。但是在jdk1.6版本下运行会出现false，false。这也是因为两个版本的jdk对intern方法实现变量到运行时常量区的方式的不同。具体原理感兴趣的可以参考一下&lt;深入理解java虚拟机&gt;一书的2.4.3小节</h4><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。"><a href="#本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。" class="headerlink" title="本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。"></a>本文简单叙述了一下我理解的jvm内存格局，里面提到的GC方式，会在下一篇文章中再做叙述。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/08/ReentrantLock源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Swaggy Q">
      <meta itemprop="description" content="拉塞尔FMVP了吗">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dloading...">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/07/08/ReentrantLock源码解析/" class="post-title-link" itemprop="url">ReetrantLock源码详解</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-07-08 22:59:25 / Modified: 23:06:24" itemprop="dateCreated datePublished" datetime="2019-07-08T22:59:25+08:00">2019-07-08</time>
            </span>
          

          
            

            
          

          

          
            
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ReentrantLock源码详解"><a href="#ReentrantLock源码详解" class="headerlink" title="ReentrantLock源码详解"></a>ReentrantLock源码详解</h1><h2 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h2><h4 id="之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。"><a href="#之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。" class="headerlink" title="之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。"></a>之前的文章我们分析了AQS这个并发框架的逻辑，本文再对同在JUC包中的一种锁的具体实现进行一下分析。</h4><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h4 id="ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定"><a href="#ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定" class="headerlink" title="ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定"></a>ReentrantLock实现了Lock的接口，用于对代码中的并发控制，内部实现了一个AQS的子类实现。有公平和非公平两种模式。模式选择在初始化的时候就已经选定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ReentrantLock(boolean fair) &#123;</span><br><span class="line">    sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类"><a href="#可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类" class="headerlink" title="可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类"></a>可以看到默认实现是非公平的。所以源码的重点就是这两个类FairSync和NonfairSync。进一步可以看到，这两个类都是继承自内部类Sync。所以我们先看到这个统一的父类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 继承实现了AQS，使用了独占模式</span><br><span class="line">	abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">       private static final long serialVersionUID = -5179523762034025860L;</span><br><span class="line"></span><br><span class="line">       abstract void lock();</span><br><span class="line">	// 这是非公平锁独有的抢占方法</span><br><span class="line">       final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           // 如果当前资源为0，则代表可以开始抢占</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           	// 用CAS的方式将资源改成抢占后的值，一般都是+1</span><br><span class="line">               if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">               	// 表示当前线程已经独占了锁</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果当前锁已经被抢占，而且正是被当前线程抢占，则可以直接再次进入锁</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0) // overflow</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">	// 继承实现了独占模式的释放资源的抽象方法</span><br><span class="line">       protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">       	// 在ReentrantLock中，得到资源之后会将state + 1;释放之后 再 -1</span><br><span class="line">       	// 所以得到的c的值表示是否已经将所有加锁的资源释放</span><br><span class="line">       	// 例如 初始state = 0，此时 线程A第一次得到了锁，则state += 1，同理多次得到会多次+1</span><br><span class="line">       	// 然后依次释放，依次-1</span><br><span class="line">           int c = getState() - releases;</span><br><span class="line">           // 只有当前线程是抢占到资源的线程时才可以释放</span><br><span class="line">           if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               throw new IllegalMonitorStateException();</span><br><span class="line">           // 标志是否完全可以供抢占</span><br><span class="line">           boolean free = false;</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           	// 如上分析，c==0，代表线程完全释放了资源，</span><br><span class="line">               free = true;</span><br><span class="line">             // 表示当前没有线程抢占了资源</span><br><span class="line">               setExclusiveOwnerThread(null);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           return free;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       protected final boolean isHeldExclusively() &#123;</span><br><span class="line">           // While we must in general read state before owner,</span><br><span class="line">           // we don&apos;t need to do so to check if current thread is owner</span><br><span class="line">           return getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁"><a href="#在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁" class="headerlink" title="在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁"></a>在ReentrantLock的内部类Sync的实现就是如上。接下来看到他的子类，公平锁和非公平锁的实现。先看到非公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">        * acquire on failure.</span><br><span class="line">        */</span><br><span class="line">       // 抢占锁 </span><br><span class="line">       final void lock() &#123;</span><br><span class="line">       	// 直接先尝试用CAS的方式，改变资源的状态</span><br><span class="line">           if (compareAndSetState(0, 1))</span><br><span class="line">           	// 如果CAS成功，则看做已经得到了锁，直接将独占线程改为自己</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           else</span><br><span class="line">           	// 如果CAS没有成功，则进入正常的AQS抢占流程</span><br><span class="line">               acquire(1);</span><br><span class="line">       &#125;</span><br><span class="line">	// 抽象方法直接使用了Sync中的非公平抢占实现</span><br><span class="line">       protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           return nonfairTryAcquire(acquires);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="再看看公平锁"><a href="#再看看公平锁" class="headerlink" title="再看看公平锁"></a>再看看公平锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;</span><br><span class="line">       private static final long serialVersionUID = -3000897897090466540L;</span><br><span class="line"></span><br><span class="line">       final void lock() &#123;</span><br><span class="line">       	// 直接进行AQS抢占流程</span><br><span class="line">           acquire(1);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * Fair version of tryAcquire.  Don&apos;t grant access unless</span><br><span class="line">        * recursive call or no waiters or is first.</span><br><span class="line">        */</span><br><span class="line">        // 抽象方法的实现，可以看到和非公平的方式基本相同</span><br><span class="line">       protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">           		// 只有多了一个这个判断</span><br><span class="line">           		// 就是判断在AQS的等待队列中，是否已经有其他节点在等待</span><br><span class="line">           		// 如果没有，则直接调用</span><br><span class="line">           		// 也就是公平锁代表不能插队</span><br><span class="line">               if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                   compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0)</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。"><a href="#所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。" class="headerlink" title="所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。"></a>所以看到公平锁和非公平锁的区别就体现在，在尝试获取资源的时候，是否可以插队获取。</h4><h4 id="进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。"><a href="#进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。" class="headerlink" title="进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。"></a>进一步看到这个tryAcquire方法，也就是公平锁和非公平锁具体差异的地方。假设此时在AQS内部已经有一个等待者队列吗。head节点释放了资源，应该去唤醒后续的节点开始竞争，假设此时非公平锁开始插队竞争，而且成功的话。那么在等待者队列中的节点将没有资源再Park了，就会一直不停的永真循环去尝试获取资源。</h4>
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Swaggy Q</p>
              <div class="site-description motion-element" itemprop="description">拉塞尔FMVP了吗</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">30</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Swaggy Q</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
